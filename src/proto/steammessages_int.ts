// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steammessages_int.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgWebAPIKey
 */
export interface CMsgWebAPIKey {
    /**
     * @generated from protobuf field: optional uint32 status = 1;
     */
    status?: number;
    /**
     * @generated from protobuf field: optional uint32 account_id = 2;
     */
    accountId?: number;
    /**
     * @generated from protobuf field: optional uint32 publisher_group_id = 3;
     */
    publisherGroupId?: number;
    /**
     * @generated from protobuf field: optional uint32 key_id = 4;
     */
    keyId?: number;
    /**
     * @generated from protobuf field: optional string domain = 5;
     */
    domain?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest
 */
export interface CMsgHttpRequest {
    /**
     * @generated from protobuf field: optional uint32 request_method = 1;
     */
    requestMethod?: number;
    /**
     * @generated from protobuf field: optional string hostname = 2;
     */
    hostname?: string;
    /**
     * @generated from protobuf field: optional string url = 3;
     */
    url?: string;
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.RequestHeader headers = 4;
     */
    headers: CMsgHttpRequest_RequestHeader[];
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam get_params = 5;
     */
    getParams: CMsgHttpRequest_QueryParam[];
    /**
     * @generated from protobuf field: repeated CMsgHttpRequest.QueryParam post_params = 6;
     */
    postParams: CMsgHttpRequest_QueryParam[];
    /**
     * @generated from protobuf field: optional bytes body = 7;
     */
    body?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 absolute_timeout = 8;
     */
    absoluteTimeout?: number;
    /**
     * @generated from protobuf field: optional bool use_https = 9;
     */
    useHttps?: boolean;
}
/**
 * @generated from protobuf message CMsgHttpRequest.RequestHeader
 */
export interface CMsgHttpRequest_RequestHeader {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgHttpRequest.QueryParam
 */
export interface CMsgHttpRequest_QueryParam {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgWebAPIRequest
 */
export interface CMsgWebAPIRequest {
    /**
     * @generated from protobuf field: optional string interface_name = 2;
     */
    interfaceName?: string;
    /**
     * @generated from protobuf field: optional string method_name = 3;
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional uint32 version = 4;
     */
    version?: number;
    /**
     * @generated from protobuf field: optional CMsgWebAPIKey api_key = 5;
     */
    apiKey?: CMsgWebAPIKey;
    /**
     * @generated from protobuf field: optional CMsgHttpRequest request = 6;
     */
    request?: CMsgHttpRequest;
    /**
     * @generated from protobuf field: optional uint32 routing_app_id = 7;
     */
    routingAppId?: number;
}
/**
 * @generated from protobuf message CMsgHttpResponse
 */
export interface CMsgHttpResponse {
    /**
     * @generated from protobuf field: optional uint32 status_code = 1;
     */
    statusCode?: number;
    /**
     * @generated from protobuf field: repeated CMsgHttpResponse.ResponseHeader headers = 2;
     */
    headers: CMsgHttpResponse_ResponseHeader[];
    /**
     * @generated from protobuf field: optional bytes body = 3;
     */
    body?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgHttpResponse.ResponseHeader
 */
export interface CMsgHttpResponse_ResponseHeader {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccounts
 */
export interface CMsgAMFindAccounts {
    /**
     * @generated from protobuf field: optional uint32 search_type = 1;
     */
    searchType?: number;
    /**
     * @generated from protobuf field: optional string search_string = 2;
     */
    searchString?: string;
}
/**
 * @generated from protobuf message CMsgAMFindAccountsResponse
 */
export interface CMsgAMFindAccountsResponse {
    /**
     * @generated from protobuf field: repeated fixed64 steam_id = 1;
     */
    steamId: bigint[];
}
/**
 * @generated from protobuf message CMsgNotifyWatchdog
 */
export interface CMsgNotifyWatchdog {
    /**
     * @generated from protobuf field: optional uint32 source = 1;
     */
    source?: number;
    /**
     * @generated from protobuf field: optional uint32 alert_type = 2;
     */
    alertType?: number;
    /**
     * @generated from protobuf field: optional bool critical = 4;
     */
    critical?: boolean;
    /**
     * @generated from protobuf field: optional uint32 time = 5;
     */
    time?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 6;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string text = 7;
     */
    text?: string;
    /**
     * @generated from protobuf field: optional string recipient = 12;
     */
    recipient?: string;
}
/**
 * @generated from protobuf message CMsgAMGetLicenses
 */
export interface CMsgAMGetLicenses {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgPackageLicense
 */
export interface CMsgPackageLicense {
    /**
     * @generated from protobuf field: optional uint32 package_id = 1;
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional uint32 time_created = 2;
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional uint32 owner_id = 3;
     */
    ownerId?: number;
}
/**
 * @generated from protobuf message CMsgAMGetLicensesResponse
 */
export interface CMsgAMGetLicensesResponse {
    /**
     * @generated from protobuf field: repeated CMsgPackageLicense license = 1;
     */
    license: CMsgPackageLicense[];
    /**
     * @generated from protobuf field: optional uint32 result = 2;
     */
    result?: number;
}
/**
 * @generated from protobuf message CMsgGCGetCommandList
 */
export interface CMsgGCGetCommandList {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional string command_prefix = 2;
     */
    commandPrefix?: string;
}
/**
 * @generated from protobuf message CMsgGCGetCommandListResponse
 */
export interface CMsgGCGetCommandListResponse {
    /**
     * @generated from protobuf field: repeated string command_name = 1;
     */
    commandName: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGet
 */
export interface CGCMsgMemCachedGet {
    /**
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse
 */
export interface CGCMsgMemCachedGetResponse {
    /**
     * @generated from protobuf field: repeated CGCMsgMemCachedGetResponse.ValueTag values = 1;
     */
    values: CGCMsgMemCachedGetResponse_ValueTag[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export interface CGCMsgMemCachedGetResponse_ValueTag {
    /**
     * @generated from protobuf field: optional bool found = 1;
     */
    found?: boolean;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet
 */
export interface CGCMsgMemCachedSet {
    /**
     * @generated from protobuf field: repeated CGCMsgMemCachedSet.KeyPair keys = 1;
     */
    keys: CGCMsgMemCachedSet_KeyPair[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedSet.KeyPair
 */
export interface CGCMsgMemCachedSet_KeyPair {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional bytes value = 2;
     */
    value?: Uint8Array;
}
/**
 * @generated from protobuf message CGCMsgMemCachedDelete
 */
export interface CGCMsgMemCachedDelete {
    /**
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
}
/**
 * @generated from protobuf message CGCMsgMemCachedStats
 */
export interface CGCMsgMemCachedStats {
}
/**
 * @generated from protobuf message CGCMsgMemCachedStatsResponse
 */
export interface CGCMsgMemCachedStatsResponse {
    /**
     * @generated from protobuf field: optional uint64 curr_connections = 1;
     */
    currConnections?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_get = 2;
     */
    cmdGet?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_set = 3;
     */
    cmdSet?: bigint;
    /**
     * @generated from protobuf field: optional uint64 cmd_flush = 4;
     */
    cmdFlush?: bigint;
    /**
     * @generated from protobuf field: optional uint64 get_hits = 5;
     */
    getHits?: bigint;
    /**
     * @generated from protobuf field: optional uint64 get_misses = 6;
     */
    getMisses?: bigint;
    /**
     * @generated from protobuf field: optional uint64 delete_hits = 7;
     */
    deleteHits?: bigint;
    /**
     * @generated from protobuf field: optional uint64 delete_misses = 8;
     */
    deleteMisses?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_read = 9;
     */
    bytesRead?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes_written = 10;
     */
    bytesWritten?: bigint;
    /**
     * @generated from protobuf field: optional uint64 limit_maxbytes = 11;
     */
    limitMaxbytes?: bigint;
    /**
     * @generated from protobuf field: optional uint64 curr_items = 12;
     */
    currItems?: bigint;
    /**
     * @generated from protobuf field: optional uint64 evictions = 13;
     */
    evictions?: bigint;
    /**
     * @generated from protobuf field: optional uint64 bytes = 14;
     */
    bytes?: bigint;
}
/**
 * @generated from protobuf message CGCMsgSQLStats
 */
export interface CGCMsgSQLStats {
    /**
     * @generated from protobuf field: optional uint32 schema_catalog = 1;
     */
    schemaCatalog?: number;
}
/**
 * @generated from protobuf message CGCMsgSQLStatsResponse
 */
export interface CGCMsgSQLStatsResponse {
    /**
     * @generated from protobuf field: optional uint32 threads = 1;
     */
    threads?: number;
    /**
     * @generated from protobuf field: optional uint32 threads_connected = 2;
     */
    threadsConnected?: number;
    /**
     * @generated from protobuf field: optional uint32 threads_active = 3;
     */
    threadsActive?: number;
    /**
     * @generated from protobuf field: optional uint32 operations_submitted = 4;
     */
    operationsSubmitted?: number;
    /**
     * @generated from protobuf field: optional uint32 prepared_statements_executed = 5;
     */
    preparedStatementsExecuted?: number;
    /**
     * @generated from protobuf field: optional uint32 non_prepared_statements_executed = 6;
     */
    nonPreparedStatementsExecuted?: number;
    /**
     * @generated from protobuf field: optional uint32 deadlock_retries = 7;
     */
    deadlockRetries?: number;
    /**
     * @generated from protobuf field: optional uint32 operations_timed_out_in_queue = 8;
     */
    operationsTimedOutInQueue?: number;
    /**
     * @generated from protobuf field: optional uint32 errors = 9;
     */
    errors?: number;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicense
 */
export interface CMsgAMAddFreeLicense {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 ip_public = 2;
     */
    ipPublic?: number;
    /**
     * @generated from protobuf field: optional uint32 packageid = 3;
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional string store_country_code = 4;
     */
    storeCountryCode?: string;
}
/**
 * @generated from protobuf message CMsgAMAddFreeLicenseResponse
 */
export interface CMsgAMAddFreeLicenseResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 purchase_result_detail = 2;
     */
    purchaseResultDetail?: number;
    /**
     * @generated from protobuf field: optional fixed64 transid = 3;
     */
    transid?: bigint;
}
/**
 * @generated from protobuf message CGCMsgGetIPLocation
 */
export interface CGCMsgGetIPLocation {
    /**
     * @generated from protobuf field: repeated fixed32 ips = 1;
     */
    ips: number[];
}
/**
 * @generated from protobuf message CGCMsgGetIPASN
 */
export interface CGCMsgGetIPASN {
    /**
     * @generated from protobuf field: repeated fixed32 ips = 1;
     */
    ips: number[];
}
/**
 * @generated from protobuf message CIPASNInfo
 */
export interface CIPASNInfo {
    /**
     * @generated from protobuf field: optional fixed32 ip = 1;
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional uint32 asn = 2;
     */
    asn?: number;
}
/**
 * @generated from protobuf message CGCMsgGetIPASNResponse
 */
export interface CGCMsgGetIPASNResponse {
    /**
     * @generated from protobuf field: repeated CIPASNInfo infos = 1;
     */
    infos: CIPASNInfo[];
}
/**
 * @generated from protobuf message CMsgAMSendEmail
 */
export interface CMsgAMSendEmail {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 email_msg_type = 2;
     */
    emailMsgType?: number;
    /**
     * @generated from protobuf field: optional uint32 email_format = 3;
     */
    emailFormat?: number;
    /**
     * @generated from protobuf field: repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5;
     */
    personaNameTokens: CMsgAMSendEmail_PersonaNameReplacementToken[];
    /**
     * @generated from protobuf field: optional uint32 source_gc = 6;
     */
    sourceGc?: number;
    /**
     * @generated from protobuf field: repeated CMsgAMSendEmail.ReplacementToken tokens = 7;
     */
    tokens: CMsgAMSendEmail_ReplacementToken[];
}
/**
 * @generated from protobuf message CMsgAMSendEmail.ReplacementToken
 */
export interface CMsgAMSendEmail_ReplacementToken {
    /**
     * @generated from protobuf field: optional string token_name = 1;
     */
    tokenName?: string;
    /**
     * @generated from protobuf field: optional string token_value = 2;
     */
    tokenValue?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export interface CMsgAMSendEmail_PersonaNameReplacementToken {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string token_name = 2;
     */
    tokenName?: string;
}
/**
 * @generated from protobuf message CMsgAMSendEmailResponse
 */
export interface CMsgAMSendEmailResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplate
 */
export interface CMsgGCGetEmailTemplate {
    /**
     * @generated from protobuf field: optional uint32 app_id = 1;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 email_msg_type = 2;
     */
    emailMsgType?: number;
    /**
     * @generated from protobuf field: optional int32 email_lang = 3;
     */
    emailLang?: number;
    /**
     * @generated from protobuf field: optional int32 email_format = 4;
     */
    emailFormat?: number;
}
/**
 * @generated from protobuf message CMsgGCGetEmailTemplateResponse
 */
export interface CMsgGCGetEmailTemplateResponse {
    /**
     * @generated from protobuf field: optional uint32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional bool template_exists = 2;
     */
    templateExists?: boolean;
    /**
     * @generated from protobuf field: optional string template = 3;
     */
    template?: string;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2
 */
export interface CMsgAMGrantGuestPasses2 {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 package_id = 2;
     */
    packageId?: number;
    /**
     * @generated from protobuf field: optional int32 passes_to_grant = 3;
     */
    passesToGrant?: number;
    /**
     * @generated from protobuf field: optional int32 days_to_expiration = 4;
     */
    daysToExpiration?: number;
    /**
     * @generated from protobuf field: optional int32 action = 5;
     */
    action?: number;
}
/**
 * @generated from protobuf message CMsgAMGrantGuestPasses2Response
 */
export interface CMsgAMGrantGuestPasses2Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional int32 passes_granted = 2;
     */
    passesGranted?: number;
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames
 */
export interface CMsgGCGetPersonaNames {
    /**
     * @generated from protobuf field: repeated fixed64 steamids = 1;
     */
    steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response
 */
export interface CMsgGCGetPersonaNames_Response {
    /**
     * @generated from protobuf field: repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1;
     */
    succeededLookups: CMsgGCGetPersonaNames_Response_PersonaName[];
    /**
     * @generated from protobuf field: repeated fixed64 failed_lookup_steamids = 2;
     */
    failedLookupSteamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export interface CMsgGCGetPersonaNames_Response_PersonaName {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string persona_name = 2;
     */
    personaName?: string;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship
 */
export interface CMsgGCCheckFriendship {
    /**
     * @generated from protobuf field: optional fixed64 steamid_left = 1;
     */
    steamidLeft?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 steamid_right = 2;
     */
    steamidRight?: bigint;
}
/**
 * @generated from protobuf message CMsgGCCheckFriendship_Response
 */
export interface CMsgGCCheckFriendship_Response {
    /**
     * @generated from protobuf field: optional bool success = 1;
     */
    success?: boolean;
    /**
     * @generated from protobuf field: optional bool found_friendship = 2;
     */
    foundFriendship?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetAppFriendsList
 */
export interface CMsgGCGetAppFriendsList {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional bool include_friendship_timestamps = 2;
     */
    includeFriendshipTimestamps?: boolean;
    /**
     * @generated from protobuf field: optional bool include_friends_with_no_play_time = 3;
     */
    includeFriendsWithNoPlayTime?: boolean;
}
/**
 * @generated from protobuf message CMsgGCGetAppFriendsList_Response
 */
export interface CMsgGCGetAppFriendsList_Response {
    /**
     * @generated from protobuf field: optional bool success = 1;
     */
    success?: boolean;
    /**
     * @generated from protobuf field: repeated fixed64 steamids = 2;
     */
    steamids: bigint[];
    /**
     * @generated from protobuf field: repeated fixed32 friendship_timestamps = 3;
     */
    friendshipTimestamps: number[];
    /**
     * @generated from protobuf field: repeated fixed32 last_playtimes = 4;
     */
    lastPlaytimes: number[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory
 */
export interface CMsgGCMsgMasterSetDirectory {
    /**
     * @generated from protobuf field: optional int32 master_dir_index = 1;
     */
    masterDirIndex?: number;
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2;
     */
    dir: CMsgGCMsgMasterSetDirectory_SubGC[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export interface CMsgGCMsgMasterSetDirectory_SubGC {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string box = 3;
     */
    box?: string;
    /**
     * @generated from protobuf field: optional string command_line = 4;
     */
    commandLine?: string;
    /**
     * @generated from protobuf field: optional string gc_binary = 5;
     */
    gcBinary?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export interface CMsgGCMsgMasterSetDirectory_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string message = 2;
     */
    message?: string;
}
/**
 * @generated from protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export interface CMsgGCMsgWebAPIJobRequestForwardResponse {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export interface CGCSystemMsg_GetPurchaseTrust_Request {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export interface CGCSystemMsg_GetPurchaseTrust_Response {
    /**
     * @generated from protobuf field: optional bool has_prior_purchase_history = 1;
     */
    hasPriorPurchaseHistory?: boolean;
    /**
     * @generated from protobuf field: optional bool has_no_recent_password_resets = 2;
     */
    hasNoRecentPasswordResets?: boolean;
    /**
     * @generated from protobuf field: optional bool is_wallet_cash_trusted = 3;
     */
    isWalletCashTrusted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 time_all_trusted = 4;
     */
    timeAllTrusted?: number;
}
/**
 * @generated from protobuf message CMsgGCHAccountVacStatusChange
 */
export interface CMsgGCHAccountVacStatusChange {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime_vacban_starts = 3;
     */
    rtimeVacbanStarts?: number;
    /**
     * @generated from protobuf field: optional bool is_banned_now = 4;
     */
    isBannedNow?: boolean;
    /**
     * @generated from protobuf field: optional bool is_banned_future = 5;
     */
    isBannedFuture?: boolean;
}
/**
 * @generated from protobuf message CMsgGCRoutingInfo
 */
export interface CMsgGCRoutingInfo {
    /**
     * @generated from protobuf field: repeated int32 dir_index = 1;
     */
    dirIndex: number[];
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod method = 2;
     */
    method?: CMsgGCRoutingInfo_RoutingMethod;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo.RoutingMethod fallback = 3;
     */
    fallback?: CMsgGCRoutingInfo_RoutingMethod;
    /**
     * @generated from protobuf field: optional uint32 protobuf_field = 4;
     */
    protobufField?: number;
    /**
     * @generated from protobuf field: optional string webapi_param = 5;
     */
    webapiParam?: string;
}
/**
 * @generated from protobuf enum CMsgGCRoutingInfo.RoutingMethod
 */
export enum CMsgGCRoutingInfo_RoutingMethod {
    /**
     * @generated from protobuf enum value: RANDOM = 0;
     */
    RANDOM = 0,
    /**
     * @generated from protobuf enum value: DISCARD = 1;
     */
    DISCARD = 1,
    /**
     * @generated from protobuf enum value: CLIENT_STEAMID = 2;
     */
    CLIENT_STEAMID = 2,
    /**
     * @generated from protobuf enum value: PROTOBUF_FIELD_UINT64 = 3;
     */
    PROTOBUF_FIELD_UINT64 = 3,
    /**
     * @generated from protobuf enum value: WEBAPI_PARAM = 4;
     */
    WEBAPI_PARAM = 4,
    /**
     * @generated from protobuf enum value: WEBAPI_PARAM_STEAMID_ACCOUNTID = 5;
     */
    WEBAPI_PARAM_STEAMID_ACCOUNTID = 5
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export interface CMsgGCMsgMasterSetWebAPIRouting {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1;
     */
    entries: CMsgGCMsgMasterSetWebAPIRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Entry {
    /**
     * @generated from protobuf field: optional string interface_name = 1;
     */
    interfaceName?: string;
    /**
     * @generated from protobuf field: optional string method_name = 2;
     */
    methodName?: string;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 3;
     */
    routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export interface CMsgGCMsgMasterSetClientMsgRouting {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1;
     */
    entries: CMsgGCMsgMasterSetClientMsgRouting_Entry[];
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Entry {
    /**
     * @generated from protobuf field: optional uint32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional CMsgGCRoutingInfo routing = 2;
     */
    routing?: CMsgGCRoutingInfo;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export interface CMsgGCMsgMasterSetWebAPIRouting_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export interface CMsgGCMsgMasterSetClientMsgRouting_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions
 */
export interface CMsgGCMsgSetOptions {
    /**
     * @generated from protobuf field: repeated CMsgGCMsgSetOptions.Option options = 1;
     */
    options: CMsgGCMsgSetOptions_Option[];
    /**
     * @generated from protobuf field: repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2;
     */
    clientMsgRanges: CMsgGCMsgSetOptions_MessageRange[];
    /**
     * @generated from protobuf field: optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version = 3;
     */
    gcsqlVersion?: CMsgGCMsgSetOptions_GCSQLVersion;
}
/**
 * @generated from protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export interface CMsgGCMsgSetOptions_MessageRange {
    /**
     * @generated from protobuf field: uint32 low = 1;
     */
    low: number;
    /**
     * @generated from protobuf field: uint32 high = 2;
     */
    high: number;
}
/**
 * @generated from protobuf enum CMsgGCMsgSetOptions.Option
 */
export enum CMsgGCMsgSetOptions_Option {
    /**
     * @generated from protobuf enum value: NOTIFY_USER_SESSIONS = 0;
     */
    NOTIFY_USER_SESSIONS = 0,
    /**
     * @generated from protobuf enum value: NOTIFY_SERVER_SESSIONS = 1;
     */
    NOTIFY_SERVER_SESSIONS = 1,
    /**
     * @generated from protobuf enum value: NOTIFY_ACHIEVEMENTS = 2;
     */
    NOTIFY_ACHIEVEMENTS = 2,
    /**
     * @generated from protobuf enum value: NOTIFY_VAC_ACTION = 3;
     */
    NOTIFY_VAC_ACTION = 3
}
/**
 * @generated from protobuf enum CMsgGCMsgSetOptions.GCSQLVersion
 */
export enum CMsgGCMsgSetOptions_GCSQLVersion {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: GCSQL_VERSION_BASELINE = 1;
     */
    GCSQL_VERSION_BASELINE = 1,
    /**
     * @generated from protobuf enum value: GCSQL_VERSION_BOOLTYPE = 2;
     */
    GCSQL_VERSION_BOOLTYPE = 2
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession
 */
export interface CMsgGCHUpdateSession {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 1;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 app_id = 2;
     */
    appId?: number;
    /**
     * @generated from protobuf field: optional bool online = 3;
     */
    online?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 server_steam_id = 4;
     */
    serverSteamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 server_addr = 5;
     */
    serverAddr?: number;
    /**
     * @generated from protobuf field: optional uint32 server_port = 6;
     */
    serverPort?: number;
    /**
     * @generated from protobuf field: optional uint32 os_type = 7;
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional uint32 client_addr = 8;
     */
    clientAddr?: number;
    /**
     * @generated from protobuf field: repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9;
     */
    extraFields: CMsgGCHUpdateSession_ExtraField[];
}
/**
 * @generated from protobuf message CMsgGCHUpdateSession.ExtraField
 */
export interface CMsgGCHUpdateSession_ExtraField {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity
 */
export interface CMsgNotificationOfSuspiciousActivity {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 appid = 2;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3;
     */
    multipleInstances?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances;
}
/**
 * @generated from protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export interface CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    /**
     * @generated from protobuf field: optional uint32 app_instance_count = 1;
     */
    appInstanceCount?: number;
    /**
     * @generated from protobuf field: repeated fixed64 other_steamids = 2;
     */
    otherSteamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCHVacVerificationChange
 */
export interface CMsgGCHVacVerificationChange {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 appid = 2;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool is_verified = 3;
     */
    isVerified?: boolean;
}
/**
 * @generated from protobuf message CMsgGCCheckClanMembership
 */
export interface CMsgGCCheckClanMembership {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 clanid = 2;
     */
    clanid?: number;
}
/**
 * @generated from protobuf message CMsgGCCheckClanMembership_Response
 */
export interface CMsgGCCheckClanMembership_Response {
    /**
     * @generated from protobuf field: optional bool ismember = 1;
     */
    ismember?: boolean;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived
 */
export interface CMsgGCHAppCheersReceived {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets = 2;
     */
    cheerTargets: CMsgGCHAppCheersReceived_CheerTarget[];
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived.CheerTypeAmount
 */
export interface CMsgGCHAppCheersReceived_CheerTypeAmount {
    /**
     * @generated from protobuf field: optional uint32 cheer_type = 1;
     */
    cheerType?: number;
    /**
     * @generated from protobuf field: optional uint32 cheer_amount = 2;
     */
    cheerAmount?: number;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersReceived.CheerTarget
 */
export interface CMsgGCHAppCheersReceived_CheerTarget {
    /**
     * @generated from protobuf field: optional uint64 cheer_target = 1;
     */
    cheerTarget?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types = 2;
     */
    cheerTypes: CMsgGCHAppCheersReceived_CheerTypeAmount[];
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypes
 */
export interface CMsgGCHAppCheersGetAllowedTypes {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint64 cheer_target = 2;
     */
    cheerTarget?: bigint;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypesResponse
 */
export interface CMsgGCHAppCheersGetAllowedTypesResponse {
    /**
     * @generated from protobuf field: repeated uint32 cheer_types_valid_all_users = 1;
     */
    cheerTypesValidAllUsers: number[];
    /**
     * @generated from protobuf field: repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps = 2;
     */
    cheerRemaps: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps[];
    /**
     * @generated from protobuf field: optional uint32 cache_duration = 3;
     */
    cacheDuration?: number;
}
/**
 * @generated from protobuf message CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps
 */
export interface CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
    /**
     * @generated from protobuf field: optional uint32 original_cheer_type = 1;
     */
    originalCheerType?: number;
    /**
     * @generated from protobuf field: optional uint32 remapped_cheer_type = 2;
     */
    remappedCheerType?: number;
    /**
     * @generated from protobuf field: repeated uint32 account_ids = 3;
     */
    accountIds: number[];
}
/**
 * @generated from protobuf message CWorkshop_AddSpecialPayment_Request
 */
export interface CWorkshop_AddSpecialPayment_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 2;
     */
    gameitemid?: number;
    /**
     * @generated from protobuf field: optional string date = 3;
     */
    date?: string;
    /**
     * @generated from protobuf field: optional uint64 payment_us_usd = 4;
     */
    paymentUsUsd?: bigint;
    /**
     * @generated from protobuf field: optional uint64 payment_row_usd = 5;
     */
    paymentRowUsd?: bigint;
}
/**
 * @generated from protobuf message CWorkshop_AddSpecialPayment_Response
 */
export interface CWorkshop_AddSpecialPayment_Response {
}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Request
 */
export interface CWorkshop_GetSpecialPayments_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 2;
     */
    gameitemid?: number;
    /**
     * @generated from protobuf field: optional string date = 3;
     */
    date?: string;
}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Response
 */
export interface CWorkshop_GetSpecialPayments_Response {
    /**
     * @generated from protobuf field: repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments = 1;
     */
    specialPayments: CWorkshop_GetSpecialPayments_Response_SpecialPayment[];
}
/**
 * @generated from protobuf message CWorkshop_GetSpecialPayments_Response.SpecialPayment
 */
export interface CWorkshop_GetSpecialPayments_Response_SpecialPayment {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 2;
     */
    gameitemid?: number;
    /**
     * @generated from protobuf field: optional string date = 3;
     */
    date?: string;
    /**
     * @generated from protobuf field: optional uint64 net_payment_us_usd = 4;
     */
    netPaymentUsUsd?: bigint;
    /**
     * @generated from protobuf field: optional uint64 net_payment_row_usd = 5;
     */
    netPaymentRowUsd?: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIKey$Type extends MessageType<CMsgWebAPIKey> {
    constructor() {
        super("CMsgWebAPIKey", [
            { no: 1, name: "status", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "publisher_group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "key_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "domain", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgWebAPIKey>): CMsgWebAPIKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgWebAPIKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgWebAPIKey): CMsgWebAPIKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* optional uint32 account_id */ 2:
                    message.accountId = reader.uint32();
                    break;
                case /* optional uint32 publisher_group_id */ 3:
                    message.publisherGroupId = reader.uint32();
                    break;
                case /* optional uint32 key_id */ 4:
                    message.keyId = reader.uint32();
                    break;
                case /* optional string domain */ 5:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgWebAPIKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* optional uint32 account_id = 2; */
        if (message.accountId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.accountId);
        /* optional uint32 publisher_group_id = 3; */
        if (message.publisherGroupId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.publisherGroupId);
        /* optional uint32 key_id = 4; */
        if (message.keyId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.keyId);
        /* optional string domain = 5; */
        if (message.domain !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIKey
 */
export const CMsgWebAPIKey = new CMsgWebAPIKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest$Type extends MessageType<CMsgHttpRequest> {
    constructor() {
        super("CMsgHttpRequest", [
            { no: 1, name: "request_method", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_RequestHeader },
            { no: 5, name: "get_params", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_QueryParam },
            { no: 6, name: "post_params", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpRequest_QueryParam },
            { no: 7, name: "body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "absolute_timeout", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "use_https", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest>): CMsgHttpRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        message.getParams = [];
        message.postParams = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest): CMsgHttpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 request_method */ 1:
                    message.requestMethod = reader.uint32();
                    break;
                case /* optional string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* optional string url */ 3:
                    message.url = reader.string();
                    break;
                case /* repeated CMsgHttpRequest.RequestHeader headers */ 4:
                    message.headers.push(CMsgHttpRequest_RequestHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgHttpRequest.QueryParam get_params */ 5:
                    message.getParams.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgHttpRequest.QueryParam post_params */ 6:
                    message.postParams.push(CMsgHttpRequest_QueryParam.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes body */ 7:
                    message.body = reader.bytes();
                    break;
                case /* optional uint32 absolute_timeout */ 8:
                    message.absoluteTimeout = reader.uint32();
                    break;
                case /* optional bool use_https */ 9:
                    message.useHttps = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 request_method = 1; */
        if (message.requestMethod !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.requestMethod);
        /* optional string hostname = 2; */
        if (message.hostname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* optional string url = 3; */
        if (message.url !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* repeated CMsgHttpRequest.RequestHeader headers = 4; */
        for (let i = 0; i < message.headers.length; i++)
            CMsgHttpRequest_RequestHeader.internalBinaryWrite(message.headers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgHttpRequest.QueryParam get_params = 5; */
        for (let i = 0; i < message.getParams.length; i++)
            CMsgHttpRequest_QueryParam.internalBinaryWrite(message.getParams[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgHttpRequest.QueryParam post_params = 6; */
        for (let i = 0; i < message.postParams.length; i++)
            CMsgHttpRequest_QueryParam.internalBinaryWrite(message.postParams[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes body = 7; */
        if (message.body !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.body);
        /* optional uint32 absolute_timeout = 8; */
        if (message.absoluteTimeout !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.absoluteTimeout);
        /* optional bool use_https = 9; */
        if (message.useHttps !== undefined)
            writer.tag(9, WireType.Varint).bool(message.useHttps);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest
 */
export const CMsgHttpRequest = new CMsgHttpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_RequestHeader$Type extends MessageType<CMsgHttpRequest_RequestHeader> {
    constructor() {
        super("CMsgHttpRequest.RequestHeader", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest_RequestHeader>): CMsgHttpRequest_RequestHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest_RequestHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest_RequestHeader): CMsgHttpRequest_RequestHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest_RequestHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.RequestHeader
 */
export const CMsgHttpRequest_RequestHeader = new CMsgHttpRequest_RequestHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpRequest_QueryParam$Type extends MessageType<CMsgHttpRequest_QueryParam> {
    constructor() {
        super("CMsgHttpRequest.QueryParam", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpRequest_QueryParam>): CMsgHttpRequest_QueryParam {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpRequest_QueryParam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpRequest_QueryParam): CMsgHttpRequest_QueryParam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpRequest_QueryParam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpRequest.QueryParam
 */
export const CMsgHttpRequest_QueryParam = new CMsgHttpRequest_QueryParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgWebAPIRequest$Type extends MessageType<CMsgWebAPIRequest> {
    constructor() {
        super("CMsgWebAPIRequest", [
            { no: 2, name: "interface_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "api_key", kind: "message", T: () => CMsgWebAPIKey },
            { no: 6, name: "request", kind: "message", T: () => CMsgHttpRequest },
            { no: 7, name: "routing_app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgWebAPIRequest>): CMsgWebAPIRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgWebAPIRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgWebAPIRequest): CMsgWebAPIRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string interface_name */ 2:
                    message.interfaceName = reader.string();
                    break;
                case /* optional string method_name */ 3:
                    message.methodName = reader.string();
                    break;
                case /* optional uint32 version */ 4:
                    message.version = reader.uint32();
                    break;
                case /* optional CMsgWebAPIKey api_key */ 5:
                    message.apiKey = CMsgWebAPIKey.internalBinaryRead(reader, reader.uint32(), options, message.apiKey);
                    break;
                case /* optional CMsgHttpRequest request */ 6:
                    message.request = CMsgHttpRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* optional uint32 routing_app_id */ 7:
                    message.routingAppId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgWebAPIRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string interface_name = 2; */
        if (message.interfaceName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.interfaceName);
        /* optional string method_name = 3; */
        if (message.methodName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.methodName);
        /* optional uint32 version = 4; */
        if (message.version !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.version);
        /* optional CMsgWebAPIKey api_key = 5; */
        if (message.apiKey)
            CMsgWebAPIKey.internalBinaryWrite(message.apiKey, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgHttpRequest request = 6; */
        if (message.request)
            CMsgHttpRequest.internalBinaryWrite(message.request, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 routing_app_id = 7; */
        if (message.routingAppId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.routingAppId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgWebAPIRequest
 */
export const CMsgWebAPIRequest = new CMsgWebAPIRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse$Type extends MessageType<CMsgHttpResponse> {
    constructor() {
        super("CMsgHttpResponse", [
            { no: 1, name: "status_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgHttpResponse_ResponseHeader },
            { no: 3, name: "body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpResponse>): CMsgHttpResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpResponse): CMsgHttpResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 status_code */ 1:
                    message.statusCode = reader.uint32();
                    break;
                case /* repeated CMsgHttpResponse.ResponseHeader headers */ 2:
                    message.headers.push(CMsgHttpResponse_ResponseHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes body */ 3:
                    message.body = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 status_code = 1; */
        if (message.statusCode !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.statusCode);
        /* repeated CMsgHttpResponse.ResponseHeader headers = 2; */
        for (let i = 0; i < message.headers.length; i++)
            CMsgHttpResponse_ResponseHeader.internalBinaryWrite(message.headers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes body = 3; */
        if (message.body !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse
 */
export const CMsgHttpResponse = new CMsgHttpResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHttpResponse_ResponseHeader$Type extends MessageType<CMsgHttpResponse_ResponseHeader> {
    constructor() {
        super("CMsgHttpResponse.ResponseHeader", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgHttpResponse_ResponseHeader>): CMsgHttpResponse_ResponseHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgHttpResponse_ResponseHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgHttpResponse_ResponseHeader): CMsgHttpResponse_ResponseHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgHttpResponse_ResponseHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgHttpResponse.ResponseHeader
 */
export const CMsgHttpResponse_ResponseHeader = new CMsgHttpResponse_ResponseHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccounts$Type extends MessageType<CMsgAMFindAccounts> {
    constructor() {
        super("CMsgAMFindAccounts", [
            { no: 1, name: "search_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "search_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMFindAccounts>): CMsgAMFindAccounts {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMFindAccounts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMFindAccounts): CMsgAMFindAccounts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 search_type */ 1:
                    message.searchType = reader.uint32();
                    break;
                case /* optional string search_string */ 2:
                    message.searchString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMFindAccounts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 search_type = 1; */
        if (message.searchType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.searchType);
        /* optional string search_string = 2; */
        if (message.searchString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.searchString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccounts
 */
export const CMsgAMFindAccounts = new CMsgAMFindAccounts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMFindAccountsResponse$Type extends MessageType<CMsgAMFindAccountsResponse> {
    constructor() {
        super("CMsgAMFindAccountsResponse", [
            { no: 1, name: "steam_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMFindAccountsResponse>): CMsgAMFindAccountsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamId = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgAMFindAccountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMFindAccountsResponse): CMsgAMFindAccountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 steam_id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamId.push(reader.fixed64().toBigInt());
                    else
                        message.steamId.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMFindAccountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 steam_id = 1; */
        for (let i = 0; i < message.steamId.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMFindAccountsResponse
 */
export const CMsgAMFindAccountsResponse = new CMsgAMFindAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotifyWatchdog$Type extends MessageType<CMsgNotifyWatchdog> {
    constructor() {
        super("CMsgNotifyWatchdog", [
            { no: 1, name: "source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "alert_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "critical", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "recipient", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNotifyWatchdog>): CMsgNotifyWatchdog {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNotifyWatchdog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotifyWatchdog): CMsgNotifyWatchdog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 source */ 1:
                    message.source = reader.uint32();
                    break;
                case /* optional uint32 alert_type */ 2:
                    message.alertType = reader.uint32();
                    break;
                case /* optional bool critical */ 4:
                    message.critical = reader.bool();
                    break;
                case /* optional uint32 time */ 5:
                    message.time = reader.uint32();
                    break;
                case /* optional uint32 appid */ 6:
                    message.appid = reader.uint32();
                    break;
                case /* optional string text */ 7:
                    message.text = reader.string();
                    break;
                case /* optional string recipient */ 12:
                    message.recipient = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotifyWatchdog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 source = 1; */
        if (message.source !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.source);
        /* optional uint32 alert_type = 2; */
        if (message.alertType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.alertType);
        /* optional bool critical = 4; */
        if (message.critical !== undefined)
            writer.tag(4, WireType.Varint).bool(message.critical);
        /* optional uint32 time = 5; */
        if (message.time !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.time);
        /* optional uint32 appid = 6; */
        if (message.appid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appid);
        /* optional string text = 7; */
        if (message.text !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.text);
        /* optional string recipient = 12; */
        if (message.recipient !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.recipient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotifyWatchdog
 */
export const CMsgNotifyWatchdog = new CMsgNotifyWatchdog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicenses$Type extends MessageType<CMsgAMGetLicenses> {
    constructor() {
        super("CMsgAMGetLicenses", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetLicenses>): CMsgAMGetLicenses {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetLicenses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetLicenses): CMsgAMGetLicenses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetLicenses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicenses
 */
export const CMsgAMGetLicenses = new CMsgAMGetLicenses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPackageLicense$Type extends MessageType<CMsgPackageLicense> {
    constructor() {
        super("CMsgPackageLicense", [
            { no: 1, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "time_created", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "owner_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgPackageLicense>): CMsgPackageLicense {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgPackageLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgPackageLicense): CMsgPackageLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 package_id */ 1:
                    message.packageId = reader.uint32();
                    break;
                case /* optional uint32 time_created */ 2:
                    message.timeCreated = reader.uint32();
                    break;
                case /* optional uint32 owner_id */ 3:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgPackageLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 package_id = 1; */
        if (message.packageId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageId);
        /* optional uint32 time_created = 2; */
        if (message.timeCreated !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.timeCreated);
        /* optional uint32 owner_id = 3; */
        if (message.ownerId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgPackageLicense
 */
export const CMsgPackageLicense = new CMsgPackageLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGetLicensesResponse$Type extends MessageType<CMsgAMGetLicensesResponse> {
    constructor() {
        super("CMsgAMGetLicensesResponse", [
            { no: 1, name: "license", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgPackageLicense },
            { no: 2, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGetLicensesResponse>): CMsgAMGetLicensesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.license = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGetLicensesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGetLicensesResponse): CMsgAMGetLicensesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgPackageLicense license */ 1:
                    message.license.push(CMsgPackageLicense.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 result */ 2:
                    message.result = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGetLicensesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgPackageLicense license = 1; */
        for (let i = 0; i < message.license.length; i++)
            CMsgPackageLicense.internalBinaryWrite(message.license[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 result = 2; */
        if (message.result !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGetLicensesResponse
 */
export const CMsgAMGetLicensesResponse = new CMsgAMGetLicensesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandList$Type extends MessageType<CMsgGCGetCommandList> {
    constructor() {
        super("CMsgGCGetCommandList", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "command_prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetCommandList>): CMsgGCGetCommandList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetCommandList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetCommandList): CMsgGCGetCommandList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional string command_prefix */ 2:
                    message.commandPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetCommandList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional string command_prefix = 2; */
        if (message.commandPrefix !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.commandPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandList
 */
export const CMsgGCGetCommandList = new CMsgGCGetCommandList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetCommandListResponse$Type extends MessageType<CMsgGCGetCommandListResponse> {
    constructor() {
        super("CMsgGCGetCommandListResponse", [
            { no: 1, name: "command_name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetCommandListResponse>): CMsgGCGetCommandListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commandName = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetCommandListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetCommandListResponse): CMsgGCGetCommandListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string command_name */ 1:
                    message.commandName.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetCommandListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string command_name = 1; */
        for (let i = 0; i < message.commandName.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.commandName[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetCommandListResponse
 */
export const CMsgGCGetCommandListResponse = new CMsgGCGetCommandListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGet$Type extends MessageType<CGCMsgMemCachedGet> {
    constructor() {
        super("CGCMsgMemCachedGet", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGet>): CGCMsgMemCachedGet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGet): CGCMsgMemCachedGet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGet
 */
export const CGCMsgMemCachedGet = new CGCMsgMemCachedGet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse$Type extends MessageType<CGCMsgMemCachedGetResponse> {
    constructor() {
        super("CGCMsgMemCachedGetResponse", [
            { no: 1, name: "values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCMsgMemCachedGetResponse_ValueTag }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGetResponse>): CGCMsgMemCachedGetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGetResponse): CGCMsgMemCachedGetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGCMsgMemCachedGetResponse.ValueTag values */ 1:
                    message.values.push(CGCMsgMemCachedGetResponse_ValueTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGCMsgMemCachedGetResponse.ValueTag values = 1; */
        for (let i = 0; i < message.values.length; i++)
            CGCMsgMemCachedGetResponse_ValueTag.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse
 */
export const CGCMsgMemCachedGetResponse = new CGCMsgMemCachedGetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedGetResponse_ValueTag$Type extends MessageType<CGCMsgMemCachedGetResponse_ValueTag> {
    constructor() {
        super("CGCMsgMemCachedGetResponse.ValueTag", [
            { no: 1, name: "found", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedGetResponse_ValueTag>): CGCMsgMemCachedGetResponse_ValueTag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedGetResponse_ValueTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedGetResponse_ValueTag): CGCMsgMemCachedGetResponse_ValueTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool found */ 1:
                    message.found = reader.bool();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedGetResponse_ValueTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool found = 1; */
        if (message.found !== undefined)
            writer.tag(1, WireType.Varint).bool(message.found);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedGetResponse.ValueTag
 */
export const CGCMsgMemCachedGetResponse_ValueTag = new CGCMsgMemCachedGetResponse_ValueTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet$Type extends MessageType<CGCMsgMemCachedSet> {
    constructor() {
        super("CGCMsgMemCachedSet", [
            { no: 1, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCMsgMemCachedSet_KeyPair }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedSet>): CGCMsgMemCachedSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedSet): CGCMsgMemCachedSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGCMsgMemCachedSet.KeyPair keys */ 1:
                    message.keys.push(CGCMsgMemCachedSet_KeyPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGCMsgMemCachedSet.KeyPair keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            CGCMsgMemCachedSet_KeyPair.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet
 */
export const CGCMsgMemCachedSet = new CGCMsgMemCachedSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedSet_KeyPair$Type extends MessageType<CGCMsgMemCachedSet_KeyPair> {
    constructor() {
        super("CGCMsgMemCachedSet.KeyPair", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedSet_KeyPair>): CGCMsgMemCachedSet_KeyPair {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedSet_KeyPair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedSet_KeyPair): CGCMsgMemCachedSet_KeyPair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedSet_KeyPair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional bytes value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedSet.KeyPair
 */
export const CGCMsgMemCachedSet_KeyPair = new CGCMsgMemCachedSet_KeyPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedDelete$Type extends MessageType<CGCMsgMemCachedDelete> {
    constructor() {
        super("CGCMsgMemCachedDelete", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedDelete>): CGCMsgMemCachedDelete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedDelete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedDelete): CGCMsgMemCachedDelete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedDelete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedDelete
 */
export const CGCMsgMemCachedDelete = new CGCMsgMemCachedDelete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStats$Type extends MessageType<CGCMsgMemCachedStats> {
    constructor() {
        super("CGCMsgMemCachedStats", []);
    }
    create(value?: PartialMessage<CGCMsgMemCachedStats>): CGCMsgMemCachedStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedStats): CGCMsgMemCachedStats {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CGCMsgMemCachedStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStats
 */
export const CGCMsgMemCachedStats = new CGCMsgMemCachedStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgMemCachedStatsResponse$Type extends MessageType<CGCMsgMemCachedStatsResponse> {
    constructor() {
        super("CGCMsgMemCachedStatsResponse", [
            { no: 1, name: "curr_connections", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cmd_get", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "cmd_set", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "cmd_flush", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "get_hits", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "get_misses", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "delete_hits", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "delete_misses", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "bytes_read", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "bytes_written", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "limit_maxbytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "curr_items", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "evictions", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "bytes", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgMemCachedStatsResponse>): CGCMsgMemCachedStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgMemCachedStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgMemCachedStatsResponse): CGCMsgMemCachedStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 curr_connections */ 1:
                    message.currConnections = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_get */ 2:
                    message.cmdGet = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_set */ 3:
                    message.cmdSet = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 cmd_flush */ 4:
                    message.cmdFlush = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 get_hits */ 5:
                    message.getHits = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 get_misses */ 6:
                    message.getMisses = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 delete_hits */ 7:
                    message.deleteHits = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 delete_misses */ 8:
                    message.deleteMisses = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_read */ 9:
                    message.bytesRead = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes_written */ 10:
                    message.bytesWritten = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 limit_maxbytes */ 11:
                    message.limitMaxbytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 curr_items */ 12:
                    message.currItems = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 evictions */ 13:
                    message.evictions = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 bytes */ 14:
                    message.bytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgMemCachedStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 curr_connections = 1; */
        if (message.currConnections !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.currConnections);
        /* optional uint64 cmd_get = 2; */
        if (message.cmdGet !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.cmdGet);
        /* optional uint64 cmd_set = 3; */
        if (message.cmdSet !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.cmdSet);
        /* optional uint64 cmd_flush = 4; */
        if (message.cmdFlush !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.cmdFlush);
        /* optional uint64 get_hits = 5; */
        if (message.getHits !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.getHits);
        /* optional uint64 get_misses = 6; */
        if (message.getMisses !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.getMisses);
        /* optional uint64 delete_hits = 7; */
        if (message.deleteHits !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.deleteHits);
        /* optional uint64 delete_misses = 8; */
        if (message.deleteMisses !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.deleteMisses);
        /* optional uint64 bytes_read = 9; */
        if (message.bytesRead !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.bytesRead);
        /* optional uint64 bytes_written = 10; */
        if (message.bytesWritten !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.bytesWritten);
        /* optional uint64 limit_maxbytes = 11; */
        if (message.limitMaxbytes !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.limitMaxbytes);
        /* optional uint64 curr_items = 12; */
        if (message.currItems !== undefined)
            writer.tag(12, WireType.Varint).uint64(message.currItems);
        /* optional uint64 evictions = 13; */
        if (message.evictions !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.evictions);
        /* optional uint64 bytes = 14; */
        if (message.bytes !== undefined)
            writer.tag(14, WireType.Varint).uint64(message.bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgMemCachedStatsResponse
 */
export const CGCMsgMemCachedStatsResponse = new CGCMsgMemCachedStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStats$Type extends MessageType<CGCMsgSQLStats> {
    constructor() {
        super("CGCMsgSQLStats", [
            { no: 1, name: "schema_catalog", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgSQLStats>): CGCMsgSQLStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgSQLStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgSQLStats): CGCMsgSQLStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 schema_catalog */ 1:
                    message.schemaCatalog = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgSQLStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 schema_catalog = 1; */
        if (message.schemaCatalog !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.schemaCatalog);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStats
 */
export const CGCMsgSQLStats = new CGCMsgSQLStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgSQLStatsResponse$Type extends MessageType<CGCMsgSQLStatsResponse> {
    constructor() {
        super("CGCMsgSQLStatsResponse", [
            { no: 1, name: "threads", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "threads_connected", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "threads_active", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "operations_submitted", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "prepared_statements_executed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "non_prepared_statements_executed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "deadlock_retries", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "operations_timed_out_in_queue", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "errors", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgSQLStatsResponse>): CGCMsgSQLStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgSQLStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgSQLStatsResponse): CGCMsgSQLStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 threads */ 1:
                    message.threads = reader.uint32();
                    break;
                case /* optional uint32 threads_connected */ 2:
                    message.threadsConnected = reader.uint32();
                    break;
                case /* optional uint32 threads_active */ 3:
                    message.threadsActive = reader.uint32();
                    break;
                case /* optional uint32 operations_submitted */ 4:
                    message.operationsSubmitted = reader.uint32();
                    break;
                case /* optional uint32 prepared_statements_executed */ 5:
                    message.preparedStatementsExecuted = reader.uint32();
                    break;
                case /* optional uint32 non_prepared_statements_executed */ 6:
                    message.nonPreparedStatementsExecuted = reader.uint32();
                    break;
                case /* optional uint32 deadlock_retries */ 7:
                    message.deadlockRetries = reader.uint32();
                    break;
                case /* optional uint32 operations_timed_out_in_queue */ 8:
                    message.operationsTimedOutInQueue = reader.uint32();
                    break;
                case /* optional uint32 errors */ 9:
                    message.errors = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgSQLStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 threads = 1; */
        if (message.threads !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.threads);
        /* optional uint32 threads_connected = 2; */
        if (message.threadsConnected !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.threadsConnected);
        /* optional uint32 threads_active = 3; */
        if (message.threadsActive !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.threadsActive);
        /* optional uint32 operations_submitted = 4; */
        if (message.operationsSubmitted !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.operationsSubmitted);
        /* optional uint32 prepared_statements_executed = 5; */
        if (message.preparedStatementsExecuted !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.preparedStatementsExecuted);
        /* optional uint32 non_prepared_statements_executed = 6; */
        if (message.nonPreparedStatementsExecuted !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.nonPreparedStatementsExecuted);
        /* optional uint32 deadlock_retries = 7; */
        if (message.deadlockRetries !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.deadlockRetries);
        /* optional uint32 operations_timed_out_in_queue = 8; */
        if (message.operationsTimedOutInQueue !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.operationsTimedOutInQueue);
        /* optional uint32 errors = 9; */
        if (message.errors !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.errors);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgSQLStatsResponse
 */
export const CGCMsgSQLStatsResponse = new CGCMsgSQLStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicense$Type extends MessageType<CMsgAMAddFreeLicense> {
    constructor() {
        super("CMsgAMAddFreeLicense", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ip_public", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "store_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMAddFreeLicense>): CMsgAMAddFreeLicense {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMAddFreeLicense>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMAddFreeLicense): CMsgAMAddFreeLicense {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 ip_public */ 2:
                    message.ipPublic = reader.uint32();
                    break;
                case /* optional uint32 packageid */ 3:
                    message.packageid = reader.uint32();
                    break;
                case /* optional string store_country_code */ 4:
                    message.storeCountryCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMAddFreeLicense, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 ip_public = 2; */
        if (message.ipPublic !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.ipPublic);
        /* optional uint32 packageid = 3; */
        if (message.packageid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.packageid);
        /* optional string store_country_code = 4; */
        if (message.storeCountryCode !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.storeCountryCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicense
 */
export const CMsgAMAddFreeLicense = new CMsgAMAddFreeLicense$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMAddFreeLicenseResponse$Type extends MessageType<CMsgAMAddFreeLicenseResponse> {
    constructor() {
        super("CMsgAMAddFreeLicenseResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "purchase_result_detail", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "transid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMAddFreeLicenseResponse>): CMsgAMAddFreeLicenseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMAddFreeLicenseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMAddFreeLicenseResponse): CMsgAMAddFreeLicenseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 purchase_result_detail */ 2:
                    message.purchaseResultDetail = reader.int32();
                    break;
                case /* optional fixed64 transid */ 3:
                    message.transid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMAddFreeLicenseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 purchase_result_detail = 2; */
        if (message.purchaseResultDetail !== undefined)
            writer.tag(2, WireType.Varint).int32(message.purchaseResultDetail);
        /* optional fixed64 transid = 3; */
        if (message.transid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.transid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMAddFreeLicenseResponse
 */
export const CMsgAMAddFreeLicenseResponse = new CMsgAMAddFreeLicenseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPLocation$Type extends MessageType<CGCMsgGetIPLocation> {
    constructor() {
        super("CGCMsgGetIPLocation", [
            { no: 1, name: "ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetIPLocation>): CGCMsgGetIPLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ips = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetIPLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetIPLocation): CGCMsgGetIPLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 ips */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ips.push(reader.fixed32());
                    else
                        message.ips.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetIPLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 ips = 1; */
        for (let i = 0; i < message.ips.length; i++)
            writer.tag(1, WireType.Bit32).fixed32(message.ips[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPLocation
 */
export const CGCMsgGetIPLocation = new CGCMsgGetIPLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPASN$Type extends MessageType<CGCMsgGetIPASN> {
    constructor() {
        super("CGCMsgGetIPASN", [
            { no: 1, name: "ips", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetIPASN>): CGCMsgGetIPASN {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ips = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetIPASN>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetIPASN): CGCMsgGetIPASN {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 ips */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ips.push(reader.fixed32());
                    else
                        message.ips.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetIPASN, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 ips = 1; */
        for (let i = 0; i < message.ips.length; i++)
            writer.tag(1, WireType.Bit32).fixed32(message.ips[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPASN
 */
export const CGCMsgGetIPASN = new CGCMsgGetIPASN$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CIPASNInfo$Type extends MessageType<CIPASNInfo> {
    constructor() {
        super("CIPASNInfo", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "asn", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CIPASNInfo>): CIPASNInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CIPASNInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CIPASNInfo): CIPASNInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 ip */ 1:
                    message.ip = reader.fixed32();
                    break;
                case /* optional uint32 asn */ 2:
                    message.asn = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CIPASNInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 ip = 1; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.ip);
        /* optional uint32 asn = 2; */
        if (message.asn !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.asn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CIPASNInfo
 */
export const CIPASNInfo = new CIPASNInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgGetIPASNResponse$Type extends MessageType<CGCMsgGetIPASNResponse> {
    constructor() {
        super("CGCMsgGetIPASNResponse", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CIPASNInfo }
        ]);
    }
    create(value?: PartialMessage<CGCMsgGetIPASNResponse>): CGCMsgGetIPASNResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.infos = [];
        if (value !== undefined)
            reflectionMergePartial<CGCMsgGetIPASNResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgGetIPASNResponse): CGCMsgGetIPASNResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CIPASNInfo infos */ 1:
                    message.infos.push(CIPASNInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgGetIPASNResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CIPASNInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            CIPASNInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgGetIPASNResponse
 */
export const CGCMsgGetIPASNResponse = new CGCMsgGetIPASNResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail$Type extends MessageType<CMsgAMSendEmail> {
    constructor() {
        super("CMsgAMSendEmail", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "email_msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "email_format", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "persona_name_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMSendEmail_PersonaNameReplacementToken },
            { no: 6, name: "source_gc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgAMSendEmail_ReplacementToken }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail>): CMsgAMSendEmail {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.personaNameTokens = [];
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail): CMsgAMSendEmail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 email_msg_type */ 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case /* optional uint32 email_format */ 3:
                    message.emailFormat = reader.uint32();
                    break;
                case /* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens */ 5:
                    message.personaNameTokens.push(CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 source_gc */ 6:
                    message.sourceGc = reader.uint32();
                    break;
                case /* repeated CMsgAMSendEmail.ReplacementToken tokens */ 7:
                    message.tokens.push(CMsgAMSendEmail_ReplacementToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 email_msg_type = 2; */
        if (message.emailMsgType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.emailMsgType);
        /* optional uint32 email_format = 3; */
        if (message.emailFormat !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.emailFormat);
        /* repeated CMsgAMSendEmail.PersonaNameReplacementToken persona_name_tokens = 5; */
        for (let i = 0; i < message.personaNameTokens.length; i++)
            CMsgAMSendEmail_PersonaNameReplacementToken.internalBinaryWrite(message.personaNameTokens[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 source_gc = 6; */
        if (message.sourceGc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.sourceGc);
        /* repeated CMsgAMSendEmail.ReplacementToken tokens = 7; */
        for (let i = 0; i < message.tokens.length; i++)
            CMsgAMSendEmail_ReplacementToken.internalBinaryWrite(message.tokens[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail
 */
export const CMsgAMSendEmail = new CMsgAMSendEmail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_ReplacementToken$Type extends MessageType<CMsgAMSendEmail_ReplacementToken> {
    constructor() {
        super("CMsgAMSendEmail.ReplacementToken", [
            { no: 1, name: "token_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail_ReplacementToken>): CMsgAMSendEmail_ReplacementToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail_ReplacementToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail_ReplacementToken): CMsgAMSendEmail_ReplacementToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token_name */ 1:
                    message.tokenName = reader.string();
                    break;
                case /* optional string token_value */ 2:
                    message.tokenValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail_ReplacementToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token_name = 1; */
        if (message.tokenName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tokenName);
        /* optional string token_value = 2; */
        if (message.tokenValue !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tokenValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.ReplacementToken
 */
export const CMsgAMSendEmail_ReplacementToken = new CMsgAMSendEmail_ReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmail_PersonaNameReplacementToken$Type extends MessageType<CMsgAMSendEmail_PersonaNameReplacementToken> {
    constructor() {
        super("CMsgAMSendEmail.PersonaNameReplacementToken", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmail_PersonaNameReplacementToken>): CMsgAMSendEmail_PersonaNameReplacementToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmail_PersonaNameReplacementToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmail_PersonaNameReplacementToken): CMsgAMSendEmail_PersonaNameReplacementToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string token_name */ 2:
                    message.tokenName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmail_PersonaNameReplacementToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string token_name = 2; */
        if (message.tokenName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.tokenName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmail.PersonaNameReplacementToken
 */
export const CMsgAMSendEmail_PersonaNameReplacementToken = new CMsgAMSendEmail_PersonaNameReplacementToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMSendEmailResponse$Type extends MessageType<CMsgAMSendEmailResponse> {
    constructor() {
        super("CMsgAMSendEmailResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMSendEmailResponse>): CMsgAMSendEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMSendEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMSendEmailResponse): CMsgAMSendEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMSendEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMSendEmailResponse
 */
export const CMsgAMSendEmailResponse = new CMsgAMSendEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplate$Type extends MessageType<CMsgGCGetEmailTemplate> {
    constructor() {
        super("CMsgGCGetEmailTemplate", [
            { no: 1, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "email_msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "email_lang", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "email_format", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetEmailTemplate>): CMsgGCGetEmailTemplate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetEmailTemplate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetEmailTemplate): CMsgGCGetEmailTemplate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_id */ 1:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 email_msg_type */ 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case /* optional int32 email_lang */ 3:
                    message.emailLang = reader.int32();
                    break;
                case /* optional int32 email_format */ 4:
                    message.emailFormat = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetEmailTemplate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_id = 1; */
        if (message.appId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appId);
        /* optional uint32 email_msg_type = 2; */
        if (message.emailMsgType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.emailMsgType);
        /* optional int32 email_lang = 3; */
        if (message.emailLang !== undefined)
            writer.tag(3, WireType.Varint).int32(message.emailLang);
        /* optional int32 email_format = 4; */
        if (message.emailFormat !== undefined)
            writer.tag(4, WireType.Varint).int32(message.emailFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplate
 */
export const CMsgGCGetEmailTemplate = new CMsgGCGetEmailTemplate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetEmailTemplateResponse$Type extends MessageType<CMsgGCGetEmailTemplateResponse> {
    constructor() {
        super("CMsgGCGetEmailTemplateResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "template_exists", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "template", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetEmailTemplateResponse>): CMsgGCGetEmailTemplateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetEmailTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetEmailTemplateResponse): CMsgGCGetEmailTemplateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 eresult */ 1:
                    message.eresult = reader.uint32();
                    break;
                case /* optional bool template_exists */ 2:
                    message.templateExists = reader.bool();
                    break;
                case /* optional string template */ 3:
                    message.template = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetEmailTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.eresult);
        /* optional bool template_exists = 2; */
        if (message.templateExists !== undefined)
            writer.tag(2, WireType.Varint).bool(message.templateExists);
        /* optional string template = 3; */
        if (message.template !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.template);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetEmailTemplateResponse
 */
export const CMsgGCGetEmailTemplateResponse = new CMsgGCGetEmailTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2$Type extends MessageType<CMsgAMGrantGuestPasses2> {
    constructor() {
        super("CMsgAMGrantGuestPasses2", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "package_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "passes_to_grant", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "days_to_expiration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "action", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGrantGuestPasses2>): CMsgAMGrantGuestPasses2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGrantGuestPasses2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGrantGuestPasses2): CMsgAMGrantGuestPasses2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 package_id */ 2:
                    message.packageId = reader.uint32();
                    break;
                case /* optional int32 passes_to_grant */ 3:
                    message.passesToGrant = reader.int32();
                    break;
                case /* optional int32 days_to_expiration */ 4:
                    message.daysToExpiration = reader.int32();
                    break;
                case /* optional int32 action */ 5:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGrantGuestPasses2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 package_id = 2; */
        if (message.packageId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.packageId);
        /* optional int32 passes_to_grant = 3; */
        if (message.passesToGrant !== undefined)
            writer.tag(3, WireType.Varint).int32(message.passesToGrant);
        /* optional int32 days_to_expiration = 4; */
        if (message.daysToExpiration !== undefined)
            writer.tag(4, WireType.Varint).int32(message.daysToExpiration);
        /* optional int32 action = 5; */
        if (message.action !== undefined)
            writer.tag(5, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2
 */
export const CMsgAMGrantGuestPasses2 = new CMsgAMGrantGuestPasses2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAMGrantGuestPasses2Response$Type extends MessageType<CMsgAMGrantGuestPasses2Response> {
    constructor() {
        super("CMsgAMGrantGuestPasses2Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "passes_granted", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAMGrantGuestPasses2Response>): CMsgAMGrantGuestPasses2Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAMGrantGuestPasses2Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAMGrantGuestPasses2Response): CMsgAMGrantGuestPasses2Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional int32 passes_granted */ 2:
                    message.passesGranted = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAMGrantGuestPasses2Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional int32 passes_granted = 2; */
        if (message.passesGranted !== undefined)
            writer.tag(2, WireType.Varint).int32(message.passesGranted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAMGrantGuestPasses2Response
 */
export const CMsgAMGrantGuestPasses2Response = new CMsgAMGrantGuestPasses2Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames$Type extends MessageType<CMsgGCGetPersonaNames> {
    constructor() {
        super("CMsgGCGetPersonaNames", [
            { no: 1, name: "steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames>): CMsgGCGetPersonaNames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames): CMsgGCGetPersonaNames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 steamids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamids.push(reader.fixed64().toBigInt());
                    else
                        message.steamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 steamids = 1; */
        for (let i = 0; i < message.steamids.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.steamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames
 */
export const CMsgGCGetPersonaNames = new CMsgGCGetPersonaNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response$Type extends MessageType<CMsgGCGetPersonaNames_Response> {
    constructor() {
        super("CMsgGCGetPersonaNames_Response", [
            { no: 1, name: "succeeded_lookups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCGetPersonaNames_Response_PersonaName },
            { no: 2, name: "failed_lookup_steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames_Response>): CMsgGCGetPersonaNames_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.succeededLookups = [];
        message.failedLookupSteamids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames_Response): CMsgGCGetPersonaNames_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups */ 1:
                    message.succeededLookups.push(CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated fixed64 failed_lookup_steamids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.failedLookupSteamids.push(reader.fixed64().toBigInt());
                    else
                        message.failedLookupSteamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCGetPersonaNames_Response.PersonaName succeeded_lookups = 1; */
        for (let i = 0; i < message.succeededLookups.length; i++)
            CMsgGCGetPersonaNames_Response_PersonaName.internalBinaryWrite(message.succeededLookups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed64 failed_lookup_steamids = 2; */
        for (let i = 0; i < message.failedLookupSteamids.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.failedLookupSteamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response
 */
export const CMsgGCGetPersonaNames_Response = new CMsgGCGetPersonaNames_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetPersonaNames_Response_PersonaName$Type extends MessageType<CMsgGCGetPersonaNames_Response_PersonaName> {
    constructor() {
        super("CMsgGCGetPersonaNames_Response.PersonaName", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "persona_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetPersonaNames_Response_PersonaName>): CMsgGCGetPersonaNames_Response_PersonaName {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetPersonaNames_Response_PersonaName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetPersonaNames_Response_PersonaName): CMsgGCGetPersonaNames_Response_PersonaName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string persona_name */ 2:
                    message.personaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetPersonaNames_Response_PersonaName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional string persona_name = 2; */
        if (message.personaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.personaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetPersonaNames_Response.PersonaName
 */
export const CMsgGCGetPersonaNames_Response_PersonaName = new CMsgGCGetPersonaNames_Response_PersonaName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship$Type extends MessageType<CMsgGCCheckFriendship> {
    constructor() {
        super("CMsgGCCheckFriendship", [
            { no: 1, name: "steamid_left", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "steamid_right", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckFriendship>): CMsgGCCheckFriendship {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckFriendship>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckFriendship): CMsgGCCheckFriendship {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid_left */ 1:
                    message.steamidLeft = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 steamid_right */ 2:
                    message.steamidRight = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckFriendship, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid_left = 1; */
        if (message.steamidLeft !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamidLeft);
        /* optional fixed64 steamid_right = 2; */
        if (message.steamidRight !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamidRight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship
 */
export const CMsgGCCheckFriendship = new CMsgGCCheckFriendship$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckFriendship_Response$Type extends MessageType<CMsgGCCheckFriendship_Response> {
    constructor() {
        super("CMsgGCCheckFriendship_Response", [
            { no: 1, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "found_friendship", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckFriendship_Response>): CMsgGCCheckFriendship_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckFriendship_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckFriendship_Response): CMsgGCCheckFriendship_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* optional bool found_friendship */ 2:
                    message.foundFriendship = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckFriendship_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool success = 1; */
        if (message.success !== undefined)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* optional bool found_friendship = 2; */
        if (message.foundFriendship !== undefined)
            writer.tag(2, WireType.Varint).bool(message.foundFriendship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckFriendship_Response
 */
export const CMsgGCCheckFriendship_Response = new CMsgGCCheckFriendship_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetAppFriendsList$Type extends MessageType<CMsgGCGetAppFriendsList> {
    constructor() {
        super("CMsgGCGetAppFriendsList", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "include_friendship_timestamps", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "include_friends_with_no_play_time", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetAppFriendsList>): CMsgGCGetAppFriendsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetAppFriendsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetAppFriendsList): CMsgGCGetAppFriendsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional bool include_friendship_timestamps */ 2:
                    message.includeFriendshipTimestamps = reader.bool();
                    break;
                case /* optional bool include_friends_with_no_play_time */ 3:
                    message.includeFriendsWithNoPlayTime = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetAppFriendsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional bool include_friendship_timestamps = 2; */
        if (message.includeFriendshipTimestamps !== undefined)
            writer.tag(2, WireType.Varint).bool(message.includeFriendshipTimestamps);
        /* optional bool include_friends_with_no_play_time = 3; */
        if (message.includeFriendsWithNoPlayTime !== undefined)
            writer.tag(3, WireType.Varint).bool(message.includeFriendsWithNoPlayTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetAppFriendsList
 */
export const CMsgGCGetAppFriendsList = new CMsgGCGetAppFriendsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCGetAppFriendsList_Response$Type extends MessageType<CMsgGCGetAppFriendsList_Response> {
    constructor() {
        super("CMsgGCGetAppFriendsList_Response", [
            { no: 1, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "friendship_timestamps", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "last_playtimes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCGetAppFriendsList_Response>): CMsgGCGetAppFriendsList_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamids = [];
        message.friendshipTimestamps = [];
        message.lastPlaytimes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCGetAppFriendsList_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCGetAppFriendsList_Response): CMsgGCGetAppFriendsList_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* repeated fixed64 steamids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamids.push(reader.fixed64().toBigInt());
                    else
                        message.steamids.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated fixed32 friendship_timestamps */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.friendshipTimestamps.push(reader.fixed32());
                    else
                        message.friendshipTimestamps.push(reader.fixed32());
                    break;
                case /* repeated fixed32 last_playtimes */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lastPlaytimes.push(reader.fixed32());
                    else
                        message.lastPlaytimes.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCGetAppFriendsList_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool success = 1; */
        if (message.success !== undefined)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* repeated fixed64 steamids = 2; */
        for (let i = 0; i < message.steamids.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.steamids[i]);
        /* repeated fixed32 friendship_timestamps = 3; */
        for (let i = 0; i < message.friendshipTimestamps.length; i++)
            writer.tag(3, WireType.Bit32).fixed32(message.friendshipTimestamps[i]);
        /* repeated fixed32 last_playtimes = 4; */
        for (let i = 0; i < message.lastPlaytimes.length; i++)
            writer.tag(4, WireType.Bit32).fixed32(message.lastPlaytimes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCGetAppFriendsList_Response
 */
export const CMsgGCGetAppFriendsList_Response = new CMsgGCGetAppFriendsList_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory$Type extends MessageType<CMsgGCMsgMasterSetDirectory> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory", [
            { no: 1, name: "master_dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dir", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetDirectory_SubGC }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory>): CMsgGCMsgMasterSetDirectory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dir = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory): CMsgGCMsgMasterSetDirectory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 master_dir_index */ 1:
                    message.masterDirIndex = reader.int32();
                    break;
                case /* repeated CMsgGCMsgMasterSetDirectory.SubGC dir */ 2:
                    message.dir.push(CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 master_dir_index = 1; */
        if (message.masterDirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.masterDirIndex);
        /* repeated CMsgGCMsgMasterSetDirectory.SubGC dir = 2; */
        for (let i = 0; i < message.dir.length; i++)
            CMsgGCMsgMasterSetDirectory_SubGC.internalBinaryWrite(message.dir[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory
 */
export const CMsgGCMsgMasterSetDirectory = new CMsgGCMsgMasterSetDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_SubGC$Type extends MessageType<CMsgGCMsgMasterSetDirectory_SubGC> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory.SubGC", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "box", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "command_line", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gc_binary", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_SubGC>): CMsgGCMsgMasterSetDirectory_SubGC {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory_SubGC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory_SubGC): CMsgGCMsgMasterSetDirectory_SubGC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string box */ 3:
                    message.box = reader.string();
                    break;
                case /* optional string command_line */ 4:
                    message.commandLine = reader.string();
                    break;
                case /* optional string gc_binary */ 5:
                    message.gcBinary = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory_SubGC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string box = 3; */
        if (message.box !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.box);
        /* optional string command_line = 4; */
        if (message.commandLine !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.commandLine);
        /* optional string gc_binary = 5; */
        if (message.gcBinary !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.gcBinary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory.SubGC
 */
export const CMsgGCMsgMasterSetDirectory_SubGC = new CMsgGCMsgMasterSetDirectory_SubGC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetDirectory_Response$Type extends MessageType<CMsgGCMsgMasterSetDirectory_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetDirectory_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetDirectory_Response>): CMsgGCMsgMasterSetDirectory_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetDirectory_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetDirectory_Response): CMsgGCMsgMasterSetDirectory_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                case /* optional string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetDirectory_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        /* optional string message = 2; */
        if (message.message !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetDirectory_Response
 */
export const CMsgGCMsgMasterSetDirectory_Response = new CMsgGCMsgMasterSetDirectory_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgWebAPIJobRequestForwardResponse$Type extends MessageType<CMsgGCMsgWebAPIJobRequestForwardResponse> {
    constructor() {
        super("CMsgGCMsgWebAPIJobRequestForwardResponse", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgWebAPIJobRequestForwardResponse>): CMsgGCMsgWebAPIJobRequestForwardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgWebAPIJobRequestForwardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgWebAPIJobRequestForwardResponse): CMsgGCMsgWebAPIJobRequestForwardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgWebAPIJobRequestForwardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgWebAPIJobRequestForwardResponse
 */
export const CMsgGCMsgWebAPIJobRequestForwardResponse = new CMsgGCMsgWebAPIJobRequestForwardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Request$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Request> {
    constructor() {
        super("CGCSystemMsg_GetPurchaseTrust_Request", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Request>): CGCSystemMsg_GetPurchaseTrust_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetPurchaseTrust_Request): CGCSystemMsg_GetPurchaseTrust_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetPurchaseTrust_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Request
 */
export const CGCSystemMsg_GetPurchaseTrust_Request = new CGCSystemMsg_GetPurchaseTrust_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCSystemMsg_GetPurchaseTrust_Response$Type extends MessageType<CGCSystemMsg_GetPurchaseTrust_Response> {
    constructor() {
        super("CGCSystemMsg_GetPurchaseTrust_Response", [
            { no: 1, name: "has_prior_purchase_history", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "has_no_recent_password_resets", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_wallet_cash_trusted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "time_all_trusted", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCSystemMsg_GetPurchaseTrust_Response>): CGCSystemMsg_GetPurchaseTrust_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCSystemMsg_GetPurchaseTrust_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCSystemMsg_GetPurchaseTrust_Response): CGCSystemMsg_GetPurchaseTrust_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool has_prior_purchase_history */ 1:
                    message.hasPriorPurchaseHistory = reader.bool();
                    break;
                case /* optional bool has_no_recent_password_resets */ 2:
                    message.hasNoRecentPasswordResets = reader.bool();
                    break;
                case /* optional bool is_wallet_cash_trusted */ 3:
                    message.isWalletCashTrusted = reader.bool();
                    break;
                case /* optional uint32 time_all_trusted */ 4:
                    message.timeAllTrusted = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCSystemMsg_GetPurchaseTrust_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool has_prior_purchase_history = 1; */
        if (message.hasPriorPurchaseHistory !== undefined)
            writer.tag(1, WireType.Varint).bool(message.hasPriorPurchaseHistory);
        /* optional bool has_no_recent_password_resets = 2; */
        if (message.hasNoRecentPasswordResets !== undefined)
            writer.tag(2, WireType.Varint).bool(message.hasNoRecentPasswordResets);
        /* optional bool is_wallet_cash_trusted = 3; */
        if (message.isWalletCashTrusted !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isWalletCashTrusted);
        /* optional uint32 time_all_trusted = 4; */
        if (message.timeAllTrusted !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.timeAllTrusted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCSystemMsg_GetPurchaseTrust_Response
 */
export const CGCSystemMsg_GetPurchaseTrust_Response = new CGCSystemMsg_GetPurchaseTrust_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAccountVacStatusChange$Type extends MessageType<CMsgGCHAccountVacStatusChange> {
    constructor() {
        super("CMsgGCHAccountVacStatusChange", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "rtime_vacban_starts", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "is_banned_now", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_banned_future", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAccountVacStatusChange>): CMsgGCHAccountVacStatusChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAccountVacStatusChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAccountVacStatusChange): CMsgGCHAccountVacStatusChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional uint32 rtime_vacban_starts */ 3:
                    message.rtimeVacbanStarts = reader.uint32();
                    break;
                case /* optional bool is_banned_now */ 4:
                    message.isBannedNow = reader.bool();
                    break;
                case /* optional bool is_banned_future */ 5:
                    message.isBannedFuture = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAccountVacStatusChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional uint32 rtime_vacban_starts = 3; */
        if (message.rtimeVacbanStarts !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.rtimeVacbanStarts);
        /* optional bool is_banned_now = 4; */
        if (message.isBannedNow !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isBannedNow);
        /* optional bool is_banned_future = 5; */
        if (message.isBannedFuture !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isBannedFuture);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAccountVacStatusChange
 */
export const CMsgGCHAccountVacStatusChange = new CMsgGCHAccountVacStatusChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRoutingInfo$Type extends MessageType<CMsgGCRoutingInfo> {
    constructor() {
        super("CMsgGCRoutingInfo", [
            { no: 1, name: "dir_index", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "method", kind: "enum", opt: true, T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod] },
            { no: 3, name: "fallback", kind: "enum", opt: true, T: () => ["CMsgGCRoutingInfo.RoutingMethod", CMsgGCRoutingInfo_RoutingMethod] },
            { no: 4, name: "protobuf_field", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "webapi_param", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCRoutingInfo>): CMsgGCRoutingInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dirIndex = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCRoutingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCRoutingInfo): CMsgGCRoutingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 dir_index */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dirIndex.push(reader.int32());
                    else
                        message.dirIndex.push(reader.int32());
                    break;
                case /* optional CMsgGCRoutingInfo.RoutingMethod method */ 2:
                    message.method = reader.int32();
                    break;
                case /* optional CMsgGCRoutingInfo.RoutingMethod fallback */ 3:
                    message.fallback = reader.int32();
                    break;
                case /* optional uint32 protobuf_field */ 4:
                    message.protobufField = reader.uint32();
                    break;
                case /* optional string webapi_param */ 5:
                    message.webapiParam = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCRoutingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 dir_index = 1; */
        for (let i = 0; i < message.dirIndex.length; i++)
            writer.tag(1, WireType.Varint).int32(message.dirIndex[i]);
        /* optional CMsgGCRoutingInfo.RoutingMethod method = 2; */
        if (message.method !== undefined)
            writer.tag(2, WireType.Varint).int32(message.method);
        /* optional CMsgGCRoutingInfo.RoutingMethod fallback = 3; */
        if (message.fallback !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fallback);
        /* optional uint32 protobuf_field = 4; */
        if (message.protobufField !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.protobufField);
        /* optional string webapi_param = 5; */
        if (message.webapiParam !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.webapiParam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCRoutingInfo
 */
export const CMsgGCRoutingInfo = new CMsgGCRoutingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetWebAPIRouting_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting>): CMsgGCMsgMasterSetWebAPIRouting {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting): CMsgGCMsgMasterSetWebAPIRouting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries */ 1:
                    message.entries.push(CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgMasterSetWebAPIRouting.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgGCMsgMasterSetWebAPIRouting_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting
 */
export const CMsgGCMsgMasterSetWebAPIRouting = new CMsgGCMsgMasterSetWebAPIRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Entry> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting.Entry", [
            { no: 1, name: "interface_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Entry>): CMsgGCMsgMasterSetWebAPIRouting_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting_Entry): CMsgGCMsgMasterSetWebAPIRouting_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string interface_name */ 1:
                    message.interfaceName = reader.string();
                    break;
                case /* optional string method_name */ 2:
                    message.methodName = reader.string();
                    break;
                case /* optional CMsgGCRoutingInfo routing */ 3:
                    message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string interface_name = 1; */
        if (message.interfaceName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.interfaceName);
        /* optional string method_name = 2; */
        if (message.methodName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.methodName);
        /* optional CMsgGCRoutingInfo routing = 3; */
        if (message.routing)
            CMsgGCRoutingInfo.internalBinaryWrite(message.routing, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting.Entry
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Entry = new CMsgGCMsgMasterSetWebAPIRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgMasterSetClientMsgRouting_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting>): CMsgGCMsgMasterSetClientMsgRouting {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting): CMsgGCMsgMasterSetClientMsgRouting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries */ 1:
                    message.entries.push(CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgMasterSetClientMsgRouting.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CMsgGCMsgMasterSetClientMsgRouting_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting
 */
export const CMsgGCMsgMasterSetClientMsgRouting = new CMsgGCMsgMasterSetClientMsgRouting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Entry$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Entry> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting.Entry", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "routing", kind: "message", T: () => CMsgGCRoutingInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Entry>): CMsgGCMsgMasterSetClientMsgRouting_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting_Entry): CMsgGCMsgMasterSetClientMsgRouting_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_type */ 1:
                    message.msgType = reader.uint32();
                    break;
                case /* optional CMsgGCRoutingInfo routing */ 2:
                    message.routing = CMsgGCRoutingInfo.internalBinaryRead(reader, reader.uint32(), options, message.routing);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgType);
        /* optional CMsgGCRoutingInfo routing = 2; */
        if (message.routing)
            CMsgGCRoutingInfo.internalBinaryWrite(message.routing, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting.Entry
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Entry = new CMsgGCMsgMasterSetClientMsgRouting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetWebAPIRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetWebAPIRouting_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetWebAPIRouting_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetWebAPIRouting_Response>): CMsgGCMsgMasterSetWebAPIRouting_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetWebAPIRouting_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetWebAPIRouting_Response): CMsgGCMsgMasterSetWebAPIRouting_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetWebAPIRouting_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetWebAPIRouting_Response
 */
export const CMsgGCMsgMasterSetWebAPIRouting_Response = new CMsgGCMsgMasterSetWebAPIRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgMasterSetClientMsgRouting_Response$Type extends MessageType<CMsgGCMsgMasterSetClientMsgRouting_Response> {
    constructor() {
        super("CMsgGCMsgMasterSetClientMsgRouting_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgMasterSetClientMsgRouting_Response>): CMsgGCMsgMasterSetClientMsgRouting_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgMasterSetClientMsgRouting_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgMasterSetClientMsgRouting_Response): CMsgGCMsgMasterSetClientMsgRouting_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgMasterSetClientMsgRouting_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgMasterSetClientMsgRouting_Response
 */
export const CMsgGCMsgMasterSetClientMsgRouting_Response = new CMsgGCMsgMasterSetClientMsgRouting_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions$Type extends MessageType<CMsgGCMsgSetOptions> {
    constructor() {
        super("CMsgGCMsgSetOptions", [
            { no: 1, name: "options", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["CMsgGCMsgSetOptions.Option", CMsgGCMsgSetOptions_Option] },
            { no: 2, name: "client_msg_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCMsgSetOptions_MessageRange },
            { no: 3, name: "gcsql_version", kind: "enum", opt: true, T: () => ["CMsgGCMsgSetOptions.GCSQLVersion", CMsgGCMsgSetOptions_GCSQLVersion] }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgSetOptions>): CMsgGCMsgSetOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.options = [];
        message.clientMsgRanges = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgSetOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgSetOptions): CMsgGCMsgSetOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCMsgSetOptions.Option options */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.options.push(reader.int32());
                    else
                        message.options.push(reader.int32());
                    break;
                case /* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges */ 2:
                    message.clientMsgRanges.push(CMsgGCMsgSetOptions_MessageRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version */ 3:
                    message.gcsqlVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgSetOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCMsgSetOptions.Option options = 1; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(1, WireType.Varint).int32(message.options[i]);
        /* repeated CMsgGCMsgSetOptions.MessageRange client_msg_ranges = 2; */
        for (let i = 0; i < message.clientMsgRanges.length; i++)
            CMsgGCMsgSetOptions_MessageRange.internalBinaryWrite(message.clientMsgRanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgGCMsgSetOptions.GCSQLVersion gcsql_version = 3; */
        if (message.gcsqlVersion !== undefined)
            writer.tag(3, WireType.Varint).int32(message.gcsqlVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions
 */
export const CMsgGCMsgSetOptions = new CMsgGCMsgSetOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMsgSetOptions_MessageRange$Type extends MessageType<CMsgGCMsgSetOptions_MessageRange> {
    constructor() {
        super("CMsgGCMsgSetOptions.MessageRange", [
            { no: 1, name: "low", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "high", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMsgSetOptions_MessageRange>): CMsgGCMsgSetOptions_MessageRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.low = 0;
        message.high = 0;
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMsgSetOptions_MessageRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMsgSetOptions_MessageRange): CMsgGCMsgSetOptions_MessageRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 low */ 1:
                    message.low = reader.uint32();
                    break;
                case /* uint32 high */ 2:
                    message.high = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMsgSetOptions_MessageRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 low = 1; */
        if (message.low !== 0)
            writer.tag(1, WireType.Varint).uint32(message.low);
        /* uint32 high = 2; */
        if (message.high !== 0)
            writer.tag(2, WireType.Varint).uint32(message.high);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMsgSetOptions.MessageRange
 */
export const CMsgGCMsgSetOptions_MessageRange = new CMsgGCMsgSetOptions_MessageRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession$Type extends MessageType<CMsgGCHUpdateSession> {
    constructor() {
        super("CMsgGCHUpdateSession", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "app_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "online", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "server_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "server_addr", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "server_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "os_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "client_addr", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "extra_fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCHUpdateSession_ExtraField }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHUpdateSession>): CMsgGCHUpdateSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extraFields = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHUpdateSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHUpdateSession): CMsgGCHUpdateSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 1:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 app_id */ 2:
                    message.appId = reader.uint32();
                    break;
                case /* optional bool online */ 3:
                    message.online = reader.bool();
                    break;
                case /* optional fixed64 server_steam_id */ 4:
                    message.serverSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 server_addr */ 5:
                    message.serverAddr = reader.uint32();
                    break;
                case /* optional uint32 server_port */ 6:
                    message.serverPort = reader.uint32();
                    break;
                case /* optional uint32 os_type */ 7:
                    message.osType = reader.uint32();
                    break;
                case /* optional uint32 client_addr */ 8:
                    message.clientAddr = reader.uint32();
                    break;
                case /* repeated CMsgGCHUpdateSession.ExtraField extra_fields */ 9:
                    message.extraFields.push(CMsgGCHUpdateSession_ExtraField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHUpdateSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamId);
        /* optional uint32 app_id = 2; */
        if (message.appId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appId);
        /* optional bool online = 3; */
        if (message.online !== undefined)
            writer.tag(3, WireType.Varint).bool(message.online);
        /* optional fixed64 server_steam_id = 4; */
        if (message.serverSteamId !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.serverSteamId);
        /* optional uint32 server_addr = 5; */
        if (message.serverAddr !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.serverAddr);
        /* optional uint32 server_port = 6; */
        if (message.serverPort !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.serverPort);
        /* optional uint32 os_type = 7; */
        if (message.osType !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.osType);
        /* optional uint32 client_addr = 8; */
        if (message.clientAddr !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.clientAddr);
        /* repeated CMsgGCHUpdateSession.ExtraField extra_fields = 9; */
        for (let i = 0; i < message.extraFields.length; i++)
            CMsgGCHUpdateSession_ExtraField.internalBinaryWrite(message.extraFields[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession
 */
export const CMsgGCHUpdateSession = new CMsgGCHUpdateSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHUpdateSession_ExtraField$Type extends MessageType<CMsgGCHUpdateSession_ExtraField> {
    constructor() {
        super("CMsgGCHUpdateSession.ExtraField", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHUpdateSession_ExtraField>): CMsgGCHUpdateSession_ExtraField {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHUpdateSession_ExtraField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHUpdateSession_ExtraField): CMsgGCHUpdateSession_ExtraField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHUpdateSession_ExtraField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHUpdateSession.ExtraField
 */
export const CMsgGCHUpdateSession_ExtraField = new CMsgGCHUpdateSession_ExtraField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity$Type extends MessageType<CMsgNotificationOfSuspiciousActivity> {
    constructor() {
        super("CMsgNotificationOfSuspiciousActivity", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "multiple_instances", kind: "message", T: () => CMsgNotificationOfSuspiciousActivity_MultipleGameInstances }
        ]);
    }
    create(value?: PartialMessage<CMsgNotificationOfSuspiciousActivity>): CMsgNotificationOfSuspiciousActivity {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgNotificationOfSuspiciousActivity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotificationOfSuspiciousActivity): CMsgNotificationOfSuspiciousActivity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances */ 3:
                    message.multipleInstances = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryRead(reader, reader.uint32(), options, message.multipleInstances);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotificationOfSuspiciousActivity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional CMsgNotificationOfSuspiciousActivity.MultipleGameInstances multiple_instances = 3; */
        if (message.multipleInstances)
            CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.internalBinaryWrite(message.multipleInstances, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity
 */
export const CMsgNotificationOfSuspiciousActivity = new CMsgNotificationOfSuspiciousActivity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type extends MessageType<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances> {
    constructor() {
        super("CMsgNotificationOfSuspiciousActivity.MultipleGameInstances", [
            { no: 1, name: "app_instance_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "other_steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.otherSteamids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 app_instance_count */ 1:
                    message.appInstanceCount = reader.uint32();
                    break;
                case /* repeated fixed64 other_steamids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.otherSteamids.push(reader.fixed64().toBigInt());
                    else
                        message.otherSteamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 app_instance_count = 1; */
        if (message.appInstanceCount !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appInstanceCount);
        /* repeated fixed64 other_steamids = 2; */
        for (let i = 0; i < message.otherSteamids.length; i++)
            writer.tag(2, WireType.Bit64).fixed64(message.otherSteamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
 */
export const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances = new CMsgNotificationOfSuspiciousActivity_MultipleGameInstances$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHVacVerificationChange$Type extends MessageType<CMsgGCHVacVerificationChange> {
    constructor() {
        super("CMsgGCHVacVerificationChange", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_verified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHVacVerificationChange>): CMsgGCHVacVerificationChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHVacVerificationChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHVacVerificationChange): CMsgGCHVacVerificationChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 appid */ 2:
                    message.appid = reader.uint32();
                    break;
                case /* optional bool is_verified */ 3:
                    message.isVerified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHVacVerificationChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 appid = 2; */
        if (message.appid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.appid);
        /* optional bool is_verified = 3; */
        if (message.isVerified !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isVerified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHVacVerificationChange
 */
export const CMsgGCHVacVerificationChange = new CMsgGCHVacVerificationChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckClanMembership$Type extends MessageType<CMsgGCCheckClanMembership> {
    constructor() {
        super("CMsgGCCheckClanMembership", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clanid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckClanMembership>): CMsgGCCheckClanMembership {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckClanMembership>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckClanMembership): CMsgGCCheckClanMembership {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 clanid */ 2:
                    message.clanid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckClanMembership, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional uint32 clanid = 2; */
        if (message.clanid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.clanid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckClanMembership
 */
export const CMsgGCCheckClanMembership = new CMsgGCCheckClanMembership$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCCheckClanMembership_Response$Type extends MessageType<CMsgGCCheckClanMembership_Response> {
    constructor() {
        super("CMsgGCCheckClanMembership_Response", [
            { no: 1, name: "ismember", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCCheckClanMembership_Response>): CMsgGCCheckClanMembership_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCCheckClanMembership_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCCheckClanMembership_Response): CMsgGCCheckClanMembership_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool ismember */ 1:
                    message.ismember = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCCheckClanMembership_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool ismember = 1; */
        if (message.ismember !== undefined)
            writer.tag(1, WireType.Varint).bool(message.ismember);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCCheckClanMembership_Response
 */
export const CMsgGCCheckClanMembership_Response = new CMsgGCCheckClanMembership_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived$Type extends MessageType<CMsgGCHAppCheersReceived> {
    constructor() {
        super("CMsgGCHAppCheersReceived", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cheer_targets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCHAppCheersReceived_CheerTarget }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersReceived>): CMsgGCHAppCheersReceived {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cheerTargets = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersReceived>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersReceived): CMsgGCHAppCheersReceived {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets */ 2:
                    message.cheerTargets.push(CMsgGCHAppCheersReceived_CheerTarget.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersReceived, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* repeated CMsgGCHAppCheersReceived.CheerTarget cheer_targets = 2; */
        for (let i = 0; i < message.cheerTargets.length; i++)
            CMsgGCHAppCheersReceived_CheerTarget.internalBinaryWrite(message.cheerTargets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived
 */
export const CMsgGCHAppCheersReceived = new CMsgGCHAppCheersReceived$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived_CheerTypeAmount$Type extends MessageType<CMsgGCHAppCheersReceived_CheerTypeAmount> {
    constructor() {
        super("CMsgGCHAppCheersReceived.CheerTypeAmount", [
            { no: 1, name: "cheer_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cheer_amount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersReceived_CheerTypeAmount>): CMsgGCHAppCheersReceived_CheerTypeAmount {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersReceived_CheerTypeAmount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersReceived_CheerTypeAmount): CMsgGCHAppCheersReceived_CheerTypeAmount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 cheer_type */ 1:
                    message.cheerType = reader.uint32();
                    break;
                case /* optional uint32 cheer_amount */ 2:
                    message.cheerAmount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersReceived_CheerTypeAmount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 cheer_type = 1; */
        if (message.cheerType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cheerType);
        /* optional uint32 cheer_amount = 2; */
        if (message.cheerAmount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.cheerAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived.CheerTypeAmount
 */
export const CMsgGCHAppCheersReceived_CheerTypeAmount = new CMsgGCHAppCheersReceived_CheerTypeAmount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersReceived_CheerTarget$Type extends MessageType<CMsgGCHAppCheersReceived_CheerTarget> {
    constructor() {
        super("CMsgGCHAppCheersReceived.CheerTarget", [
            { no: 1, name: "cheer_target", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cheer_types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCHAppCheersReceived_CheerTypeAmount }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersReceived_CheerTarget>): CMsgGCHAppCheersReceived_CheerTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cheerTypes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersReceived_CheerTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersReceived_CheerTarget): CMsgGCHAppCheersReceived_CheerTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 cheer_target */ 1:
                    message.cheerTarget = reader.uint64().toBigInt();
                    break;
                case /* repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types */ 2:
                    message.cheerTypes.push(CMsgGCHAppCheersReceived_CheerTypeAmount.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersReceived_CheerTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 cheer_target = 1; */
        if (message.cheerTarget !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.cheerTarget);
        /* repeated CMsgGCHAppCheersReceived.CheerTypeAmount cheer_types = 2; */
        for (let i = 0; i < message.cheerTypes.length; i++)
            CMsgGCHAppCheersReceived_CheerTypeAmount.internalBinaryWrite(message.cheerTypes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersReceived.CheerTarget
 */
export const CMsgGCHAppCheersReceived_CheerTarget = new CMsgGCHAppCheersReceived_CheerTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypes$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypes> {
    constructor() {
        super("CMsgGCHAppCheersGetAllowedTypes", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cheer_target", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypes>): CMsgGCHAppCheersGetAllowedTypes {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersGetAllowedTypes): CMsgGCHAppCheersGetAllowedTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint64 cheer_target */ 2:
                    message.cheerTarget = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersGetAllowedTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint64 cheer_target = 2; */
        if (message.cheerTarget !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.cheerTarget);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypes
 */
export const CMsgGCHAppCheersGetAllowedTypes = new CMsgGCHAppCheersGetAllowedTypes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypesResponse$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypesResponse> {
    constructor() {
        super("CMsgGCHAppCheersGetAllowedTypesResponse", [
            { no: 1, name: "cheer_types_valid_all_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cheer_remaps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps },
            { no: 3, name: "cache_duration", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypesResponse>): CMsgGCHAppCheersGetAllowedTypesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cheerTypesValidAllUsers = [];
        message.cheerRemaps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersGetAllowedTypesResponse): CMsgGCHAppCheersGetAllowedTypesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 cheer_types_valid_all_users */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cheerTypesValidAllUsers.push(reader.uint32());
                    else
                        message.cheerTypesValidAllUsers.push(reader.uint32());
                    break;
                case /* repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps */ 2:
                    message.cheerRemaps.push(CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 cache_duration */ 3:
                    message.cacheDuration = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersGetAllowedTypesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 cheer_types_valid_all_users = 1; */
        for (let i = 0; i < message.cheerTypesValidAllUsers.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.cheerTypesValidAllUsers[i]);
        /* repeated CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps cheer_remaps = 2; */
        for (let i = 0; i < message.cheerRemaps.length; i++)
            CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.internalBinaryWrite(message.cheerRemaps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 cache_duration = 3; */
        if (message.cacheDuration !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cacheDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypesResponse
 */
export const CMsgGCHAppCheersGetAllowedTypesResponse = new CMsgGCHAppCheersGetAllowedTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps$Type extends MessageType<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps> {
    constructor() {
        super("CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps", [
            { no: 1, name: "original_cheer_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "remapped_cheer_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "account_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 original_cheer_type */ 1:
                    message.originalCheerType = reader.uint32();
                    break;
                case /* optional uint32 remapped_cheer_type */ 2:
                    message.remappedCheerType = reader.uint32();
                    break;
                case /* repeated uint32 account_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.accountIds.push(reader.uint32());
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 original_cheer_type = 1; */
        if (message.originalCheerType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.originalCheerType);
        /* optional uint32 remapped_cheer_type = 2; */
        if (message.remappedCheerType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.remappedCheerType);
        /* repeated uint32 account_ids = 3; */
        for (let i = 0; i < message.accountIds.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.accountIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCHAppCheersGetAllowedTypesResponse.CheerRemaps
 */
export const CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps = new CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_AddSpecialPayment_Request$Type extends MessageType<CWorkshop_AddSpecialPayment_Request> {
    constructor() {
        super("CWorkshop_AddSpecialPayment_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payment_us_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "payment_row_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_AddSpecialPayment_Request>): CWorkshop_AddSpecialPayment_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_AddSpecialPayment_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_AddSpecialPayment_Request): CWorkshop_AddSpecialPayment_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 gameitemid */ 2:
                    message.gameitemid = reader.uint32();
                    break;
                case /* optional string date */ 3:
                    message.date = reader.string();
                    break;
                case /* optional uint64 payment_us_usd */ 4:
                    message.paymentUsUsd = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 payment_row_usd */ 5:
                    message.paymentRowUsd = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_AddSpecialPayment_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 gameitemid = 2; */
        if (message.gameitemid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameitemid);
        /* optional string date = 3; */
        if (message.date !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        /* optional uint64 payment_us_usd = 4; */
        if (message.paymentUsUsd !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.paymentUsUsd);
        /* optional uint64 payment_row_usd = 5; */
        if (message.paymentRowUsd !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.paymentRowUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_AddSpecialPayment_Request
 */
export const CWorkshop_AddSpecialPayment_Request = new CWorkshop_AddSpecialPayment_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_AddSpecialPayment_Response$Type extends MessageType<CWorkshop_AddSpecialPayment_Response> {
    constructor() {
        super("CWorkshop_AddSpecialPayment_Response", []);
    }
    create(value?: PartialMessage<CWorkshop_AddSpecialPayment_Response>): CWorkshop_AddSpecialPayment_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_AddSpecialPayment_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_AddSpecialPayment_Response): CWorkshop_AddSpecialPayment_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CWorkshop_AddSpecialPayment_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_AddSpecialPayment_Response
 */
export const CWorkshop_AddSpecialPayment_Response = new CWorkshop_AddSpecialPayment_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Request$Type extends MessageType<CWorkshop_GetSpecialPayments_Request> {
    constructor() {
        super("CWorkshop_GetSpecialPayments_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_GetSpecialPayments_Request>): CWorkshop_GetSpecialPayments_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_GetSpecialPayments_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_GetSpecialPayments_Request): CWorkshop_GetSpecialPayments_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 gameitemid */ 2:
                    message.gameitemid = reader.uint32();
                    break;
                case /* optional string date */ 3:
                    message.date = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_GetSpecialPayments_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 gameitemid = 2; */
        if (message.gameitemid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameitemid);
        /* optional string date = 3; */
        if (message.date !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Request
 */
export const CWorkshop_GetSpecialPayments_Request = new CWorkshop_GetSpecialPayments_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Response$Type extends MessageType<CWorkshop_GetSpecialPayments_Response> {
    constructor() {
        super("CWorkshop_GetSpecialPayments_Response", [
            { no: 1, name: "special_payments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CWorkshop_GetSpecialPayments_Response_SpecialPayment }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_GetSpecialPayments_Response>): CWorkshop_GetSpecialPayments_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.specialPayments = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_GetSpecialPayments_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_GetSpecialPayments_Response): CWorkshop_GetSpecialPayments_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments */ 1:
                    message.specialPayments.push(CWorkshop_GetSpecialPayments_Response_SpecialPayment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_GetSpecialPayments_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CWorkshop_GetSpecialPayments_Response.SpecialPayment special_payments = 1; */
        for (let i = 0; i < message.specialPayments.length; i++)
            CWorkshop_GetSpecialPayments_Response_SpecialPayment.internalBinaryWrite(message.specialPayments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Response
 */
export const CWorkshop_GetSpecialPayments_Response = new CWorkshop_GetSpecialPayments_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetSpecialPayments_Response_SpecialPayment$Type extends MessageType<CWorkshop_GetSpecialPayments_Response_SpecialPayment> {
    constructor() {
        super("CWorkshop_GetSpecialPayments_Response.SpecialPayment", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "date", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "net_payment_us_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "net_payment_row_usd", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_GetSpecialPayments_Response_SpecialPayment>): CWorkshop_GetSpecialPayments_Response_SpecialPayment {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_GetSpecialPayments_Response_SpecialPayment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_GetSpecialPayments_Response_SpecialPayment): CWorkshop_GetSpecialPayments_Response_SpecialPayment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 gameitemid */ 2:
                    message.gameitemid = reader.uint32();
                    break;
                case /* optional string date */ 3:
                    message.date = reader.string();
                    break;
                case /* optional uint64 net_payment_us_usd */ 4:
                    message.netPaymentUsUsd = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 net_payment_row_usd */ 5:
                    message.netPaymentRowUsd = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_GetSpecialPayments_Response_SpecialPayment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 gameitemid = 2; */
        if (message.gameitemid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameitemid);
        /* optional string date = 3; */
        if (message.date !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        /* optional uint64 net_payment_us_usd = 4; */
        if (message.netPaymentUsUsd !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.netPaymentUsUsd);
        /* optional uint64 net_payment_row_usd = 5; */
        if (message.netPaymentRowUsd !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.netPaymentRowUsd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetSpecialPayments_Response.SpecialPayment
 */
export const CWorkshop_GetSpecialPayments_Response_SpecialPayment = new CWorkshop_GetSpecialPayments_Response_SpecialPayment$Type();

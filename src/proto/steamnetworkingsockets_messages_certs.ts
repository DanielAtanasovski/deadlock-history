// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steamnetworkingsockets_messages_certs.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgSteamNetworkingIdentityLegacyBinary
 */
export interface CMsgSteamNetworkingIdentityLegacyBinary {
    /**
     * @generated from protobuf field: optional fixed64 steam_id = 16;
     */
    steamId?: bigint;
    /**
     * @generated from protobuf field: optional bytes generic_bytes = 2;
     */
    genericBytes?: Uint8Array;
    /**
     * @generated from protobuf field: optional string generic_string = 3;
     */
    genericString?: string;
    /**
     * @generated from protobuf field: optional bytes ipv6_and_port = 4;
     */
    ipv6AndPort?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramCertificate
 */
export interface CMsgSteamDatagramCertificate {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificate.EKeyType key_type = 1;
     */
    keyType?: CMsgSteamDatagramCertificate_EKeyType;
    /**
     * @generated from protobuf field: optional bytes key_data = 2;
     */
    keyData?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 legacy_steam_id = 4;
     */
    legacySteamId?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingIdentityLegacyBinary legacy_identity_binary = 11;
     */
    legacyIdentityBinary?: CMsgSteamNetworkingIdentityLegacyBinary;
    /**
     * @generated from protobuf field: optional string identity_string = 12;
     */
    identityString?: string;
    /**
     * @generated from protobuf field: repeated fixed32 gameserver_datacenter_ids = 5;
     */
    gameserverDatacenterIds: number[];
    /**
     * @generated from protobuf field: optional fixed32 time_created = 8;
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional fixed32 time_expiry = 9;
     */
    timeExpiry?: number;
    /**
     * @generated from protobuf field: repeated uint32 app_ids = 10;
     */
    appIds: number[];
    /**
     * @generated from protobuf field: repeated string ip_addresses = 13;
     */
    ipAddresses: string[];
}
/**
 * @generated from protobuf enum CMsgSteamDatagramCertificate.EKeyType
 */
export enum CMsgSteamDatagramCertificate_EKeyType {
    /**
     * @generated from protobuf enum value: INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: ED25519 = 1;
     */
    ED25519 = 1
}
/**
 * @generated from protobuf message CMsgSteamDatagramCertificateSigned
 */
export interface CMsgSteamDatagramCertificateSigned {
    /**
     * @generated from protobuf field: optional bytes cert = 4;
     */
    cert?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 ca_key_id = 5;
     */
    caKeyId?: bigint;
    /**
     * @generated from protobuf field: optional bytes ca_signature = 6;
     */
    caSignature?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes private_key_data = 1;
     */
    privateKeyData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramCertificateRequest
 */
export interface CMsgSteamDatagramCertificateRequest {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificate cert = 1;
     */
    cert?: CMsgSteamDatagramCertificate;
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingIdentityLegacyBinary$Type extends MessageType<CMsgSteamNetworkingIdentityLegacyBinary> {
    constructor() {
        super("CMsgSteamNetworkingIdentityLegacyBinary", [
            { no: 16, name: "steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "generic_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "generic_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ipv6_and_port", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingIdentityLegacyBinary>): CMsgSteamNetworkingIdentityLegacyBinary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingIdentityLegacyBinary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingIdentityLegacyBinary): CMsgSteamNetworkingIdentityLegacyBinary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steam_id */ 16:
                    message.steamId = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes generic_bytes */ 2:
                    message.genericBytes = reader.bytes();
                    break;
                case /* optional string generic_string */ 3:
                    message.genericString = reader.string();
                    break;
                case /* optional bytes ipv6_and_port */ 4:
                    message.ipv6AndPort = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingIdentityLegacyBinary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steam_id = 16; */
        if (message.steamId !== undefined)
            writer.tag(16, WireType.Bit64).fixed64(message.steamId);
        /* optional bytes generic_bytes = 2; */
        if (message.genericBytes !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.genericBytes);
        /* optional string generic_string = 3; */
        if (message.genericString !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.genericString);
        /* optional bytes ipv6_and_port = 4; */
        if (message.ipv6AndPort !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.ipv6AndPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingIdentityLegacyBinary
 */
export const CMsgSteamNetworkingIdentityLegacyBinary = new CMsgSteamNetworkingIdentityLegacyBinary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramCertificate$Type extends MessageType<CMsgSteamDatagramCertificate> {
    constructor() {
        super("CMsgSteamDatagramCertificate", [
            { no: 1, name: "key_type", kind: "enum", opt: true, T: () => ["CMsgSteamDatagramCertificate.EKeyType", CMsgSteamDatagramCertificate_EKeyType] },
            { no: 2, name: "key_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "legacy_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "legacy_identity_binary", kind: "message", T: () => CMsgSteamNetworkingIdentityLegacyBinary },
            { no: 12, name: "identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gameserver_datacenter_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "time_created", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "time_expiry", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "app_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "ip_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramCertificate>): CMsgSteamDatagramCertificate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gameserverDatacenterIds = [];
        message.appIds = [];
        message.ipAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramCertificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramCertificate): CMsgSteamDatagramCertificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramCertificate.EKeyType key_type */ 1:
                    message.keyType = reader.int32();
                    break;
                case /* optional bytes key_data */ 2:
                    message.keyData = reader.bytes();
                    break;
                case /* optional fixed64 legacy_steam_id */ 4:
                    message.legacySteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgSteamNetworkingIdentityLegacyBinary legacy_identity_binary */ 11:
                    message.legacyIdentityBinary = CMsgSteamNetworkingIdentityLegacyBinary.internalBinaryRead(reader, reader.uint32(), options, message.legacyIdentityBinary);
                    break;
                case /* optional string identity_string */ 12:
                    message.identityString = reader.string();
                    break;
                case /* repeated fixed32 gameserver_datacenter_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.gameserverDatacenterIds.push(reader.fixed32());
                    else
                        message.gameserverDatacenterIds.push(reader.fixed32());
                    break;
                case /* optional fixed32 time_created */ 8:
                    message.timeCreated = reader.fixed32();
                    break;
                case /* optional fixed32 time_expiry */ 9:
                    message.timeExpiry = reader.fixed32();
                    break;
                case /* repeated uint32 app_ids */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.appIds.push(reader.uint32());
                    else
                        message.appIds.push(reader.uint32());
                    break;
                case /* repeated string ip_addresses */ 13:
                    message.ipAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramCertificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramCertificate.EKeyType key_type = 1; */
        if (message.keyType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.keyType);
        /* optional bytes key_data = 2; */
        if (message.keyData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.keyData);
        /* optional fixed64 legacy_steam_id = 4; */
        if (message.legacySteamId !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.legacySteamId);
        /* optional CMsgSteamNetworkingIdentityLegacyBinary legacy_identity_binary = 11; */
        if (message.legacyIdentityBinary)
            CMsgSteamNetworkingIdentityLegacyBinary.internalBinaryWrite(message.legacyIdentityBinary, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional string identity_string = 12; */
        if (message.identityString !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.identityString);
        /* repeated fixed32 gameserver_datacenter_ids = 5; */
        for (let i = 0; i < message.gameserverDatacenterIds.length; i++)
            writer.tag(5, WireType.Bit32).fixed32(message.gameserverDatacenterIds[i]);
        /* optional fixed32 time_created = 8; */
        if (message.timeCreated !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.timeCreated);
        /* optional fixed32 time_expiry = 9; */
        if (message.timeExpiry !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.timeExpiry);
        /* repeated uint32 app_ids = 10; */
        for (let i = 0; i < message.appIds.length; i++)
            writer.tag(10, WireType.Varint).uint32(message.appIds[i]);
        /* repeated string ip_addresses = 13; */
        for (let i = 0; i < message.ipAddresses.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.ipAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramCertificate
 */
export const CMsgSteamDatagramCertificate = new CMsgSteamDatagramCertificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramCertificateSigned$Type extends MessageType<CMsgSteamDatagramCertificateSigned> {
    constructor() {
        super("CMsgSteamDatagramCertificateSigned", [
            { no: 4, name: "cert", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "ca_key_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "ca_signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 1, name: "private_key_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramCertificateSigned>): CMsgSteamDatagramCertificateSigned {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramCertificateSigned>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramCertificateSigned): CMsgSteamDatagramCertificateSigned {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes cert */ 4:
                    message.cert = reader.bytes();
                    break;
                case /* optional fixed64 ca_key_id */ 5:
                    message.caKeyId = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes ca_signature */ 6:
                    message.caSignature = reader.bytes();
                    break;
                case /* optional bytes private_key_data */ 1:
                    message.privateKeyData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramCertificateSigned, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes cert = 4; */
        if (message.cert !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.cert);
        /* optional fixed64 ca_key_id = 5; */
        if (message.caKeyId !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.caKeyId);
        /* optional bytes ca_signature = 6; */
        if (message.caSignature !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.caSignature);
        /* optional bytes private_key_data = 1; */
        if (message.privateKeyData !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.privateKeyData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramCertificateSigned
 */
export const CMsgSteamDatagramCertificateSigned = new CMsgSteamDatagramCertificateSigned$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramCertificateRequest$Type extends MessageType<CMsgSteamDatagramCertificateRequest> {
    constructor() {
        super("CMsgSteamDatagramCertificateRequest", [
            { no: 1, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificate }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramCertificateRequest>): CMsgSteamDatagramCertificateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramCertificateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramCertificateRequest): CMsgSteamDatagramCertificateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramCertificate cert */ 1:
                    message.cert = CMsgSteamDatagramCertificate.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramCertificateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramCertificate cert = 1; */
        if (message.cert)
            CMsgSteamDatagramCertificate.internalBinaryWrite(message.cert, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramCertificateRequest
 */
export const CMsgSteamDatagramCertificateRequest = new CMsgSteamDatagramCertificateRequest$Type();

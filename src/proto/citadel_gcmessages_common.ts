// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "citadel_gcmessages_common.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EGCPlatform } from "./steammessages";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";
/**
 * @generated from protobuf message CSOCitadelLobby
 */
export interface CSOCitadelLobby {
  /**
   * @generated from protobuf field: optional uint64 lobby_id = 1;
   */
  lobbyId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 match_id = 2;
   */
  matchId?: bigint;
  /**
   * @generated from protobuf field: optional ECitadelMatchMode match_mode = 3;
   */
  matchMode?: ECitadelMatchMode;
  /**
   * @generated from protobuf field: optional ECitadelGameMode game_mode = 4;
   */
  gameMode?: ECitadelGameMode;
  /**
   * @generated from protobuf field: optional uint32 compatibility_version = 5;
   */
  compatibilityVersion?: number;
  /**
   * @generated from protobuf field: repeated CExtraMsgBlock extra_messages = 6;
   */
  extraMessages: CExtraMsgBlock[];
  /**
   * @generated from protobuf field: optional fixed64 server_steam_id = 7;
   */
  serverSteamId?: bigint;
  /**
   * @generated from protobuf field: optional ELobbyServerState server_state = 8;
   */
  serverState?: ELobbyServerState;
  /**
   * @generated from protobuf field: optional uint32 udp_connect_ip = 9;
   */
  udpConnectIp?: number;
  /**
   * @generated from protobuf field: optional uint32 udp_connect_port = 10;
   */
  udpConnectPort?: number;
  /**
   * @generated from protobuf field: optional bytes sdr_address = 12;
   */
  sdrAddress?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint32 server_version = 13;
   */
  serverVersion?: number;
  /**
   * @generated from protobuf field: optional bool safe_to_abandon = 14;
   */
  safeToAbandon?: boolean;
}
/**
 * @generated from protobuf message CLobbyData_PostMatchSurvey
 */
export interface CLobbyData_PostMatchSurvey {
  /**
   * @generated from protobuf field: repeated CLobbyData_PostMatchSurvey.PlayerSurvey surveys = 1;
   */
  surveys: CLobbyData_PostMatchSurvey_PlayerSurvey[];
}
/**
 * @generated from protobuf message CLobbyData_PostMatchSurvey.PlayerSurvey
 */
export interface CLobbyData_PostMatchSurvey_PlayerSurvey {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 question_id = 2;
   */
  questionId?: number;
}
/**
 * @generated from protobuf message CMsgHeroSelectionMatchInfo
 */
export interface CMsgHeroSelectionMatchInfo {
  /**
   * @generated from protobuf field: repeated CMsgHeroSelectionMatchInfo.Hero hero_selections = 1;
   */
  heroSelections: CMsgHeroSelectionMatchInfo_Hero[];
}
/**
 * @generated from protobuf message CMsgHeroSelectionMatchInfo.Hero
 */
export interface CMsgHeroSelectionMatchInfo_Hero {
  /**
   * @generated from protobuf field: optional uint32 hero_id = 1;
   */
  heroId?: number;
  /**
   * @generated from protobuf field: optional uint32 priority = 2;
   */
  priority?: number;
}
/**
 * @generated from protobuf message CMsgStartFindingMatchInfo
 */
export interface CMsgStartFindingMatchInfo {
  /**
   * @generated from protobuf field: optional string server_search_key = 1;
   */
  serverSearchKey?: string;
  /**
   * @generated from protobuf field: optional string server_command_string = 2;
   */
  serverCommandString?: string;
  /**
   * @generated from protobuf field: optional ECitadelMatchMode match_mode = 3;
   */
  matchMode?: ECitadelMatchMode;
  /**
   * @generated from protobuf field: optional ECitadelGameMode game_mode = 5;
   */
  gameMode?: ECitadelGameMode;
  /**
   * @generated from protobuf field: optional bool solo_match = 6;
   */
  soloMatch?: boolean;
  /**
   * @generated from protobuf field: optional ECitadelBotDifficulty bot_difficulty = 7;
   */
  botDifficulty?: ECitadelBotDifficulty;
  /**
   * @generated from protobuf field: optional ECitadelRegionMode region_mode = 8;
   */
  regionMode?: ECitadelRegionMode;
}
/**
 * @generated from protobuf message CMsgAnyToGCReportAsserts
 */
export interface CMsgAnyToGCReportAsserts {
  /**
   * @generated from protobuf field: optional uint32 version = 1;
   */
  version?: number;
  /**
   * @generated from protobuf field: repeated CMsgAnyToGCReportAsserts.TrackedAssert asserts = 2;
   */
  asserts: CMsgAnyToGCReportAsserts_TrackedAssert[];
}
/**
 * @generated from protobuf message CMsgAnyToGCReportAsserts.TrackedAssert
 */
export interface CMsgAnyToGCReportAsserts_TrackedAssert {
  /**
   * @generated from protobuf field: optional string filename = 1;
   */
  filename?: string;
  /**
   * @generated from protobuf field: optional uint32 line_number = 2;
   */
  lineNumber?: number;
  /**
   * @generated from protobuf field: optional string sample_msg = 3;
   */
  sampleMsg?: string;
  /**
   * @generated from protobuf field: optional string sample_stack = 4;
   */
  sampleStack?: string;
  /**
   * @generated from protobuf field: optional uint32 times_fired = 5;
   */
  timesFired?: number;
  /**
   * @generated from protobuf field: optional string function_name = 6;
   */
  functionName?: string;
  /**
   * @generated from protobuf field: optional string condition = 7;
   */
  condition?: string;
  /**
   * @generated from protobuf field: optional uint32 total_times_fired = 8;
   */
  totalTimesFired?: number;
}
/**
 * @generated from protobuf message CMsgAnyToGCReportAssertsResponse
 */
export interface CMsgAnyToGCReportAssertsResponse {
  /**
   * @generated from protobuf field: optional bool success = 1;
   */
  success?: boolean;
}
/**
 * @generated from protobuf message CMsgRegionPingTimesClient
 */
export interface CMsgRegionPingTimesClient {
  /**
   * @generated from protobuf field: repeated fixed32 data_center_codes = 1 [packed = true];
   */
  dataCenterCodes: number[];
  /**
   * @generated from protobuf field: repeated uint32 ping_times = 2 [packed = true];
   */
  pingTimes: number[];
}
/**
 * @generated from protobuf message CSOCitadelParty
 */
export interface CSOCitadelParty {
  /**
   * @generated from protobuf field: optional uint64 party_id = 1;
   */
  partyId?: bigint;
  /**
   * @generated from protobuf field: repeated CSOCitadelParty.Member members = 2;
   */
  members: CSOCitadelParty_Member[];
  /**
   * @generated from protobuf field: repeated CSOCitadelParty.Invite invites = 3;
   */
  invites: CSOCitadelParty_Invite[];
  /**
   * @generated from protobuf field: optional string dev_server_command = 4;
   */
  devServerCommand?: string;
  /**
   * @generated from protobuf field: repeated CSOCitadelParty.LeftMember left_members = 5;
   */
  leftMembers: CSOCitadelParty_LeftMember[];
  /**
   * @generated from protobuf field: optional uint64 join_code = 6;
   */
  joinCode?: bigint;
  /**
   * @generated from protobuf field: optional ECitadelBotDifficulty bot_difficulty = 7;
   */
  botDifficulty?: ECitadelBotDifficulty;
  /**
   * @generated from protobuf field: optional ECitadelMatchMode match_mode = 9;
   */
  matchMode?: ECitadelMatchMode;
  /**
   * @generated from protobuf field: optional ECitadelGameMode game_mode = 10;
   */
  gameMode?: ECitadelGameMode;
  /**
   * @generated from protobuf field: optional uint32 match_making_start_time = 11;
   */
  matchMakingStartTime?: number;
  /**
   * @generated from protobuf field: optional string server_search_key = 12;
   */
  serverSearchKey?: string;
  /**
   * @generated from protobuf field: optional bool is_high_skill_range_party = 13;
   */
  isHighSkillRangeParty?: boolean;
  /**
   * @generated from protobuf field: optional CSOCitadelParty.EChatMode chat_mode = 14;
   */
  chatMode?: CSOCitadelParty_EChatMode;
  /**
   * @generated from protobuf field: optional ECitadelRegionMode region_mode = 15;
   */
  regionMode?: ECitadelRegionMode;
  /**
   * @generated from protobuf field: optional bool is_private_lobby = 16;
   */
  isPrivateLobby?: boolean;
  /**
   * @generated from protobuf field: optional CSOCitadelParty.PrivateLobbySettings private_lobby_settings = 17;
   */
  privateLobbySettings?: CSOCitadelParty_PrivateLobbySettings;
}
/**
 * @generated from protobuf message CSOCitadelParty.PrivateLobbySlot
 */
export interface CSOCitadelParty_PrivateLobbySlot {
  /**
   * @generated from protobuf field: optional uint32 slot_id = 1;
   */
  slotId?: number;
  /**
   * @generated from protobuf field: optional uint32 player_account_id = 2;
   */
  playerAccountId?: number;
}
/**
 * @generated from protobuf message CSOCitadelParty.PrivateLobbySettings
 */
export interface CSOCitadelParty_PrivateLobbySettings {
  /**
   * @generated from protobuf field: optional uint32 min_roster_size = 1;
   */
  minRosterSize?: number;
  /**
   * @generated from protobuf field: repeated CSOCitadelParty.PrivateLobbySlot match_slots = 2;
   */
  matchSlots: CSOCitadelParty_PrivateLobbySlot[];
}
/**
 * @generated from protobuf message CSOCitadelParty.Member
 */
export interface CSOCitadelParty_Member {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional string persona_name = 2;
   */
  personaName?: string;
  /**
   * @generated from protobuf field: optional uint32 rights_flags = 3;
   */
  rightsFlags?: number;
  /**
   * @generated from protobuf field: optional bool is_ready = 4;
   */
  isReady?: boolean;
  /**
   * @generated from protobuf field: optional CSOCitadelParty.EPlayerType player_type = 5;
   */
  playerType?: CSOCitadelParty_EPlayerType;
  /**
   * @generated from protobuf field: optional uint32 compatibility_version = 6;
   */
  compatibilityVersion?: number;
  /**
   * @generated from protobuf field: optional EGCPlatform platform = 7;
   */
  platform?: EGCPlatform;
  /**
   * @generated from protobuf field: optional uint32 team = 8;
   */
  team?: number;
  /**
   * @generated from protobuf field: optional CMsgHeroSelectionMatchInfo hero_roster = 9;
   */
  heroRoster?: CMsgHeroSelectionMatchInfo;
  /**
   * @generated from protobuf field: optional uint64 permissions = 10;
   */
  permissions?: bigint;
  /**
   * @generated from protobuf field: optional uint64 new_player_progress = 11;
   */
  newPlayerProgress?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 owned_heroes = 12 [packed = true];
   */
  ownedHeroes: number[];
}
/**
 * @generated from protobuf message CSOCitadelParty.LeftMember
 */
export interface CSOCitadelParty_LeftMember {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 rights_flags = 2;
   */
  rightsFlags?: number;
  /**
   * @generated from protobuf field: optional CSOCitadelParty.EPlayerType player_type = 3;
   */
  playerType?: CSOCitadelParty_EPlayerType;
}
/**
 * @generated from protobuf message CSOCitadelParty.Invite
 */
export interface CSOCitadelParty_Invite {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional string persona_name = 2;
   */
  personaName?: string;
  /**
   * @generated from protobuf field: optional uint32 invited_by = 3;
   */
  invitedBy?: number;
}
/**
 * @generated from protobuf enum CSOCitadelParty.EMemberRights
 */
export enum CSOCitadelParty_EMemberRights {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_eMemberRights_Admin = 1;
   */
  k_eMemberRights_Admin = 1,
  /**
   * @generated from protobuf enum value: k_eMemberRights_Creator = 2;
   */
  k_eMemberRights_Creator = 2,
}
/**
 * @generated from protobuf enum CSOCitadelParty.EPlayerType
 */
export enum CSOCitadelParty_EPlayerType {
  /**
   * @generated from protobuf enum value: k_ePlayerType_Player = 0;
   */
  k_ePlayerType_Player = 0,
  /**
   * @generated from protobuf enum value: k_ePlayerType_Spectator = 1;
   */
  k_ePlayerType_Spectator = 1,
}
/**
 * @generated from protobuf enum CSOCitadelParty.EChatMode
 */
export enum CSOCitadelParty_EChatMode {
  /**
   * @generated from protobuf enum value: k_eNone = 0;
   */
  k_eNone = 0,
  /**
   * @generated from protobuf enum value: k_ePartyChat = 1;
   */
  k_ePartyChat = 1,
  /**
   * @generated from protobuf enum value: k_eTeamChat = 2;
   */
  k_eTeamChat = 2,
}
/**
 * @generated from protobuf message CMsgMatchPlayerPathsData
 */
export interface CMsgMatchPlayerPathsData {
  /**
   * @generated from protobuf field: optional uint32 version = 1;
   */
  version?: number;
  /**
   * @generated from protobuf field: optional float interval_s = 2;
   */
  intervalS?: number;
  /**
   * @generated from protobuf field: optional uint32 x_resolution = 3;
   */
  xResolution?: number;
  /**
   * @generated from protobuf field: optional uint32 y_resolution = 4;
   */
  yResolution?: number;
  /**
   * @generated from protobuf field: repeated CMsgMatchPlayerPathsData.Path paths = 5;
   */
  paths: CMsgMatchPlayerPathsData_Path[];
}
/**
 * @generated from protobuf message CMsgMatchPlayerPathsData.Path
 */
export interface CMsgMatchPlayerPathsData_Path {
  /**
   * @generated from protobuf field: optional uint32 player_slot = 1;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: optional float x_min = 2;
   */
  xMin?: number;
  /**
   * @generated from protobuf field: optional float y_min = 3;
   */
  yMin?: number;
  /**
   * @generated from protobuf field: optional float x_max = 4;
   */
  xMax?: number;
  /**
   * @generated from protobuf field: optional float y_max = 5;
   */
  yMax?: number;
  /**
   * @generated from protobuf field: repeated uint32 x_pos = 6 [packed = true];
   */
  xPos: number[];
  /**
   * @generated from protobuf field: repeated uint32 y_pos = 7 [packed = true];
   */
  yPos: number[];
  /**
   * @generated from protobuf field: repeated bool alive = 8 [packed = true];
   */
  alive: boolean[];
  /**
   * @generated from protobuf field: repeated uint32 health = 9 [packed = true];
   */
  health: number[];
}
/**
 * @generated from protobuf message CMsgMatchPlayerDamageMatrix
 */
export interface CMsgMatchPlayerDamageMatrix {
  /**
   * @generated from protobuf field: repeated CMsgMatchPlayerDamageMatrix.DamageDealer damage_dealers = 1;
   */
  damageDealers: CMsgMatchPlayerDamageMatrix_DamageDealer[];
  /**
   * @generated from protobuf field: repeated uint32 sample_time_s = 2 [packed = true];
   */
  sampleTimeS: number[];
  /**
   * @generated from protobuf field: optional CMsgMatchPlayerDamageMatrix.SourceDetails source_details = 3;
   */
  sourceDetails?: CMsgMatchPlayerDamageMatrix_SourceDetails;
}
/**
 * @generated from protobuf message CMsgMatchPlayerDamageMatrix.DamageToPlayer
 */
export interface CMsgMatchPlayerDamageMatrix_DamageToPlayer {
  /**
   * @generated from protobuf field: optional uint32 target_player_slot = 1;
   */
  targetPlayerSlot?: number;
  /**
   * @generated from protobuf field: repeated uint32 damage = 2 [packed = true];
   */
  damage: number[];
}
/**
 * @generated from protobuf message CMsgMatchPlayerDamageMatrix.DamageSource
 */
export interface CMsgMatchPlayerDamageMatrix_DamageSource {
  /**
   * @generated from protobuf field: repeated CMsgMatchPlayerDamageMatrix.DamageToPlayer damage_to_players = 2;
   */
  damageToPlayers: CMsgMatchPlayerDamageMatrix_DamageToPlayer[];
  /**
   * @generated from protobuf field: optional uint32 source_details_index = 4;
   */
  sourceDetailsIndex?: number;
}
/**
 * @generated from protobuf message CMsgMatchPlayerDamageMatrix.DamageDealer
 */
export interface CMsgMatchPlayerDamageMatrix_DamageDealer {
  /**
   * @generated from protobuf field: optional uint32 dealer_player_slot = 1;
   */
  dealerPlayerSlot?: number;
  /**
   * @generated from protobuf field: repeated CMsgMatchPlayerDamageMatrix.DamageSource damage_sources = 2;
   */
  damageSources: CMsgMatchPlayerDamageMatrix_DamageSource[];
}
/**
 * @generated from protobuf message CMsgMatchPlayerDamageMatrix.SourceDetails
 */
export interface CMsgMatchPlayerDamageMatrix_SourceDetails {
  /**
   * @generated from protobuf field: repeated CMsgMatchPlayerDamageMatrix.EStatType stat_type = 1 [packed = true];
   */
  statType: CMsgMatchPlayerDamageMatrix_EStatType[];
  /**
   * @generated from protobuf field: repeated string source_name = 2;
   */
  sourceName: string[];
}
/**
 * @generated from protobuf enum CMsgMatchPlayerDamageMatrix.EStatType
 */
export enum CMsgMatchPlayerDamageMatrix_EStatType {
  /**
   * @generated from protobuf enum value: k_eType_Damage = 0;
   */
  k_eType_Damage = 0,
  /**
   * @generated from protobuf enum value: k_eType_Healing = 1;
   */
  k_eType_Healing = 1,
  /**
   * @generated from protobuf enum value: k_eType_HealPrevented = 2;
   */
  k_eType_HealPrevented = 2,
  /**
   * @generated from protobuf enum value: k_eType_Mitigated = 3;
   */
  k_eType_Mitigated = 3,
  /**
   * @generated from protobuf enum value: k_eType_LethalDamage = 4;
   */
  k_eType_LethalDamage = 4,
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents
 */
export interface CMsgMatchMetaDataContents {
  /**
   * @generated from protobuf field: optional CMsgMatchMetaDataContents.MatchInfo match_info = 2;
   */
  matchInfo?: CMsgMatchMetaDataContents_MatchInfo;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Position
 */
export interface CMsgMatchMetaDataContents_Position {
  /**
   * @generated from protobuf field: optional float x = 1;
   */
  x?: number;
  /**
   * @generated from protobuf field: optional float y = 2;
   */
  y?: number;
  /**
   * @generated from protobuf field: optional float z = 3;
   */
  z?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Deaths
 */
export interface CMsgMatchMetaDataContents_Deaths {
  /**
   * @generated from protobuf field: optional uint32 game_time_s = 1;
   */
  gameTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 killer_player_slot = 9;
   */
  killerPlayerSlot?: number;
  /**
   * @generated from protobuf field: optional CMsgMatchMetaDataContents.Position death_pos = 10;
   */
  deathPos?: CMsgMatchMetaDataContents_Position;
  /**
   * @generated from protobuf field: optional CMsgMatchMetaDataContents.Position killer_pos = 11;
   */
  killerPos?: CMsgMatchMetaDataContents_Position;
  /**
   * @generated from protobuf field: optional uint32 death_duration_s = 12;
   */
  deathDurationS?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Items
 */
export interface CMsgMatchMetaDataContents_Items {
  /**
   * @generated from protobuf field: optional uint32 game_time_s = 1;
   */
  gameTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 item_id = 2;
   */
  itemId?: number;
  /**
   * @generated from protobuf field: optional uint32 upgrade_id = 3;
   */
  upgradeId?: number;
  /**
   * @generated from protobuf field: optional uint32 sold_time_s = 4;
   */
  soldTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 flags = 5;
   */
  flags?: number;
  /**
   * @generated from protobuf field: optional uint32 imbued_ability_id = 6;
   */
  imbuedAbilityId?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Ping
 */
export interface CMsgMatchMetaDataContents_Ping {
  /**
   * @generated from protobuf field: optional uint32 ping_type = 1;
   */
  pingType?: number;
  /**
   * @generated from protobuf field: optional uint32 ping_data = 2;
   */
  pingData?: number;
  /**
   * @generated from protobuf field: optional uint32 game_time_s = 3;
   */
  gameTimeS?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.GoldSource
 */
export interface CMsgMatchMetaDataContents_GoldSource {
  /**
   * @generated from protobuf field: optional CMsgMatchMetaDataContents.EGoldSource source = 1;
   */
  source?: CMsgMatchMetaDataContents_EGoldSource;
  /**
   * @generated from protobuf field: optional uint32 kills = 2;
   */
  kills?: number;
  /**
   * @generated from protobuf field: optional uint32 damage = 3;
   */
  damage?: number;
  /**
   * @generated from protobuf field: optional uint32 gold = 4;
   */
  gold?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_orbs = 5;
   */
  goldOrbs?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.CustomUserStatInfo
 */
export interface CMsgMatchMetaDataContents_CustomUserStatInfo {
  /**
   * @generated from protobuf field: optional string name = 1;
   */
  name?: string;
  /**
   * @generated from protobuf field: optional uint32 id = 2;
   */
  id?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.CustomUserStat
 */
export interface CMsgMatchMetaDataContents_CustomUserStat {
  /**
   * @generated from protobuf field: optional uint32 value = 2;
   */
  value?: number;
  /**
   * @generated from protobuf field: optional uint32 id = 3;
   */
  id?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.PlayerStats
 */
export interface CMsgMatchMetaDataContents_PlayerStats {
  /**
   * @generated from protobuf field: optional uint32 time_stamp_s = 1;
   */
  timeStampS?: number;
  /**
   * @generated from protobuf field: optional uint32 net_worth = 2;
   */
  netWorth?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_player = 3;
   */
  goldPlayer?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_player_orbs = 4;
   */
  goldPlayerOrbs?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_lane_creep_orbs = 5;
   */
  goldLaneCreepOrbs?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_neutral_creep_orbs = 6;
   */
  goldNeutralCreepOrbs?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_boss = 7;
   */
  goldBoss?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_boss_orb = 8;
   */
  goldBossOrb?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_treasure = 9;
   */
  goldTreasure?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_denied = 10;
   */
  goldDenied?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_death_loss = 11;
   */
  goldDeathLoss?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_lane_creep = 12;
   */
  goldLaneCreep?: number;
  /**
   * @generated from protobuf field: optional uint32 gold_neutral_creep = 13;
   */
  goldNeutralCreep?: number;
  /**
   * @generated from protobuf field: optional uint32 kills = 14;
   */
  kills?: number;
  /**
   * @generated from protobuf field: optional uint32 deaths = 15;
   */
  deaths?: number;
  /**
   * @generated from protobuf field: optional uint32 assists = 16;
   */
  assists?: number;
  /**
   * @generated from protobuf field: optional uint32 creep_kills = 17;
   */
  creepKills?: number;
  /**
   * @generated from protobuf field: optional uint32 neutral_kills = 18;
   */
  neutralKills?: number;
  /**
   * @generated from protobuf field: optional uint32 possible_creeps = 19;
   */
  possibleCreeps?: number;
  /**
   * @generated from protobuf field: optional uint32 creep_damage = 20;
   */
  creepDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 player_damage = 21;
   */
  playerDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 neutral_damage = 22;
   */
  neutralDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 boss_damage = 23;
   */
  bossDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 denies = 24;
   */
  denies?: number;
  /**
   * @generated from protobuf field: optional uint32 player_healing = 25;
   */
  playerHealing?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_points = 26;
   */
  abilityPoints?: number;
  /**
   * @generated from protobuf field: optional uint32 self_healing = 27;
   */
  selfHealing?: number;
  /**
   * @generated from protobuf field: optional uint32 player_damage_taken = 28;
   */
  playerDamageTaken?: number;
  /**
   * @generated from protobuf field: optional uint32 max_health = 29;
   */
  maxHealth?: number;
  /**
   * @generated from protobuf field: optional uint32 weapon_power = 30;
   */
  weaponPower?: number;
  /**
   * @generated from protobuf field: optional uint32 tech_power = 31;
   */
  techPower?: number;
  /**
   * @generated from protobuf field: optional uint32 shots_hit = 32;
   */
  shotsHit?: number;
  /**
   * @generated from protobuf field: optional uint32 shots_missed = 33;
   */
  shotsMissed?: number;
  /**
   * @generated from protobuf field: optional uint32 damage_absorbed = 34;
   */
  damageAbsorbed?: number;
  /**
   * @generated from protobuf field: optional uint32 absorption_provided = 35;
   */
  absorptionProvided?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_bullets_hit = 36;
   */
  heroBulletsHit?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_bullets_hit_crit = 37;
   */
  heroBulletsHitCrit?: number;
  /**
   * @generated from protobuf field: optional uint32 heal_prevented = 38;
   */
  healPrevented?: number;
  /**
   * @generated from protobuf field: optional uint32 heal_lost = 39;
   */
  healLost?: number;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.GoldSource gold_sources = 40;
   */
  goldSources: CMsgMatchMetaDataContents_GoldSource[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.CustomUserStat custom_user_stats = 41;
   */
  customUserStats: CMsgMatchMetaDataContents_CustomUserStat[];
  /**
   * @generated from protobuf field: optional uint32 damage_mitigated = 42;
   */
  damageMitigated?: number;
  /**
   * @generated from protobuf field: optional uint32 level = 43;
   */
  level?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.AbilityStat
 */
export interface CMsgMatchMetaDataContents_AbilityStat {
  /**
   * @generated from protobuf field: optional uint32 ability_id = 1;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_value = 2;
   */
  abilityValue?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.BookReward
 */
export interface CMsgMatchMetaDataContents_BookReward {
  /**
   * @generated from protobuf field: optional uint32 book_id = 1;
   */
  bookId?: number;
  /**
   * @generated from protobuf field: optional uint32 xp_amount = 2;
   */
  xpAmount?: number;
  /**
   * @generated from protobuf field: optional uint32 starting_xp = 3;
   */
  startingXp?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Players
 */
export interface CMsgMatchMetaDataContents_Players {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 player_slot = 2;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Deaths death_details = 3;
   */
  deathDetails: CMsgMatchMetaDataContents_Deaths[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Items items = 4;
   */
  items: CMsgMatchMetaDataContents_Items[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.PlayerStats stats = 5;
   */
  stats: CMsgMatchMetaDataContents_PlayerStats[];
  /**
   * @generated from protobuf field: optional ECitadelLobbyTeam team = 6;
   */
  team?: ECitadelLobbyTeam;
  /**
   * @generated from protobuf field: optional uint32 kills = 8;
   */
  kills?: number;
  /**
   * @generated from protobuf field: optional uint32 deaths = 9;
   */
  deaths?: number;
  /**
   * @generated from protobuf field: optional uint32 assists = 10;
   */
  assists?: number;
  /**
   * @generated from protobuf field: optional uint32 net_worth = 11;
   */
  netWorth?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_id = 12;
   */
  heroId?: number;
  /**
   * @generated from protobuf field: optional uint32 last_hits = 13;
   */
  lastHits?: number;
  /**
   * @generated from protobuf field: optional uint32 denies = 14;
   */
  denies?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_points = 15;
   */
  abilityPoints?: number;
  /**
   * @generated from protobuf field: optional uint32 party = 16;
   */
  party?: number;
  /**
   * @generated from protobuf field: optional uint32 assigned_lane = 17;
   */
  assignedLane?: number;
  /**
   * @generated from protobuf field: optional uint32 level = 18;
   */
  level?: number;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Ping pings = 19;
   */
  pings: CMsgMatchMetaDataContents_Ping[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.AbilityStat ability_stats = 20;
   */
  abilityStats: CMsgMatchMetaDataContents_AbilityStat[];
  /**
   * @generated from protobuf field: repeated float stats_type_stat = 21 [packed = true];
   */
  statsTypeStat: number[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.BookReward book_rewards = 22;
   */
  bookRewards: CMsgMatchMetaDataContents_BookReward[];
  /**
   * @generated from protobuf field: optional uint32 abandon_match_time_s = 23;
   */
  abandonMatchTimeS?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Objective
 */
export interface CMsgMatchMetaDataContents_Objective {
  /**
   * @generated from protobuf field: optional ECitadelObjective legacy_objective_id = 1;
   */
  legacyObjectiveId?: ECitadelObjective;
  /**
   * @generated from protobuf field: optional uint32 destroyed_time_s = 2;
   */
  destroyedTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 creep_damage = 4;
   */
  creepDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 creep_damage_mitigated = 5;
   */
  creepDamageMitigated?: number;
  /**
   * @generated from protobuf field: optional uint32 player_damage = 6;
   */
  playerDamage?: number;
  /**
   * @generated from protobuf field: optional uint32 player_damage_mitigated = 7;
   */
  playerDamageMitigated?: number;
  /**
   * @generated from protobuf field: optional uint32 first_damage_time_s = 8;
   */
  firstDamageTimeS?: number;
  /**
   * @generated from protobuf field: optional ECitadelTeamObjective team_objective_id = 9;
   */
  teamObjectiveId?: ECitadelTeamObjective;
  /**
   * @generated from protobuf field: optional ECitadelLobbyTeam team = 10;
   */
  team?: ECitadelLobbyTeam;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.MidBoss
 */
export interface CMsgMatchMetaDataContents_MidBoss {
  /**
   * @generated from protobuf field: optional ECitadelLobbyTeam team_killed = 1;
   */
  teamKilled?: ECitadelLobbyTeam;
  /**
   * @generated from protobuf field: optional ECitadelLobbyTeam team_claimed = 2;
   */
  teamClaimed?: ECitadelLobbyTeam;
  /**
   * @generated from protobuf field: optional uint32 destroyed_time_s = 3;
   */
  destroyedTimeS?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.Pause
 */
export interface CMsgMatchMetaDataContents_Pause {
  /**
   * @generated from protobuf field: optional uint32 game_time_s = 1;
   */
  gameTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 pause_duration_s = 2;
   */
  pauseDurationS?: number;
  /**
   * @generated from protobuf field: optional uint32 player_slot = 3;
   */
  playerSlot?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.WatchedDeathReplay
 */
export interface CMsgMatchMetaDataContents_WatchedDeathReplay {
  /**
   * @generated from protobuf field: optional uint32 game_time_s = 1;
   */
  gameTimeS?: number;
  /**
   * @generated from protobuf field: optional uint32 player_slot = 2;
   */
  playerSlot?: number;
}
/**
 * @generated from protobuf message CMsgMatchMetaDataContents.MatchInfo
 */
export interface CMsgMatchMetaDataContents_MatchInfo {
  /**
   * @generated from protobuf field: optional uint32 duration_s = 1;
   */
  durationS?: number;
  /**
   * @generated from protobuf field: optional CMsgMatchMetaDataContents.EMatchOutcome match_outcome = 2;
   */
  matchOutcome?: CMsgMatchMetaDataContents_EMatchOutcome;
  /**
   * @generated from protobuf field: optional ECitadelLobbyTeam winning_team = 3;
   */
  winningTeam?: ECitadelLobbyTeam;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Players players = 4;
   */
  players: CMsgMatchMetaDataContents_Players[];
  /**
   * @generated from protobuf field: optional uint32 start_time = 5;
   */
  startTime?: number;
  /**
   * @generated from protobuf field: optional uint64 match_id = 6;
   */
  matchId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 legacy_objectives_mask = 8;
   */
  legacyObjectivesMask?: number;
  /**
   * @generated from protobuf field: optional ECitadelGameMode game_mode = 9;
   */
  gameMode?: ECitadelGameMode;
  /**
   * @generated from protobuf field: optional ECitadelMatchMode match_mode = 10;
   */
  matchMode?: ECitadelMatchMode;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Objective objectives = 11;
   */
  objectives: CMsgMatchMetaDataContents_Objective[];
  /**
   * @generated from protobuf field: optional CMsgMatchPlayerPathsData match_paths = 12;
   */
  matchPaths?: CMsgMatchPlayerPathsData;
  /**
   * @generated from protobuf field: optional CMsgMatchPlayerDamageMatrix damage_matrix = 13;
   */
  damageMatrix?: CMsgMatchPlayerDamageMatrix;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.Pause match_pauses = 14;
   */
  matchPauses: CMsgMatchMetaDataContents_Pause[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.CustomUserStatInfo custom_user_stats = 15;
   */
  customUserStats: CMsgMatchMetaDataContents_CustomUserStatInfo[];
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.WatchedDeathReplay watched_death_replays = 16;
   */
  watchedDeathReplays: CMsgMatchMetaDataContents_WatchedDeathReplay[];
  /**
   * @generated from protobuf field: optional uint64 objectives_mask_team0 = 17;
   */
  objectivesMaskTeam0?: bigint;
  /**
   * @generated from protobuf field: optional uint64 objectives_mask_team1 = 18;
   */
  objectivesMaskTeam1?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgMatchMetaDataContents.MidBoss mid_boss = 19;
   */
  midBoss: CMsgMatchMetaDataContents_MidBoss[];
}
/**
 * @generated from protobuf enum CMsgMatchMetaDataContents.EMatchOutcome
 */
export enum CMsgMatchMetaDataContents_EMatchOutcome {
  /**
   * @generated from protobuf enum value: k_eOutcome_TeamWin = 0;
   */
  k_eOutcome_TeamWin = 0,
  /**
   * @generated from protobuf enum value: k_eOutcome_Error = 1;
   */
  k_eOutcome_Error = 1,
}
/**
 * @generated from protobuf enum CMsgMatchMetaDataContents.EGoldSource
 */
export enum CMsgMatchMetaDataContents_EGoldSource {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_ePlayers = 1;
   */
  k_ePlayers = 1,
  /**
   * @generated from protobuf enum value: k_eLaneCreeps = 2;
   */
  k_eLaneCreeps = 2,
  /**
   * @generated from protobuf enum value: k_eNeutrals = 3;
   */
  k_eNeutrals = 3,
  /**
   * @generated from protobuf enum value: k_eBosses = 4;
   */
  k_eBosses = 4,
  /**
   * @generated from protobuf enum value: k_eTreasure = 5;
   */
  k_eTreasure = 5,
  /**
   * @generated from protobuf enum value: k_eAssists = 6;
   */
  k_eAssists = 6,
  /**
   * @generated from protobuf enum value: k_eDenies = 7;
   */
  k_eDenies = 7,
}
/**
 * @generated from protobuf message CMsgMatchMetaData
 */
export interface CMsgMatchMetaData {
  /**
   * @generated from protobuf field: optional uint32 version = 1;
   */
  version?: number;
  /**
   * @generated from protobuf field: optional bytes match_details = 2;
   */
  matchDetails?: Uint8Array;
  /**
   * @generated from protobuf field: optional uint64 match_id = 3;
   */
  matchId?: bigint;
}
/**
 * @generated from protobuf message CMsgMapLine
 */
export interface CMsgMapLine {
  /**
   * @generated from protobuf field: optional int32 x = 1;
   */
  x?: number;
  /**
   * @generated from protobuf field: optional int32 y = 2;
   */
  y?: number;
  /**
   * @generated from protobuf field: optional bool initial = 3;
   */
  initial?: boolean;
}
/**
 * @generated from protobuf message CMsgAccountHeroStats
 */
export interface CMsgAccountHeroStats {
  /**
   * @generated from protobuf field: optional uint32 hero_id = 1;
   */
  heroId?: number;
  /**
   * @generated from protobuf field: repeated uint32 stat_id = 2;
   */
  statId: number[];
  /**
   * @generated from protobuf field: repeated uint64 total_value = 3;
   */
  totalValue: bigint[];
  /**
   * @generated from protobuf field: repeated uint32 medals_bronze = 4;
   */
  medalsBronze: number[];
  /**
   * @generated from protobuf field: repeated uint32 medals_silver = 5;
   */
  medalsSilver: number[];
  /**
   * @generated from protobuf field: repeated uint32 medals_gold = 6;
   */
  medalsGold: number[];
}
/**
 * @generated from protobuf message CMsgAccountBookStats
 */
export interface CMsgAccountBookStats {
  /**
   * @generated from protobuf field: optional uint32 book_id = 1;
   */
  bookId?: number;
  /**
   * @generated from protobuf field: optional uint32 book_xp = 2;
   */
  bookXp?: number;
  /**
   * @generated from protobuf field: optional uint32 book_max_xp = 3;
   */
  bookMaxXp?: number;
}
/**
 * @generated from protobuf message CMsgAccountStats
 */
export interface CMsgAccountStats {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: repeated CMsgAccountHeroStats stats = 2;
   */
  stats: CMsgAccountHeroStats[];
}
/**
 * @generated from protobuf enum CMsgLaneColor
 */
export enum CMsgLaneColor {
  /**
   * @generated from protobuf enum value: k_ELaneColor_Invalid = 0;
   */
  k_ELaneColor_Invalid = 0,
  /**
   * @generated from protobuf enum value: k_ELaneColor_Yellow = 1;
   */
  k_ELaneColor_Yellow = 1,
  /**
   * @generated from protobuf enum value: k_ELaneColor_Green = 3;
   */
  k_ELaneColor_Green = 3,
  /**
   * @generated from protobuf enum value: k_ELaneColor_Blue = 4;
   */
  k_ELaneColor_Blue = 4,
  /**
   * @generated from protobuf enum value: k_ELaneColor_Purple = 6;
   */
  k_ELaneColor_Purple = 6,
}
/**
 * @generated from protobuf enum EGCCitadelCommonMessages
 */
export enum EGCCitadelCommonMessages {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_EMsgAnyToGCReportAsserts = 7000;
   */
  k_EMsgAnyToGCReportAsserts = 7000,
  /**
   * @generated from protobuf enum value: k_EMsgAnyToGCReportAssertsResponse = 7001;
   */
  k_EMsgAnyToGCReportAssertsResponse = 7001,
}
/**
 * @generated from protobuf enum ECitadelMatchMode
 */
export enum ECitadelMatchMode {
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_Invalid = 0;
   */
  k_ECitadelMatchMode_Invalid = 0,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_Unranked = 1;
   */
  k_ECitadelMatchMode_Unranked = 1,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_PrivateLobby = 2;
   */
  k_ECitadelMatchMode_PrivateLobby = 2,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_CoopBot = 3;
   */
  k_ECitadelMatchMode_CoopBot = 3,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_Ranked = 4;
   */
  k_ECitadelMatchMode_Ranked = 4,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_ServerTest = 5;
   */
  k_ECitadelMatchMode_ServerTest = 5,
  /**
   * @generated from protobuf enum value: k_ECitadelMatchMode_Tutorial = 6;
   */
  k_ECitadelMatchMode_Tutorial = 6,
}
/**
 * @generated from protobuf enum ECitadelLobbyTeam
 */
export enum ECitadelLobbyTeam {
  /**
   * @generated from protobuf enum value: k_ECitadelLobbyTeam_Team0 = 0;
   */
  k_ECitadelLobbyTeam_Team0 = 0,
  /**
   * @generated from protobuf enum value: k_ECitadelLobbyTeam_Team1 = 1;
   */
  k_ECitadelLobbyTeam_Team1 = 1,
  /**
   * @generated from protobuf enum value: k_ECitadelLobbyTeam_Spectator = 16;
   */
  k_ECitadelLobbyTeam_Spectator = 16,
}
/**
 * @generated from protobuf enum ECitadelAccountStatMedal
 */
export enum ECitadelAccountStatMedal {
  /**
   * @generated from protobuf enum value: k_eNone = 0;
   */
  k_eNone = 0,
  /**
   * @generated from protobuf enum value: k_eBronze = 1;
   */
  k_eBronze = 1,
  /**
   * @generated from protobuf enum value: k_eSilver = 2;
   */
  k_eSilver = 2,
  /**
   * @generated from protobuf enum value: k_eGold = 3;
   */
  k_eGold = 3,
}
/**
 * @generated from protobuf enum ECitadelObjective
 */
export enum ECitadelObjective {
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Core = 0;
   */
  k_eCitadelObjective_Team0_Core = 0,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier1_Lane1 = 1;
   */
  k_eCitadelObjective_Team0_Tier1_Lane1 = 1,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier1_Lane2 = 2;
   */
  k_eCitadelObjective_Team0_Tier1_Lane2 = 2,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier1_Lane3 = 3;
   */
  k_eCitadelObjective_Team0_Tier1_Lane3 = 3,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier1_Lane4 = 4;
   */
  k_eCitadelObjective_Team0_Tier1_Lane4 = 4,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier2_Lane1 = 5;
   */
  k_eCitadelObjective_Team0_Tier2_Lane1 = 5,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier2_Lane2 = 6;
   */
  k_eCitadelObjective_Team0_Tier2_Lane2 = 6,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier2_Lane3 = 7;
   */
  k_eCitadelObjective_Team0_Tier2_Lane3 = 7,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Tier2_Lane4 = 8;
   */
  k_eCitadelObjective_Team0_Tier2_Lane4 = 8,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_Titan = 9;
   */
  k_eCitadelObjective_Team0_Titan = 9,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_TitanShieldGenerator_1 = 10;
   */
  k_eCitadelObjective_Team0_TitanShieldGenerator_1 = 10,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_TitanShieldGenerator_2 = 11;
   */
  k_eCitadelObjective_Team0_TitanShieldGenerator_2 = 11,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_BarrackBoss_Lane1 = 12;
   */
  k_eCitadelObjective_Team0_BarrackBoss_Lane1 = 12,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_BarrackBoss_Lane2 = 13;
   */
  k_eCitadelObjective_Team0_BarrackBoss_Lane2 = 13,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_BarrackBoss_Lane3 = 14;
   */
  k_eCitadelObjective_Team0_BarrackBoss_Lane3 = 14,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team0_BarrackBoss_Lane4 = 15;
   */
  k_eCitadelObjective_Team0_BarrackBoss_Lane4 = 15,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Core = 16;
   */
  k_eCitadelObjective_Team1_Core = 16,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier1_Lane1 = 17;
   */
  k_eCitadelObjective_Team1_Tier1_Lane1 = 17,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier1_Lane2 = 18;
   */
  k_eCitadelObjective_Team1_Tier1_Lane2 = 18,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier1_Lane3 = 19;
   */
  k_eCitadelObjective_Team1_Tier1_Lane3 = 19,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier1_Lane4 = 20;
   */
  k_eCitadelObjective_Team1_Tier1_Lane4 = 20,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier2_Lane1 = 21;
   */
  k_eCitadelObjective_Team1_Tier2_Lane1 = 21,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier2_Lane2 = 22;
   */
  k_eCitadelObjective_Team1_Tier2_Lane2 = 22,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier2_Lane3 = 23;
   */
  k_eCitadelObjective_Team1_Tier2_Lane3 = 23,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Tier2_Lane4 = 24;
   */
  k_eCitadelObjective_Team1_Tier2_Lane4 = 24,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_Titan = 25;
   */
  k_eCitadelObjective_Team1_Titan = 25,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_TitanShieldGenerator_1 = 26;
   */
  k_eCitadelObjective_Team1_TitanShieldGenerator_1 = 26,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_TitanShieldGenerator_2 = 27;
   */
  k_eCitadelObjective_Team1_TitanShieldGenerator_2 = 27,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_BarrackBoss_Lane1 = 28;
   */
  k_eCitadelObjective_Team1_BarrackBoss_Lane1 = 28,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_BarrackBoss_Lane2 = 29;
   */
  k_eCitadelObjective_Team1_BarrackBoss_Lane2 = 29,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_BarrackBoss_Lane3 = 30;
   */
  k_eCitadelObjective_Team1_BarrackBoss_Lane3 = 30,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Team1_BarrackBoss_Lane4 = 31;
   */
  k_eCitadelObjective_Team1_BarrackBoss_Lane4 = 31,
  /**
   * @generated from protobuf enum value: k_eCitadelObjective_Neutral_Mid = 32;
   */
  k_eCitadelObjective_Neutral_Mid = 32,
}
/**
 * @generated from protobuf enum ECitadelTeamObjective
 */
export enum ECitadelTeamObjective {
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Core = 0;
   */
  k_eCitadelTeamObjective_Core = 0,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier1_Lane1 = 1;
   */
  k_eCitadelTeamObjective_Tier1_Lane1 = 1,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier1_Lane2 = 2;
   */
  k_eCitadelTeamObjective_Tier1_Lane2 = 2,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier1_Lane3 = 3;
   */
  k_eCitadelTeamObjective_Tier1_Lane3 = 3,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier1_Lane4 = 4;
   */
  k_eCitadelTeamObjective_Tier1_Lane4 = 4,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier2_Lane1 = 5;
   */
  k_eCitadelTeamObjective_Tier2_Lane1 = 5,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier2_Lane2 = 6;
   */
  k_eCitadelTeamObjective_Tier2_Lane2 = 6,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier2_Lane3 = 7;
   */
  k_eCitadelTeamObjective_Tier2_Lane3 = 7,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Tier2_Lane4 = 8;
   */
  k_eCitadelTeamObjective_Tier2_Lane4 = 8,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_Titan = 9;
   */
  k_eCitadelTeamObjective_Titan = 9,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_TitanShieldGenerator_1 = 10;
   */
  k_eCitadelTeamObjective_TitanShieldGenerator_1 = 10,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_TitanShieldGenerator_2 = 11;
   */
  k_eCitadelTeamObjective_TitanShieldGenerator_2 = 11,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_BarrackBoss_Lane1 = 12;
   */
  k_eCitadelTeamObjective_BarrackBoss_Lane1 = 12,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_BarrackBoss_Lane2 = 13;
   */
  k_eCitadelTeamObjective_BarrackBoss_Lane2 = 13,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_BarrackBoss_Lane3 = 14;
   */
  k_eCitadelTeamObjective_BarrackBoss_Lane3 = 14,
  /**
   * @generated from protobuf enum value: k_eCitadelTeamObjective_BarrackBoss_Lane4 = 15;
   */
  k_eCitadelTeamObjective_BarrackBoss_Lane4 = 15,
}
/**
 * @generated from protobuf enum ECitadelBotDifficulty
 */
export enum ECitadelBotDifficulty {
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_None = 0;
   */
  k_ECitadelBotDifficulty_None = 0,
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_Easy = 1;
   */
  k_ECitadelBotDifficulty_Easy = 1,
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_Medium = 2;
   */
  k_ECitadelBotDifficulty_Medium = 2,
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_Hard = 3;
   */
  k_ECitadelBotDifficulty_Hard = 3,
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_Nightmare = 4;
   */
  k_ECitadelBotDifficulty_Nightmare = 4,
  /**
   * @generated from protobuf enum value: k_ECitadelBotDifficulty_Guided = 5;
   */
  k_ECitadelBotDifficulty_Guided = 5,
}
/**
 * @generated from protobuf enum ECitadelRegionMode
 */
export enum ECitadelRegionMode {
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_ROW = 0;
   */
  k_ECitadelRegionMode_ROW = 0,
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_Europe = 1;
   */
  k_ECitadelRegionMode_Europe = 1,
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_SEAsia = 2;
   */
  k_ECitadelRegionMode_SEAsia = 2,
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_SAmerica = 3;
   */
  k_ECitadelRegionMode_SAmerica = 3,
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_Russia = 4;
   */
  k_ECitadelRegionMode_Russia = 4,
  /**
   * @generated from protobuf enum value: k_ECitadelRegionMode_Oceania = 5;
   */
  k_ECitadelRegionMode_Oceania = 5,
}
/**
 * @generated from protobuf enum ECitadelGameMode
 */
export enum ECitadelGameMode {
  /**
   * @generated from protobuf enum value: k_ECitadelGameMode_Invalid = 0;
   */
  k_ECitadelGameMode_Invalid = 0,
  /**
   * @generated from protobuf enum value: k_ECitadelGameMode_Normal = 1;
   */
  k_ECitadelGameMode_Normal = 1,
  /**
   * @generated from protobuf enum value: k_ECitadelGameMode_1v1Test = 2;
   */
  k_ECitadelGameMode_1v1Test = 2,
  /**
   * @generated from protobuf enum value: k_ECitadelGameMode_Sandbox = 3;
   */
  k_ECitadelGameMode_Sandbox = 3,
}
/**
 * @generated from protobuf enum ELobbyServerState
 */
export enum ELobbyServerState {
  /**
   * @generated from protobuf enum value: k_eLobbyServerState_Assign = 0;
   */
  k_eLobbyServerState_Assign = 0,
  /**
   * @generated from protobuf enum value: k_eLobbyServerState_InGame = 1;
   */
  k_eLobbyServerState_InGame = 1,
  /**
   * @generated from protobuf enum value: k_eLobbyServerState_PostMatch = 2;
   */
  k_eLobbyServerState_PostMatch = 2,
  /**
   * @generated from protobuf enum value: k_eLobbyServerState_SignedOut = 3;
   */
  k_eLobbyServerState_SignedOut = 3,
  /**
   * @generated from protobuf enum value: k_eLobbyServerState_Abandoned = 4;
   */
  k_eLobbyServerState_Abandoned = 4,
}
/**
 * @generated from protobuf enum EBannedFeature
 */
export enum EBannedFeature {
  /**
   * @generated from protobuf enum value: k_eBannedFeature_Invalid = 0;
   */
  k_eBannedFeature_Invalid = 0,
  /**
   * @generated from protobuf enum value: k_eBannedFeature_LowPriorityMatchmaking = 1;
   */
  k_eBannedFeature_LowPriorityMatchmaking = 1,
  /**
   * @generated from protobuf enum value: k_eBannedFeature_CommsRestricted = 2;
   */
  k_eBannedFeature_CommsRestricted = 2,
}
/**
 * @generated from protobuf enum EFeatureBanReason
 */
export enum EFeatureBanReason {
  /**
   * @generated from protobuf enum value: k_eFeatureBanReason_Invalid = 0;
   */
  k_eFeatureBanReason_Invalid = 0,
  /**
   * @generated from protobuf enum value: k_eFeatureBanReason_DevCommand = 1;
   */
  k_eFeatureBanReason_DevCommand = 1,
  /**
   * @generated from protobuf enum value: k_eFeatureBanReason_PlayerReports = 2;
   */
  k_eFeatureBanReason_PlayerReports = 2,
  /**
   * @generated from protobuf enum value: k_eFeatureBanReason_MatchAbandons = 3;
   */
  k_eFeatureBanReason_MatchAbandons = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelLobby$Type extends MessageType<CSOCitadelLobby> {
  constructor() {
    super("CSOCitadelLobby", [
      {
        no: 1,
        name: "lobby_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "match_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelMatchMode", ECitadelMatchMode],
      },
      {
        no: 4,
        name: "game_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelGameMode", ECitadelGameMode],
      },
      {
        no: 5,
        name: "compatibility_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "extra_messages",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CExtraMsgBlock,
      },
      {
        no: 7,
        name: "server_steam_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 8,
        name: "server_state",
        kind: "enum",
        opt: true,
        T: () => ["ELobbyServerState", ELobbyServerState],
      },
      {
        no: 9,
        name: "udp_connect_ip",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "udp_connect_port",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "sdr_address",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 13,
        name: "server_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "safe_to_abandon",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOCitadelLobby>): CSOCitadelLobby {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.extraMessages = [];
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelLobby>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelLobby,
  ): CSOCitadelLobby {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 lobby_id */ 1:
          message.lobbyId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 match_id */ 2:
          message.matchId = reader.uint64().toBigInt();
          break;
        case /* optional ECitadelMatchMode match_mode */ 3:
          message.matchMode = reader.int32();
          break;
        case /* optional ECitadelGameMode game_mode */ 4:
          message.gameMode = reader.int32();
          break;
        case /* optional uint32 compatibility_version */ 5:
          message.compatibilityVersion = reader.uint32();
          break;
        case /* repeated CExtraMsgBlock extra_messages */ 6:
          message.extraMessages.push(
            CExtraMsgBlock.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional fixed64 server_steam_id */ 7:
          message.serverSteamId = reader.fixed64().toBigInt();
          break;
        case /* optional ELobbyServerState server_state */ 8:
          message.serverState = reader.int32();
          break;
        case /* optional uint32 udp_connect_ip */ 9:
          message.udpConnectIp = reader.uint32();
          break;
        case /* optional uint32 udp_connect_port */ 10:
          message.udpConnectPort = reader.uint32();
          break;
        case /* optional bytes sdr_address */ 12:
          message.sdrAddress = reader.bytes();
          break;
        case /* optional uint32 server_version */ 13:
          message.serverVersion = reader.uint32();
          break;
        case /* optional bool safe_to_abandon */ 14:
          message.safeToAbandon = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelLobby,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 lobby_id = 1; */
    if (message.lobbyId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.lobbyId);
    /* optional uint64 match_id = 2; */
    if (message.matchId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.matchId);
    /* optional ECitadelMatchMode match_mode = 3; */
    if (message.matchMode !== undefined)
      writer.tag(3, WireType.Varint).int32(message.matchMode);
    /* optional ECitadelGameMode game_mode = 4; */
    if (message.gameMode !== undefined)
      writer.tag(4, WireType.Varint).int32(message.gameMode);
    /* optional uint32 compatibility_version = 5; */
    if (message.compatibilityVersion !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.compatibilityVersion);
    /* repeated CExtraMsgBlock extra_messages = 6; */
    for (let i = 0; i < message.extraMessages.length; i++)
      CExtraMsgBlock.internalBinaryWrite(
        message.extraMessages[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional fixed64 server_steam_id = 7; */
    if (message.serverSteamId !== undefined)
      writer.tag(7, WireType.Bit64).fixed64(message.serverSteamId);
    /* optional ELobbyServerState server_state = 8; */
    if (message.serverState !== undefined)
      writer.tag(8, WireType.Varint).int32(message.serverState);
    /* optional uint32 udp_connect_ip = 9; */
    if (message.udpConnectIp !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.udpConnectIp);
    /* optional uint32 udp_connect_port = 10; */
    if (message.udpConnectPort !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.udpConnectPort);
    /* optional bytes sdr_address = 12; */
    if (message.sdrAddress !== undefined)
      writer.tag(12, WireType.LengthDelimited).bytes(message.sdrAddress);
    /* optional uint32 server_version = 13; */
    if (message.serverVersion !== undefined)
      writer.tag(13, WireType.Varint).uint32(message.serverVersion);
    /* optional bool safe_to_abandon = 14; */
    if (message.safeToAbandon !== undefined)
      writer.tag(14, WireType.Varint).bool(message.safeToAbandon);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelLobby
 */
export const CSOCitadelLobby = new CSOCitadelLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CLobbyData_PostMatchSurvey$Type extends MessageType<CLobbyData_PostMatchSurvey> {
  constructor() {
    super("CLobbyData_PostMatchSurvey", [
      {
        no: 1,
        name: "surveys",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CLobbyData_PostMatchSurvey_PlayerSurvey,
      },
    ]);
  }
  create(
    value?: PartialMessage<CLobbyData_PostMatchSurvey>,
  ): CLobbyData_PostMatchSurvey {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.surveys = [];
    if (value !== undefined)
      reflectionMergePartial<CLobbyData_PostMatchSurvey>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CLobbyData_PostMatchSurvey,
  ): CLobbyData_PostMatchSurvey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CLobbyData_PostMatchSurvey.PlayerSurvey surveys */ 1:
          message.surveys.push(
            CLobbyData_PostMatchSurvey_PlayerSurvey.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CLobbyData_PostMatchSurvey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CLobbyData_PostMatchSurvey.PlayerSurvey surveys = 1; */
    for (let i = 0; i < message.surveys.length; i++)
      CLobbyData_PostMatchSurvey_PlayerSurvey.internalBinaryWrite(
        message.surveys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CLobbyData_PostMatchSurvey
 */
export const CLobbyData_PostMatchSurvey = new CLobbyData_PostMatchSurvey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CLobbyData_PostMatchSurvey_PlayerSurvey$Type extends MessageType<CLobbyData_PostMatchSurvey_PlayerSurvey> {
  constructor() {
    super("CLobbyData_PostMatchSurvey.PlayerSurvey", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "question_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CLobbyData_PostMatchSurvey_PlayerSurvey>,
  ): CLobbyData_PostMatchSurvey_PlayerSurvey {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CLobbyData_PostMatchSurvey_PlayerSurvey>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CLobbyData_PostMatchSurvey_PlayerSurvey,
  ): CLobbyData_PostMatchSurvey_PlayerSurvey {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 question_id */ 2:
          message.questionId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CLobbyData_PostMatchSurvey_PlayerSurvey,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional uint32 question_id = 2; */
    if (message.questionId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.questionId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CLobbyData_PostMatchSurvey.PlayerSurvey
 */
export const CLobbyData_PostMatchSurvey_PlayerSurvey =
  new CLobbyData_PostMatchSurvey_PlayerSurvey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHeroSelectionMatchInfo$Type extends MessageType<CMsgHeroSelectionMatchInfo> {
  constructor() {
    super("CMsgHeroSelectionMatchInfo", [
      {
        no: 1,
        name: "hero_selections",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgHeroSelectionMatchInfo_Hero,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgHeroSelectionMatchInfo>,
  ): CMsgHeroSelectionMatchInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.heroSelections = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgHeroSelectionMatchInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgHeroSelectionMatchInfo,
  ): CMsgHeroSelectionMatchInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgHeroSelectionMatchInfo.Hero hero_selections */ 1:
          message.heroSelections.push(
            CMsgHeroSelectionMatchInfo_Hero.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgHeroSelectionMatchInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgHeroSelectionMatchInfo.Hero hero_selections = 1; */
    for (let i = 0; i < message.heroSelections.length; i++)
      CMsgHeroSelectionMatchInfo_Hero.internalBinaryWrite(
        message.heroSelections[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgHeroSelectionMatchInfo
 */
export const CMsgHeroSelectionMatchInfo = new CMsgHeroSelectionMatchInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgHeroSelectionMatchInfo_Hero$Type extends MessageType<CMsgHeroSelectionMatchInfo_Hero> {
  constructor() {
    super("CMsgHeroSelectionMatchInfo.Hero", [
      {
        no: 1,
        name: "hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "priority",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgHeroSelectionMatchInfo_Hero>,
  ): CMsgHeroSelectionMatchInfo_Hero {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgHeroSelectionMatchInfo_Hero>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgHeroSelectionMatchInfo_Hero,
  ): CMsgHeroSelectionMatchInfo_Hero {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 hero_id */ 1:
          message.heroId = reader.uint32();
          break;
        case /* optional uint32 priority */ 2:
          message.priority = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgHeroSelectionMatchInfo_Hero,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 hero_id = 1; */
    if (message.heroId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.heroId);
    /* optional uint32 priority = 2; */
    if (message.priority !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.priority);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgHeroSelectionMatchInfo.Hero
 */
export const CMsgHeroSelectionMatchInfo_Hero =
  new CMsgHeroSelectionMatchInfo_Hero$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgStartFindingMatchInfo$Type extends MessageType<CMsgStartFindingMatchInfo> {
  constructor() {
    super("CMsgStartFindingMatchInfo", [
      {
        no: 1,
        name: "server_search_key",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "server_command_string",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "match_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelMatchMode", ECitadelMatchMode],
      },
      {
        no: 5,
        name: "game_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelGameMode", ECitadelGameMode],
      },
      {
        no: 6,
        name: "solo_match",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 7,
        name: "bot_difficulty",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelBotDifficulty", ECitadelBotDifficulty],
      },
      {
        no: 8,
        name: "region_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelRegionMode", ECitadelRegionMode],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgStartFindingMatchInfo>,
  ): CMsgStartFindingMatchInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgStartFindingMatchInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgStartFindingMatchInfo,
  ): CMsgStartFindingMatchInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string server_search_key */ 1:
          message.serverSearchKey = reader.string();
          break;
        case /* optional string server_command_string */ 2:
          message.serverCommandString = reader.string();
          break;
        case /* optional ECitadelMatchMode match_mode */ 3:
          message.matchMode = reader.int32();
          break;
        case /* optional ECitadelGameMode game_mode */ 5:
          message.gameMode = reader.int32();
          break;
        case /* optional bool solo_match */ 6:
          message.soloMatch = reader.bool();
          break;
        case /* optional ECitadelBotDifficulty bot_difficulty */ 7:
          message.botDifficulty = reader.int32();
          break;
        case /* optional ECitadelRegionMode region_mode */ 8:
          message.regionMode = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgStartFindingMatchInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string server_search_key = 1; */
    if (message.serverSearchKey !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.serverSearchKey);
    /* optional string server_command_string = 2; */
    if (message.serverCommandString !== undefined)
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.serverCommandString);
    /* optional ECitadelMatchMode match_mode = 3; */
    if (message.matchMode !== undefined)
      writer.tag(3, WireType.Varint).int32(message.matchMode);
    /* optional ECitadelGameMode game_mode = 5; */
    if (message.gameMode !== undefined)
      writer.tag(5, WireType.Varint).int32(message.gameMode);
    /* optional bool solo_match = 6; */
    if (message.soloMatch !== undefined)
      writer.tag(6, WireType.Varint).bool(message.soloMatch);
    /* optional ECitadelBotDifficulty bot_difficulty = 7; */
    if (message.botDifficulty !== undefined)
      writer.tag(7, WireType.Varint).int32(message.botDifficulty);
    /* optional ECitadelRegionMode region_mode = 8; */
    if (message.regionMode !== undefined)
      writer.tag(8, WireType.Varint).int32(message.regionMode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgStartFindingMatchInfo
 */
export const CMsgStartFindingMatchInfo = new CMsgStartFindingMatchInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAnyToGCReportAsserts$Type extends MessageType<CMsgAnyToGCReportAsserts> {
  constructor() {
    super("CMsgAnyToGCReportAsserts", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "asserts",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgAnyToGCReportAsserts_TrackedAssert,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgAnyToGCReportAsserts>,
  ): CMsgAnyToGCReportAsserts {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.asserts = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAnyToGCReportAsserts>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAnyToGCReportAsserts,
  ): CMsgAnyToGCReportAsserts {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 version */ 1:
          message.version = reader.uint32();
          break;
        case /* repeated CMsgAnyToGCReportAsserts.TrackedAssert asserts */ 2:
          message.asserts.push(
            CMsgAnyToGCReportAsserts_TrackedAssert.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAnyToGCReportAsserts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 version = 1; */
    if (message.version !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.version);
    /* repeated CMsgAnyToGCReportAsserts.TrackedAssert asserts = 2; */
    for (let i = 0; i < message.asserts.length; i++)
      CMsgAnyToGCReportAsserts_TrackedAssert.internalBinaryWrite(
        message.asserts[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAnyToGCReportAsserts
 */
export const CMsgAnyToGCReportAsserts = new CMsgAnyToGCReportAsserts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAnyToGCReportAsserts_TrackedAssert$Type extends MessageType<CMsgAnyToGCReportAsserts_TrackedAssert> {
  constructor() {
    super("CMsgAnyToGCReportAsserts.TrackedAssert", [
      {
        no: 1,
        name: "filename",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "line_number",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "sample_msg",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "sample_stack",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "times_fired",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "function_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: "condition",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "total_times_fired",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgAnyToGCReportAsserts_TrackedAssert>,
  ): CMsgAnyToGCReportAsserts_TrackedAssert {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgAnyToGCReportAsserts_TrackedAssert>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAnyToGCReportAsserts_TrackedAssert,
  ): CMsgAnyToGCReportAsserts_TrackedAssert {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string filename */ 1:
          message.filename = reader.string();
          break;
        case /* optional uint32 line_number */ 2:
          message.lineNumber = reader.uint32();
          break;
        case /* optional string sample_msg */ 3:
          message.sampleMsg = reader.string();
          break;
        case /* optional string sample_stack */ 4:
          message.sampleStack = reader.string();
          break;
        case /* optional uint32 times_fired */ 5:
          message.timesFired = reader.uint32();
          break;
        case /* optional string function_name */ 6:
          message.functionName = reader.string();
          break;
        case /* optional string condition */ 7:
          message.condition = reader.string();
          break;
        case /* optional uint32 total_times_fired */ 8:
          message.totalTimesFired = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAnyToGCReportAsserts_TrackedAssert,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string filename = 1; */
    if (message.filename !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.filename);
    /* optional uint32 line_number = 2; */
    if (message.lineNumber !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.lineNumber);
    /* optional string sample_msg = 3; */
    if (message.sampleMsg !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.sampleMsg);
    /* optional string sample_stack = 4; */
    if (message.sampleStack !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.sampleStack);
    /* optional uint32 times_fired = 5; */
    if (message.timesFired !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.timesFired);
    /* optional string function_name = 6; */
    if (message.functionName !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.functionName);
    /* optional string condition = 7; */
    if (message.condition !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.condition);
    /* optional uint32 total_times_fired = 8; */
    if (message.totalTimesFired !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.totalTimesFired);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAnyToGCReportAsserts.TrackedAssert
 */
export const CMsgAnyToGCReportAsserts_TrackedAssert =
  new CMsgAnyToGCReportAsserts_TrackedAssert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAnyToGCReportAssertsResponse$Type extends MessageType<CMsgAnyToGCReportAssertsResponse> {
  constructor() {
    super("CMsgAnyToGCReportAssertsResponse", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgAnyToGCReportAssertsResponse>,
  ): CMsgAnyToGCReportAssertsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgAnyToGCReportAssertsResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAnyToGCReportAssertsResponse,
  ): CMsgAnyToGCReportAssertsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool success */ 1:
          message.success = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAnyToGCReportAssertsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool success = 1; */
    if (message.success !== undefined)
      writer.tag(1, WireType.Varint).bool(message.success);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAnyToGCReportAssertsResponse
 */
export const CMsgAnyToGCReportAssertsResponse =
  new CMsgAnyToGCReportAssertsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgRegionPingTimesClient$Type extends MessageType<CMsgRegionPingTimesClient> {
  constructor() {
    super("CMsgRegionPingTimesClient", [
      {
        no: 1,
        name: "data_center_codes",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 2,
        name: "ping_times",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgRegionPingTimesClient>,
  ): CMsgRegionPingTimesClient {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.dataCenterCodes = [];
    message.pingTimes = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgRegionPingTimesClient>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgRegionPingTimesClient,
  ): CMsgRegionPingTimesClient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated fixed32 data_center_codes = 1 [packed = true];*/ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dataCenterCodes.push(reader.fixed32());
          else message.dataCenterCodes.push(reader.fixed32());
          break;
        case /* repeated uint32 ping_times = 2 [packed = true];*/ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.pingTimes.push(reader.uint32());
          else message.pingTimes.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgRegionPingTimesClient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated fixed32 data_center_codes = 1 [packed = true]; */
    if (message.dataCenterCodes.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.dataCenterCodes.length; i++)
        writer.fixed32(message.dataCenterCodes[i]);
      writer.join();
    }
    /* repeated uint32 ping_times = 2 [packed = true]; */
    if (message.pingTimes.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.pingTimes.length; i++)
        writer.uint32(message.pingTimes[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgRegionPingTimesClient
 */
export const CMsgRegionPingTimesClient = new CMsgRegionPingTimesClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty$Type extends MessageType<CSOCitadelParty> {
  constructor() {
    super("CSOCitadelParty", [
      {
        no: 1,
        name: "party_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "members",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOCitadelParty_Member,
      },
      {
        no: 3,
        name: "invites",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOCitadelParty_Invite,
      },
      {
        no: 4,
        name: "dev_server_command",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "left_members",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOCitadelParty_LeftMember,
      },
      {
        no: 6,
        name: "join_code",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: "bot_difficulty",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelBotDifficulty", ECitadelBotDifficulty],
      },
      {
        no: 9,
        name: "match_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelMatchMode", ECitadelMatchMode],
      },
      {
        no: 10,
        name: "game_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelGameMode", ECitadelGameMode],
      },
      {
        no: 11,
        name: "match_making_start_time",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "server_search_key",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 13,
        name: "is_high_skill_range_party",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 14,
        name: "chat_mode",
        kind: "enum",
        opt: true,
        T: () => ["CSOCitadelParty.EChatMode", CSOCitadelParty_EChatMode],
      },
      {
        no: 15,
        name: "region_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelRegionMode", ECitadelRegionMode],
      },
      {
        no: 16,
        name: "is_private_lobby",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 17,
        name: "private_lobby_settings",
        kind: "message",
        T: () => CSOCitadelParty_PrivateLobbySettings,
      },
    ]);
  }
  create(value?: PartialMessage<CSOCitadelParty>): CSOCitadelParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.members = [];
    message.invites = [];
    message.leftMembers = [];
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty,
  ): CSOCitadelParty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 party_id */ 1:
          message.partyId = reader.uint64().toBigInt();
          break;
        case /* repeated CSOCitadelParty.Member members */ 2:
          message.members.push(
            CSOCitadelParty_Member.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CSOCitadelParty.Invite invites */ 3:
          message.invites.push(
            CSOCitadelParty_Invite.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional string dev_server_command */ 4:
          message.devServerCommand = reader.string();
          break;
        case /* repeated CSOCitadelParty.LeftMember left_members */ 5:
          message.leftMembers.push(
            CSOCitadelParty_LeftMember.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint64 join_code */ 6:
          message.joinCode = reader.uint64().toBigInt();
          break;
        case /* optional ECitadelBotDifficulty bot_difficulty */ 7:
          message.botDifficulty = reader.int32();
          break;
        case /* optional ECitadelMatchMode match_mode */ 9:
          message.matchMode = reader.int32();
          break;
        case /* optional ECitadelGameMode game_mode */ 10:
          message.gameMode = reader.int32();
          break;
        case /* optional uint32 match_making_start_time */ 11:
          message.matchMakingStartTime = reader.uint32();
          break;
        case /* optional string server_search_key */ 12:
          message.serverSearchKey = reader.string();
          break;
        case /* optional bool is_high_skill_range_party */ 13:
          message.isHighSkillRangeParty = reader.bool();
          break;
        case /* optional CSOCitadelParty.EChatMode chat_mode */ 14:
          message.chatMode = reader.int32();
          break;
        case /* optional ECitadelRegionMode region_mode */ 15:
          message.regionMode = reader.int32();
          break;
        case /* optional bool is_private_lobby */ 16:
          message.isPrivateLobby = reader.bool();
          break;
        case /* optional CSOCitadelParty.PrivateLobbySettings private_lobby_settings */ 17:
          message.privateLobbySettings =
            CSOCitadelParty_PrivateLobbySettings.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.privateLobbySettings,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 party_id = 1; */
    if (message.partyId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.partyId);
    /* repeated CSOCitadelParty.Member members = 2; */
    for (let i = 0; i < message.members.length; i++)
      CSOCitadelParty_Member.internalBinaryWrite(
        message.members[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CSOCitadelParty.Invite invites = 3; */
    for (let i = 0; i < message.invites.length; i++)
      CSOCitadelParty_Invite.internalBinaryWrite(
        message.invites[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional string dev_server_command = 4; */
    if (message.devServerCommand !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.devServerCommand);
    /* repeated CSOCitadelParty.LeftMember left_members = 5; */
    for (let i = 0; i < message.leftMembers.length; i++)
      CSOCitadelParty_LeftMember.internalBinaryWrite(
        message.leftMembers[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint64 join_code = 6; */
    if (message.joinCode !== undefined)
      writer.tag(6, WireType.Varint).uint64(message.joinCode);
    /* optional ECitadelBotDifficulty bot_difficulty = 7; */
    if (message.botDifficulty !== undefined)
      writer.tag(7, WireType.Varint).int32(message.botDifficulty);
    /* optional ECitadelMatchMode match_mode = 9; */
    if (message.matchMode !== undefined)
      writer.tag(9, WireType.Varint).int32(message.matchMode);
    /* optional ECitadelGameMode game_mode = 10; */
    if (message.gameMode !== undefined)
      writer.tag(10, WireType.Varint).int32(message.gameMode);
    /* optional uint32 match_making_start_time = 11; */
    if (message.matchMakingStartTime !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.matchMakingStartTime);
    /* optional string server_search_key = 12; */
    if (message.serverSearchKey !== undefined)
      writer.tag(12, WireType.LengthDelimited).string(message.serverSearchKey);
    /* optional bool is_high_skill_range_party = 13; */
    if (message.isHighSkillRangeParty !== undefined)
      writer.tag(13, WireType.Varint).bool(message.isHighSkillRangeParty);
    /* optional CSOCitadelParty.EChatMode chat_mode = 14; */
    if (message.chatMode !== undefined)
      writer.tag(14, WireType.Varint).int32(message.chatMode);
    /* optional ECitadelRegionMode region_mode = 15; */
    if (message.regionMode !== undefined)
      writer.tag(15, WireType.Varint).int32(message.regionMode);
    /* optional bool is_private_lobby = 16; */
    if (message.isPrivateLobby !== undefined)
      writer.tag(16, WireType.Varint).bool(message.isPrivateLobby);
    /* optional CSOCitadelParty.PrivateLobbySettings private_lobby_settings = 17; */
    if (message.privateLobbySettings)
      CSOCitadelParty_PrivateLobbySettings.internalBinaryWrite(
        message.privateLobbySettings,
        writer.tag(17, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty
 */
export const CSOCitadelParty = new CSOCitadelParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty_PrivateLobbySlot$Type extends MessageType<CSOCitadelParty_PrivateLobbySlot> {
  constructor() {
    super("CSOCitadelParty.PrivateLobbySlot", [
      {
        no: 1,
        name: "slot_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "player_account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOCitadelParty_PrivateLobbySlot>,
  ): CSOCitadelParty_PrivateLobbySlot {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty_PrivateLobbySlot>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty_PrivateLobbySlot,
  ): CSOCitadelParty_PrivateLobbySlot {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 slot_id */ 1:
          message.slotId = reader.uint32();
          break;
        case /* optional uint32 player_account_id */ 2:
          message.playerAccountId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty_PrivateLobbySlot,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 slot_id = 1; */
    if (message.slotId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.slotId);
    /* optional uint32 player_account_id = 2; */
    if (message.playerAccountId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.playerAccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty.PrivateLobbySlot
 */
export const CSOCitadelParty_PrivateLobbySlot =
  new CSOCitadelParty_PrivateLobbySlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty_PrivateLobbySettings$Type extends MessageType<CSOCitadelParty_PrivateLobbySettings> {
  constructor() {
    super("CSOCitadelParty.PrivateLobbySettings", [
      {
        no: 1,
        name: "min_roster_size",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "match_slots",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOCitadelParty_PrivateLobbySlot,
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOCitadelParty_PrivateLobbySettings>,
  ): CSOCitadelParty_PrivateLobbySettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.matchSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty_PrivateLobbySettings>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty_PrivateLobbySettings,
  ): CSOCitadelParty_PrivateLobbySettings {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 min_roster_size */ 1:
          message.minRosterSize = reader.uint32();
          break;
        case /* repeated CSOCitadelParty.PrivateLobbySlot match_slots */ 2:
          message.matchSlots.push(
            CSOCitadelParty_PrivateLobbySlot.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty_PrivateLobbySettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 min_roster_size = 1; */
    if (message.minRosterSize !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.minRosterSize);
    /* repeated CSOCitadelParty.PrivateLobbySlot match_slots = 2; */
    for (let i = 0; i < message.matchSlots.length; i++)
      CSOCitadelParty_PrivateLobbySlot.internalBinaryWrite(
        message.matchSlots[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty.PrivateLobbySettings
 */
export const CSOCitadelParty_PrivateLobbySettings =
  new CSOCitadelParty_PrivateLobbySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty_Member$Type extends MessageType<CSOCitadelParty_Member> {
  constructor() {
    super("CSOCitadelParty.Member", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "persona_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "rights_flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "is_ready",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "player_type",
        kind: "enum",
        opt: true,
        T: () => ["CSOCitadelParty.EPlayerType", CSOCitadelParty_EPlayerType],
      },
      {
        no: 6,
        name: "compatibility_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "platform",
        kind: "enum",
        opt: true,
        T: () => ["EGCPlatform", EGCPlatform],
      },
      {
        no: 8,
        name: "team",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "hero_roster",
        kind: "message",
        T: () => CMsgHeroSelectionMatchInfo,
      },
      {
        no: 10,
        name: "permissions",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 11,
        name: "new_player_progress",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 12,
        name: "owned_heroes",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOCitadelParty_Member>,
  ): CSOCitadelParty_Member {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ownedHeroes = [];
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty_Member>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty_Member,
  ): CSOCitadelParty_Member {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional string persona_name */ 2:
          message.personaName = reader.string();
          break;
        case /* optional uint32 rights_flags */ 3:
          message.rightsFlags = reader.uint32();
          break;
        case /* optional bool is_ready */ 4:
          message.isReady = reader.bool();
          break;
        case /* optional CSOCitadelParty.EPlayerType player_type */ 5:
          message.playerType = reader.int32();
          break;
        case /* optional uint32 compatibility_version */ 6:
          message.compatibilityVersion = reader.uint32();
          break;
        case /* optional EGCPlatform platform */ 7:
          message.platform = reader.int32();
          break;
        case /* optional uint32 team */ 8:
          message.team = reader.uint32();
          break;
        case /* optional CMsgHeroSelectionMatchInfo hero_roster */ 9:
          message.heroRoster = CMsgHeroSelectionMatchInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.heroRoster,
          );
          break;
        case /* optional uint64 permissions */ 10:
          message.permissions = reader.uint64().toBigInt();
          break;
        case /* optional uint64 new_player_progress */ 11:
          message.newPlayerProgress = reader.uint64().toBigInt();
          break;
        case /* repeated uint32 owned_heroes = 12 [packed = true];*/ 12:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ownedHeroes.push(reader.uint32());
          else message.ownedHeroes.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty_Member,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional string persona_name = 2; */
    if (message.personaName !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.personaName);
    /* optional uint32 rights_flags = 3; */
    if (message.rightsFlags !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.rightsFlags);
    /* optional bool is_ready = 4; */
    if (message.isReady !== undefined)
      writer.tag(4, WireType.Varint).bool(message.isReady);
    /* optional CSOCitadelParty.EPlayerType player_type = 5; */
    if (message.playerType !== undefined)
      writer.tag(5, WireType.Varint).int32(message.playerType);
    /* optional uint32 compatibility_version = 6; */
    if (message.compatibilityVersion !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.compatibilityVersion);
    /* optional EGCPlatform platform = 7; */
    if (message.platform !== undefined)
      writer.tag(7, WireType.Varint).int32(message.platform);
    /* optional uint32 team = 8; */
    if (message.team !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.team);
    /* optional CMsgHeroSelectionMatchInfo hero_roster = 9; */
    if (message.heroRoster)
      CMsgHeroSelectionMatchInfo.internalBinaryWrite(
        message.heroRoster,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint64 permissions = 10; */
    if (message.permissions !== undefined)
      writer.tag(10, WireType.Varint).uint64(message.permissions);
    /* optional uint64 new_player_progress = 11; */
    if (message.newPlayerProgress !== undefined)
      writer.tag(11, WireType.Varint).uint64(message.newPlayerProgress);
    /* repeated uint32 owned_heroes = 12 [packed = true]; */
    if (message.ownedHeroes.length) {
      writer.tag(12, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.ownedHeroes.length; i++)
        writer.uint32(message.ownedHeroes[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty.Member
 */
export const CSOCitadelParty_Member = new CSOCitadelParty_Member$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty_LeftMember$Type extends MessageType<CSOCitadelParty_LeftMember> {
  constructor() {
    super("CSOCitadelParty.LeftMember", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "rights_flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "player_type",
        kind: "enum",
        opt: true,
        T: () => ["CSOCitadelParty.EPlayerType", CSOCitadelParty_EPlayerType],
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOCitadelParty_LeftMember>,
  ): CSOCitadelParty_LeftMember {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty_LeftMember>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty_LeftMember,
  ): CSOCitadelParty_LeftMember {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 rights_flags */ 2:
          message.rightsFlags = reader.uint32();
          break;
        case /* optional CSOCitadelParty.EPlayerType player_type */ 3:
          message.playerType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty_LeftMember,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional uint32 rights_flags = 2; */
    if (message.rightsFlags !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.rightsFlags);
    /* optional CSOCitadelParty.EPlayerType player_type = 3; */
    if (message.playerType !== undefined)
      writer.tag(3, WireType.Varint).int32(message.playerType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty.LeftMember
 */
export const CSOCitadelParty_LeftMember = new CSOCitadelParty_LeftMember$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOCitadelParty_Invite$Type extends MessageType<CSOCitadelParty_Invite> {
  constructor() {
    super("CSOCitadelParty.Invite", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "persona_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "invited_by",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOCitadelParty_Invite>,
  ): CSOCitadelParty_Invite {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOCitadelParty_Invite>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOCitadelParty_Invite,
  ): CSOCitadelParty_Invite {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional string persona_name */ 2:
          message.personaName = reader.string();
          break;
        case /* optional uint32 invited_by */ 3:
          message.invitedBy = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOCitadelParty_Invite,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional string persona_name = 2; */
    if (message.personaName !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.personaName);
    /* optional uint32 invited_by = 3; */
    if (message.invitedBy !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.invitedBy);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOCitadelParty.Invite
 */
export const CSOCitadelParty_Invite = new CSOCitadelParty_Invite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerPathsData$Type extends MessageType<CMsgMatchPlayerPathsData> {
  constructor() {
    super("CMsgMatchPlayerPathsData", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "interval_s",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "x_resolution",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "y_resolution",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "paths",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchPlayerPathsData_Path,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerPathsData>,
  ): CMsgMatchPlayerPathsData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.paths = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerPathsData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerPathsData,
  ): CMsgMatchPlayerPathsData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 version */ 1:
          message.version = reader.uint32();
          break;
        case /* optional float interval_s */ 2:
          message.intervalS = reader.float();
          break;
        case /* optional uint32 x_resolution */ 3:
          message.xResolution = reader.uint32();
          break;
        case /* optional uint32 y_resolution */ 4:
          message.yResolution = reader.uint32();
          break;
        case /* repeated CMsgMatchPlayerPathsData.Path paths */ 5:
          message.paths.push(
            CMsgMatchPlayerPathsData_Path.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerPathsData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 version = 1; */
    if (message.version !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.version);
    /* optional float interval_s = 2; */
    if (message.intervalS !== undefined)
      writer.tag(2, WireType.Bit32).float(message.intervalS);
    /* optional uint32 x_resolution = 3; */
    if (message.xResolution !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.xResolution);
    /* optional uint32 y_resolution = 4; */
    if (message.yResolution !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.yResolution);
    /* repeated CMsgMatchPlayerPathsData.Path paths = 5; */
    for (let i = 0; i < message.paths.length; i++)
      CMsgMatchPlayerPathsData_Path.internalBinaryWrite(
        message.paths[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerPathsData
 */
export const CMsgMatchPlayerPathsData = new CMsgMatchPlayerPathsData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerPathsData_Path$Type extends MessageType<CMsgMatchPlayerPathsData_Path> {
  constructor() {
    super("CMsgMatchPlayerPathsData.Path", [
      {
        no: 1,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "x_min",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "y_min",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "x_max",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "y_max",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "x_pos",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "y_pos",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "alive",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 9,
        name: "health",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerPathsData_Path>,
  ): CMsgMatchPlayerPathsData_Path {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.xPos = [];
    message.yPos = [];
    message.alive = [];
    message.health = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerPathsData_Path>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerPathsData_Path,
  ): CMsgMatchPlayerPathsData_Path {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 player_slot */ 1:
          message.playerSlot = reader.uint32();
          break;
        case /* optional float x_min */ 2:
          message.xMin = reader.float();
          break;
        case /* optional float y_min */ 3:
          message.yMin = reader.float();
          break;
        case /* optional float x_max */ 4:
          message.xMax = reader.float();
          break;
        case /* optional float y_max */ 5:
          message.yMax = reader.float();
          break;
        case /* repeated uint32 x_pos = 6 [packed = true];*/ 6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.xPos.push(reader.uint32());
          else message.xPos.push(reader.uint32());
          break;
        case /* repeated uint32 y_pos = 7 [packed = true];*/ 7:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.yPos.push(reader.uint32());
          else message.yPos.push(reader.uint32());
          break;
        case /* repeated bool alive = 8 [packed = true];*/ 8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.alive.push(reader.bool());
          else message.alive.push(reader.bool());
          break;
        case /* repeated uint32 health = 9 [packed = true];*/ 9:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.health.push(reader.uint32());
          else message.health.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerPathsData_Path,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 player_slot = 1; */
    if (message.playerSlot !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.playerSlot);
    /* optional float x_min = 2; */
    if (message.xMin !== undefined)
      writer.tag(2, WireType.Bit32).float(message.xMin);
    /* optional float y_min = 3; */
    if (message.yMin !== undefined)
      writer.tag(3, WireType.Bit32).float(message.yMin);
    /* optional float x_max = 4; */
    if (message.xMax !== undefined)
      writer.tag(4, WireType.Bit32).float(message.xMax);
    /* optional float y_max = 5; */
    if (message.yMax !== undefined)
      writer.tag(5, WireType.Bit32).float(message.yMax);
    /* repeated uint32 x_pos = 6 [packed = true]; */
    if (message.xPos.length) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.xPos.length; i++)
        writer.uint32(message.xPos[i]);
      writer.join();
    }
    /* repeated uint32 y_pos = 7 [packed = true]; */
    if (message.yPos.length) {
      writer.tag(7, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.yPos.length; i++)
        writer.uint32(message.yPos[i]);
      writer.join();
    }
    /* repeated bool alive = 8 [packed = true]; */
    if (message.alive.length) {
      writer.tag(8, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.alive.length; i++)
        writer.bool(message.alive[i]);
      writer.join();
    }
    /* repeated uint32 health = 9 [packed = true]; */
    if (message.health.length) {
      writer.tag(9, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.health.length; i++)
        writer.uint32(message.health[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerPathsData.Path
 */
export const CMsgMatchPlayerPathsData_Path =
  new CMsgMatchPlayerPathsData_Path$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerDamageMatrix$Type extends MessageType<CMsgMatchPlayerDamageMatrix> {
  constructor() {
    super("CMsgMatchPlayerDamageMatrix", [
      {
        no: 1,
        name: "damage_dealers",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchPlayerDamageMatrix_DamageDealer,
      },
      {
        no: 2,
        name: "sample_time_s",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "source_details",
        kind: "message",
        T: () => CMsgMatchPlayerDamageMatrix_SourceDetails,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerDamageMatrix>,
  ): CMsgMatchPlayerDamageMatrix {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.damageDealers = [];
    message.sampleTimeS = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerDamageMatrix>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerDamageMatrix,
  ): CMsgMatchPlayerDamageMatrix {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgMatchPlayerDamageMatrix.DamageDealer damage_dealers */ 1:
          message.damageDealers.push(
            CMsgMatchPlayerDamageMatrix_DamageDealer.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated uint32 sample_time_s = 2 [packed = true];*/ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.sampleTimeS.push(reader.uint32());
          else message.sampleTimeS.push(reader.uint32());
          break;
        case /* optional CMsgMatchPlayerDamageMatrix.SourceDetails source_details */ 3:
          message.sourceDetails =
            CMsgMatchPlayerDamageMatrix_SourceDetails.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.sourceDetails,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerDamageMatrix,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgMatchPlayerDamageMatrix.DamageDealer damage_dealers = 1; */
    for (let i = 0; i < message.damageDealers.length; i++)
      CMsgMatchPlayerDamageMatrix_DamageDealer.internalBinaryWrite(
        message.damageDealers[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated uint32 sample_time_s = 2 [packed = true]; */
    if (message.sampleTimeS.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.sampleTimeS.length; i++)
        writer.uint32(message.sampleTimeS[i]);
      writer.join();
    }
    /* optional CMsgMatchPlayerDamageMatrix.SourceDetails source_details = 3; */
    if (message.sourceDetails)
      CMsgMatchPlayerDamageMatrix_SourceDetails.internalBinaryWrite(
        message.sourceDetails,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerDamageMatrix
 */
export const CMsgMatchPlayerDamageMatrix =
  new CMsgMatchPlayerDamageMatrix$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerDamageMatrix_DamageToPlayer$Type extends MessageType<CMsgMatchPlayerDamageMatrix_DamageToPlayer> {
  constructor() {
    super("CMsgMatchPlayerDamageMatrix.DamageToPlayer", [
      {
        no: 1,
        name: "target_player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "damage",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerDamageMatrix_DamageToPlayer>,
  ): CMsgMatchPlayerDamageMatrix_DamageToPlayer {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.damage = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerDamageMatrix_DamageToPlayer>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerDamageMatrix_DamageToPlayer,
  ): CMsgMatchPlayerDamageMatrix_DamageToPlayer {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 target_player_slot */ 1:
          message.targetPlayerSlot = reader.uint32();
          break;
        case /* repeated uint32 damage = 2 [packed = true];*/ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.damage.push(reader.uint32());
          else message.damage.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerDamageMatrix_DamageToPlayer,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 target_player_slot = 1; */
    if (message.targetPlayerSlot !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.targetPlayerSlot);
    /* repeated uint32 damage = 2 [packed = true]; */
    if (message.damage.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.damage.length; i++)
        writer.uint32(message.damage[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerDamageMatrix.DamageToPlayer
 */
export const CMsgMatchPlayerDamageMatrix_DamageToPlayer =
  new CMsgMatchPlayerDamageMatrix_DamageToPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerDamageMatrix_DamageSource$Type extends MessageType<CMsgMatchPlayerDamageMatrix_DamageSource> {
  constructor() {
    super("CMsgMatchPlayerDamageMatrix.DamageSource", [
      {
        no: 2,
        name: "damage_to_players",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchPlayerDamageMatrix_DamageToPlayer,
      },
      {
        no: 4,
        name: "source_details_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerDamageMatrix_DamageSource>,
  ): CMsgMatchPlayerDamageMatrix_DamageSource {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.damageToPlayers = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerDamageMatrix_DamageSource>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerDamageMatrix_DamageSource,
  ): CMsgMatchPlayerDamageMatrix_DamageSource {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgMatchPlayerDamageMatrix.DamageToPlayer damage_to_players */ 2:
          message.damageToPlayers.push(
            CMsgMatchPlayerDamageMatrix_DamageToPlayer.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint32 source_details_index */ 4:
          message.sourceDetailsIndex = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerDamageMatrix_DamageSource,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgMatchPlayerDamageMatrix.DamageToPlayer damage_to_players = 2; */
    for (let i = 0; i < message.damageToPlayers.length; i++)
      CMsgMatchPlayerDamageMatrix_DamageToPlayer.internalBinaryWrite(
        message.damageToPlayers[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 source_details_index = 4; */
    if (message.sourceDetailsIndex !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.sourceDetailsIndex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerDamageMatrix.DamageSource
 */
export const CMsgMatchPlayerDamageMatrix_DamageSource =
  new CMsgMatchPlayerDamageMatrix_DamageSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerDamageMatrix_DamageDealer$Type extends MessageType<CMsgMatchPlayerDamageMatrix_DamageDealer> {
  constructor() {
    super("CMsgMatchPlayerDamageMatrix.DamageDealer", [
      {
        no: 1,
        name: "dealer_player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "damage_sources",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchPlayerDamageMatrix_DamageSource,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerDamageMatrix_DamageDealer>,
  ): CMsgMatchPlayerDamageMatrix_DamageDealer {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.damageSources = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerDamageMatrix_DamageDealer>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerDamageMatrix_DamageDealer,
  ): CMsgMatchPlayerDamageMatrix_DamageDealer {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 dealer_player_slot */ 1:
          message.dealerPlayerSlot = reader.uint32();
          break;
        case /* repeated CMsgMatchPlayerDamageMatrix.DamageSource damage_sources */ 2:
          message.damageSources.push(
            CMsgMatchPlayerDamageMatrix_DamageSource.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerDamageMatrix_DamageDealer,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 dealer_player_slot = 1; */
    if (message.dealerPlayerSlot !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.dealerPlayerSlot);
    /* repeated CMsgMatchPlayerDamageMatrix.DamageSource damage_sources = 2; */
    for (let i = 0; i < message.damageSources.length; i++)
      CMsgMatchPlayerDamageMatrix_DamageSource.internalBinaryWrite(
        message.damageSources[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerDamageMatrix.DamageDealer
 */
export const CMsgMatchPlayerDamageMatrix_DamageDealer =
  new CMsgMatchPlayerDamageMatrix_DamageDealer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchPlayerDamageMatrix_SourceDetails$Type extends MessageType<CMsgMatchPlayerDamageMatrix_SourceDetails> {
  constructor() {
    super("CMsgMatchPlayerDamageMatrix.SourceDetails", [
      {
        no: 1,
        name: "stat_type",
        kind: "enum",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          "CMsgMatchPlayerDamageMatrix.EStatType",
          CMsgMatchPlayerDamageMatrix_EStatType,
        ],
      },
      {
        no: 2,
        name: "source_name",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchPlayerDamageMatrix_SourceDetails>,
  ): CMsgMatchPlayerDamageMatrix_SourceDetails {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.statType = [];
    message.sourceName = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchPlayerDamageMatrix_SourceDetails>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchPlayerDamageMatrix_SourceDetails,
  ): CMsgMatchPlayerDamageMatrix_SourceDetails {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgMatchPlayerDamageMatrix.EStatType stat_type = 1 [packed = true];*/ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.statType.push(reader.int32());
          else message.statType.push(reader.int32());
          break;
        case /* repeated string source_name */ 2:
          message.sourceName.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchPlayerDamageMatrix_SourceDetails,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgMatchPlayerDamageMatrix.EStatType stat_type = 1 [packed = true]; */
    if (message.statType.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.statType.length; i++)
        writer.int32(message.statType[i]);
      writer.join();
    }
    /* repeated string source_name = 2; */
    for (let i = 0; i < message.sourceName.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.sourceName[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchPlayerDamageMatrix.SourceDetails
 */
export const CMsgMatchPlayerDamageMatrix_SourceDetails =
  new CMsgMatchPlayerDamageMatrix_SourceDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents$Type extends MessageType<CMsgMatchMetaDataContents> {
  constructor() {
    super("CMsgMatchMetaDataContents", [
      {
        no: 2,
        name: "match_info",
        kind: "message",
        T: () => CMsgMatchMetaDataContents_MatchInfo,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents>,
  ): CMsgMatchMetaDataContents {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents,
  ): CMsgMatchMetaDataContents {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgMatchMetaDataContents.MatchInfo match_info */ 2:
          message.matchInfo =
            CMsgMatchMetaDataContents_MatchInfo.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.matchInfo,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgMatchMetaDataContents.MatchInfo match_info = 2; */
    if (message.matchInfo)
      CMsgMatchMetaDataContents_MatchInfo.internalBinaryWrite(
        message.matchInfo,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents
 */
export const CMsgMatchMetaDataContents = new CMsgMatchMetaDataContents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Position$Type extends MessageType<CMsgMatchMetaDataContents_Position> {
  constructor() {
    super("CMsgMatchMetaDataContents.Position", [
      {
        no: 1,
        name: "x",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: "y",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "z",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Position>,
  ): CMsgMatchMetaDataContents_Position {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Position>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Position,
  ): CMsgMatchMetaDataContents_Position {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float x */ 1:
          message.x = reader.float();
          break;
        case /* optional float y */ 2:
          message.y = reader.float();
          break;
        case /* optional float z */ 3:
          message.z = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Position,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float x = 1; */
    if (message.x !== undefined) writer.tag(1, WireType.Bit32).float(message.x);
    /* optional float y = 2; */
    if (message.y !== undefined) writer.tag(2, WireType.Bit32).float(message.y);
    /* optional float z = 3; */
    if (message.z !== undefined) writer.tag(3, WireType.Bit32).float(message.z);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Position
 */
export const CMsgMatchMetaDataContents_Position =
  new CMsgMatchMetaDataContents_Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Deaths$Type extends MessageType<CMsgMatchMetaDataContents_Deaths> {
  constructor() {
    super("CMsgMatchMetaDataContents.Deaths", [
      {
        no: 1,
        name: "game_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "killer_player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "death_pos",
        kind: "message",
        T: () => CMsgMatchMetaDataContents_Position,
      },
      {
        no: 11,
        name: "killer_pos",
        kind: "message",
        T: () => CMsgMatchMetaDataContents_Position,
      },
      {
        no: 12,
        name: "death_duration_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Deaths>,
  ): CMsgMatchMetaDataContents_Deaths {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Deaths>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Deaths,
  ): CMsgMatchMetaDataContents_Deaths {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 game_time_s */ 1:
          message.gameTimeS = reader.uint32();
          break;
        case /* optional uint32 killer_player_slot */ 9:
          message.killerPlayerSlot = reader.uint32();
          break;
        case /* optional CMsgMatchMetaDataContents.Position death_pos */ 10:
          message.deathPos =
            CMsgMatchMetaDataContents_Position.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.deathPos,
            );
          break;
        case /* optional CMsgMatchMetaDataContents.Position killer_pos */ 11:
          message.killerPos =
            CMsgMatchMetaDataContents_Position.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.killerPos,
            );
          break;
        case /* optional uint32 death_duration_s */ 12:
          message.deathDurationS = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Deaths,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 game_time_s = 1; */
    if (message.gameTimeS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.gameTimeS);
    /* optional uint32 killer_player_slot = 9; */
    if (message.killerPlayerSlot !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.killerPlayerSlot);
    /* optional CMsgMatchMetaDataContents.Position death_pos = 10; */
    if (message.deathPos)
      CMsgMatchMetaDataContents_Position.internalBinaryWrite(
        message.deathPos,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgMatchMetaDataContents.Position killer_pos = 11; */
    if (message.killerPos)
      CMsgMatchMetaDataContents_Position.internalBinaryWrite(
        message.killerPos,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 death_duration_s = 12; */
    if (message.deathDurationS !== undefined)
      writer.tag(12, WireType.Varint).uint32(message.deathDurationS);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Deaths
 */
export const CMsgMatchMetaDataContents_Deaths =
  new CMsgMatchMetaDataContents_Deaths$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Items$Type extends MessageType<CMsgMatchMetaDataContents_Items> {
  constructor() {
    super("CMsgMatchMetaDataContents.Items", [
      {
        no: 1,
        name: "game_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "item_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "upgrade_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "sold_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "imbued_ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Items>,
  ): CMsgMatchMetaDataContents_Items {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Items>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Items,
  ): CMsgMatchMetaDataContents_Items {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 game_time_s */ 1:
          message.gameTimeS = reader.uint32();
          break;
        case /* optional uint32 item_id */ 2:
          message.itemId = reader.uint32();
          break;
        case /* optional uint32 upgrade_id */ 3:
          message.upgradeId = reader.uint32();
          break;
        case /* optional uint32 sold_time_s */ 4:
          message.soldTimeS = reader.uint32();
          break;
        case /* optional uint32 flags */ 5:
          message.flags = reader.uint32();
          break;
        case /* optional uint32 imbued_ability_id */ 6:
          message.imbuedAbilityId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Items,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 game_time_s = 1; */
    if (message.gameTimeS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.gameTimeS);
    /* optional uint32 item_id = 2; */
    if (message.itemId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.itemId);
    /* optional uint32 upgrade_id = 3; */
    if (message.upgradeId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.upgradeId);
    /* optional uint32 sold_time_s = 4; */
    if (message.soldTimeS !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.soldTimeS);
    /* optional uint32 flags = 5; */
    if (message.flags !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.flags);
    /* optional uint32 imbued_ability_id = 6; */
    if (message.imbuedAbilityId !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.imbuedAbilityId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Items
 */
export const CMsgMatchMetaDataContents_Items =
  new CMsgMatchMetaDataContents_Items$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Ping$Type extends MessageType<CMsgMatchMetaDataContents_Ping> {
  constructor() {
    super("CMsgMatchMetaDataContents.Ping", [
      {
        no: 1,
        name: "ping_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "ping_data",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "game_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Ping>,
  ): CMsgMatchMetaDataContents_Ping {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Ping>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Ping,
  ): CMsgMatchMetaDataContents_Ping {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 ping_type */ 1:
          message.pingType = reader.uint32();
          break;
        case /* optional uint32 ping_data */ 2:
          message.pingData = reader.uint32();
          break;
        case /* optional uint32 game_time_s */ 3:
          message.gameTimeS = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Ping,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 ping_type = 1; */
    if (message.pingType !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.pingType);
    /* optional uint32 ping_data = 2; */
    if (message.pingData !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.pingData);
    /* optional uint32 game_time_s = 3; */
    if (message.gameTimeS !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.gameTimeS);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Ping
 */
export const CMsgMatchMetaDataContents_Ping =
  new CMsgMatchMetaDataContents_Ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_GoldSource$Type extends MessageType<CMsgMatchMetaDataContents_GoldSource> {
  constructor() {
    super("CMsgMatchMetaDataContents.GoldSource", [
      {
        no: 1,
        name: "source",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgMatchMetaDataContents.EGoldSource",
          CMsgMatchMetaDataContents_EGoldSource,
        ],
      },
      {
        no: 2,
        name: "kills",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "gold",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "gold_orbs",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_GoldSource>,
  ): CMsgMatchMetaDataContents_GoldSource {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_GoldSource>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_GoldSource,
  ): CMsgMatchMetaDataContents_GoldSource {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgMatchMetaDataContents.EGoldSource source */ 1:
          message.source = reader.int32();
          break;
        case /* optional uint32 kills */ 2:
          message.kills = reader.uint32();
          break;
        case /* optional uint32 damage */ 3:
          message.damage = reader.uint32();
          break;
        case /* optional uint32 gold */ 4:
          message.gold = reader.uint32();
          break;
        case /* optional uint32 gold_orbs */ 5:
          message.goldOrbs = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_GoldSource,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgMatchMetaDataContents.EGoldSource source = 1; */
    if (message.source !== undefined)
      writer.tag(1, WireType.Varint).int32(message.source);
    /* optional uint32 kills = 2; */
    if (message.kills !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.kills);
    /* optional uint32 damage = 3; */
    if (message.damage !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.damage);
    /* optional uint32 gold = 4; */
    if (message.gold !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.gold);
    /* optional uint32 gold_orbs = 5; */
    if (message.goldOrbs !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.goldOrbs);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.GoldSource
 */
export const CMsgMatchMetaDataContents_GoldSource =
  new CMsgMatchMetaDataContents_GoldSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_CustomUserStatInfo$Type extends MessageType<CMsgMatchMetaDataContents_CustomUserStatInfo> {
  constructor() {
    super("CMsgMatchMetaDataContents.CustomUserStatInfo", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_CustomUserStatInfo>,
  ): CMsgMatchMetaDataContents_CustomUserStatInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_CustomUserStatInfo>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_CustomUserStatInfo,
  ): CMsgMatchMetaDataContents_CustomUserStatInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */ 1:
          message.name = reader.string();
          break;
        case /* optional uint32 id */ 2:
          message.id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_CustomUserStatInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string name = 1; */
    if (message.name !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* optional uint32 id = 2; */
    if (message.id !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.CustomUserStatInfo
 */
export const CMsgMatchMetaDataContents_CustomUserStatInfo =
  new CMsgMatchMetaDataContents_CustomUserStatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_CustomUserStat$Type extends MessageType<CMsgMatchMetaDataContents_CustomUserStat> {
  constructor() {
    super("CMsgMatchMetaDataContents.CustomUserStat", [
      {
        no: 2,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_CustomUserStat>,
  ): CMsgMatchMetaDataContents_CustomUserStat {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_CustomUserStat>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_CustomUserStat,
  ): CMsgMatchMetaDataContents_CustomUserStat {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 value */ 2:
          message.value = reader.uint32();
          break;
        case /* optional uint32 id */ 3:
          message.id = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_CustomUserStat,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 value = 2; */
    if (message.value !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.value);
    /* optional uint32 id = 3; */
    if (message.id !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.id);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.CustomUserStat
 */
export const CMsgMatchMetaDataContents_CustomUserStat =
  new CMsgMatchMetaDataContents_CustomUserStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_PlayerStats$Type extends MessageType<CMsgMatchMetaDataContents_PlayerStats> {
  constructor() {
    super("CMsgMatchMetaDataContents.PlayerStats", [
      {
        no: 1,
        name: "time_stamp_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "net_worth",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "gold_player",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "gold_player_orbs",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "gold_lane_creep_orbs",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "gold_neutral_creep_orbs",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "gold_boss",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "gold_boss_orb",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "gold_treasure",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "gold_denied",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 11,
        name: "gold_death_loss",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "gold_lane_creep",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "gold_neutral_creep",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "kills",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "deaths",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "assists",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "creep_kills",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 18,
        name: "neutral_kills",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 19,
        name: "possible_creeps",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 20,
        name: "creep_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 21,
        name: "player_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 22,
        name: "neutral_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 23,
        name: "boss_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 24,
        name: "denies",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 25,
        name: "player_healing",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 26,
        name: "ability_points",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 27,
        name: "self_healing",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 28,
        name: "player_damage_taken",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 29,
        name: "max_health",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 30,
        name: "weapon_power",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 31,
        name: "tech_power",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 32,
        name: "shots_hit",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 33,
        name: "shots_missed",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 34,
        name: "damage_absorbed",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 35,
        name: "absorption_provided",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 36,
        name: "hero_bullets_hit",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 37,
        name: "hero_bullets_hit_crit",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 38,
        name: "heal_prevented",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 39,
        name: "heal_lost",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 40,
        name: "gold_sources",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_GoldSource,
      },
      {
        no: 41,
        name: "custom_user_stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_CustomUserStat,
      },
      {
        no: 42,
        name: "damage_mitigated",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 43,
        name: "level",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_PlayerStats>,
  ): CMsgMatchMetaDataContents_PlayerStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.goldSources = [];
    message.customUserStats = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_PlayerStats>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_PlayerStats,
  ): CMsgMatchMetaDataContents_PlayerStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 time_stamp_s */ 1:
          message.timeStampS = reader.uint32();
          break;
        case /* optional uint32 net_worth */ 2:
          message.netWorth = reader.uint32();
          break;
        case /* optional uint32 gold_player */ 3:
          message.goldPlayer = reader.uint32();
          break;
        case /* optional uint32 gold_player_orbs */ 4:
          message.goldPlayerOrbs = reader.uint32();
          break;
        case /* optional uint32 gold_lane_creep_orbs */ 5:
          message.goldLaneCreepOrbs = reader.uint32();
          break;
        case /* optional uint32 gold_neutral_creep_orbs */ 6:
          message.goldNeutralCreepOrbs = reader.uint32();
          break;
        case /* optional uint32 gold_boss */ 7:
          message.goldBoss = reader.uint32();
          break;
        case /* optional uint32 gold_boss_orb */ 8:
          message.goldBossOrb = reader.uint32();
          break;
        case /* optional uint32 gold_treasure */ 9:
          message.goldTreasure = reader.uint32();
          break;
        case /* optional uint32 gold_denied */ 10:
          message.goldDenied = reader.uint32();
          break;
        case /* optional uint32 gold_death_loss */ 11:
          message.goldDeathLoss = reader.uint32();
          break;
        case /* optional uint32 gold_lane_creep */ 12:
          message.goldLaneCreep = reader.uint32();
          break;
        case /* optional uint32 gold_neutral_creep */ 13:
          message.goldNeutralCreep = reader.uint32();
          break;
        case /* optional uint32 kills */ 14:
          message.kills = reader.uint32();
          break;
        case /* optional uint32 deaths */ 15:
          message.deaths = reader.uint32();
          break;
        case /* optional uint32 assists */ 16:
          message.assists = reader.uint32();
          break;
        case /* optional uint32 creep_kills */ 17:
          message.creepKills = reader.uint32();
          break;
        case /* optional uint32 neutral_kills */ 18:
          message.neutralKills = reader.uint32();
          break;
        case /* optional uint32 possible_creeps */ 19:
          message.possibleCreeps = reader.uint32();
          break;
        case /* optional uint32 creep_damage */ 20:
          message.creepDamage = reader.uint32();
          break;
        case /* optional uint32 player_damage */ 21:
          message.playerDamage = reader.uint32();
          break;
        case /* optional uint32 neutral_damage */ 22:
          message.neutralDamage = reader.uint32();
          break;
        case /* optional uint32 boss_damage */ 23:
          message.bossDamage = reader.uint32();
          break;
        case /* optional uint32 denies */ 24:
          message.denies = reader.uint32();
          break;
        case /* optional uint32 player_healing */ 25:
          message.playerHealing = reader.uint32();
          break;
        case /* optional uint32 ability_points */ 26:
          message.abilityPoints = reader.uint32();
          break;
        case /* optional uint32 self_healing */ 27:
          message.selfHealing = reader.uint32();
          break;
        case /* optional uint32 player_damage_taken */ 28:
          message.playerDamageTaken = reader.uint32();
          break;
        case /* optional uint32 max_health */ 29:
          message.maxHealth = reader.uint32();
          break;
        case /* optional uint32 weapon_power */ 30:
          message.weaponPower = reader.uint32();
          break;
        case /* optional uint32 tech_power */ 31:
          message.techPower = reader.uint32();
          break;
        case /* optional uint32 shots_hit */ 32:
          message.shotsHit = reader.uint32();
          break;
        case /* optional uint32 shots_missed */ 33:
          message.shotsMissed = reader.uint32();
          break;
        case /* optional uint32 damage_absorbed */ 34:
          message.damageAbsorbed = reader.uint32();
          break;
        case /* optional uint32 absorption_provided */ 35:
          message.absorptionProvided = reader.uint32();
          break;
        case /* optional uint32 hero_bullets_hit */ 36:
          message.heroBulletsHit = reader.uint32();
          break;
        case /* optional uint32 hero_bullets_hit_crit */ 37:
          message.heroBulletsHitCrit = reader.uint32();
          break;
        case /* optional uint32 heal_prevented */ 38:
          message.healPrevented = reader.uint32();
          break;
        case /* optional uint32 heal_lost */ 39:
          message.healLost = reader.uint32();
          break;
        case /* repeated CMsgMatchMetaDataContents.GoldSource gold_sources */ 40:
          message.goldSources.push(
            CMsgMatchMetaDataContents_GoldSource.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.CustomUserStat custom_user_stats */ 41:
          message.customUserStats.push(
            CMsgMatchMetaDataContents_CustomUserStat.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint32 damage_mitigated */ 42:
          message.damageMitigated = reader.uint32();
          break;
        case /* optional uint32 level */ 43:
          message.level = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_PlayerStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 time_stamp_s = 1; */
    if (message.timeStampS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.timeStampS);
    /* optional uint32 net_worth = 2; */
    if (message.netWorth !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.netWorth);
    /* optional uint32 gold_player = 3; */
    if (message.goldPlayer !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.goldPlayer);
    /* optional uint32 gold_player_orbs = 4; */
    if (message.goldPlayerOrbs !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.goldPlayerOrbs);
    /* optional uint32 gold_lane_creep_orbs = 5; */
    if (message.goldLaneCreepOrbs !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.goldLaneCreepOrbs);
    /* optional uint32 gold_neutral_creep_orbs = 6; */
    if (message.goldNeutralCreepOrbs !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.goldNeutralCreepOrbs);
    /* optional uint32 gold_boss = 7; */
    if (message.goldBoss !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.goldBoss);
    /* optional uint32 gold_boss_orb = 8; */
    if (message.goldBossOrb !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.goldBossOrb);
    /* optional uint32 gold_treasure = 9; */
    if (message.goldTreasure !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.goldTreasure);
    /* optional uint32 gold_denied = 10; */
    if (message.goldDenied !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.goldDenied);
    /* optional uint32 gold_death_loss = 11; */
    if (message.goldDeathLoss !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.goldDeathLoss);
    /* optional uint32 gold_lane_creep = 12; */
    if (message.goldLaneCreep !== undefined)
      writer.tag(12, WireType.Varint).uint32(message.goldLaneCreep);
    /* optional uint32 gold_neutral_creep = 13; */
    if (message.goldNeutralCreep !== undefined)
      writer.tag(13, WireType.Varint).uint32(message.goldNeutralCreep);
    /* optional uint32 kills = 14; */
    if (message.kills !== undefined)
      writer.tag(14, WireType.Varint).uint32(message.kills);
    /* optional uint32 deaths = 15; */
    if (message.deaths !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.deaths);
    /* optional uint32 assists = 16; */
    if (message.assists !== undefined)
      writer.tag(16, WireType.Varint).uint32(message.assists);
    /* optional uint32 creep_kills = 17; */
    if (message.creepKills !== undefined)
      writer.tag(17, WireType.Varint).uint32(message.creepKills);
    /* optional uint32 neutral_kills = 18; */
    if (message.neutralKills !== undefined)
      writer.tag(18, WireType.Varint).uint32(message.neutralKills);
    /* optional uint32 possible_creeps = 19; */
    if (message.possibleCreeps !== undefined)
      writer.tag(19, WireType.Varint).uint32(message.possibleCreeps);
    /* optional uint32 creep_damage = 20; */
    if (message.creepDamage !== undefined)
      writer.tag(20, WireType.Varint).uint32(message.creepDamage);
    /* optional uint32 player_damage = 21; */
    if (message.playerDamage !== undefined)
      writer.tag(21, WireType.Varint).uint32(message.playerDamage);
    /* optional uint32 neutral_damage = 22; */
    if (message.neutralDamage !== undefined)
      writer.tag(22, WireType.Varint).uint32(message.neutralDamage);
    /* optional uint32 boss_damage = 23; */
    if (message.bossDamage !== undefined)
      writer.tag(23, WireType.Varint).uint32(message.bossDamage);
    /* optional uint32 denies = 24; */
    if (message.denies !== undefined)
      writer.tag(24, WireType.Varint).uint32(message.denies);
    /* optional uint32 player_healing = 25; */
    if (message.playerHealing !== undefined)
      writer.tag(25, WireType.Varint).uint32(message.playerHealing);
    /* optional uint32 ability_points = 26; */
    if (message.abilityPoints !== undefined)
      writer.tag(26, WireType.Varint).uint32(message.abilityPoints);
    /* optional uint32 self_healing = 27; */
    if (message.selfHealing !== undefined)
      writer.tag(27, WireType.Varint).uint32(message.selfHealing);
    /* optional uint32 player_damage_taken = 28; */
    if (message.playerDamageTaken !== undefined)
      writer.tag(28, WireType.Varint).uint32(message.playerDamageTaken);
    /* optional uint32 max_health = 29; */
    if (message.maxHealth !== undefined)
      writer.tag(29, WireType.Varint).uint32(message.maxHealth);
    /* optional uint32 weapon_power = 30; */
    if (message.weaponPower !== undefined)
      writer.tag(30, WireType.Varint).uint32(message.weaponPower);
    /* optional uint32 tech_power = 31; */
    if (message.techPower !== undefined)
      writer.tag(31, WireType.Varint).uint32(message.techPower);
    /* optional uint32 shots_hit = 32; */
    if (message.shotsHit !== undefined)
      writer.tag(32, WireType.Varint).uint32(message.shotsHit);
    /* optional uint32 shots_missed = 33; */
    if (message.shotsMissed !== undefined)
      writer.tag(33, WireType.Varint).uint32(message.shotsMissed);
    /* optional uint32 damage_absorbed = 34; */
    if (message.damageAbsorbed !== undefined)
      writer.tag(34, WireType.Varint).uint32(message.damageAbsorbed);
    /* optional uint32 absorption_provided = 35; */
    if (message.absorptionProvided !== undefined)
      writer.tag(35, WireType.Varint).uint32(message.absorptionProvided);
    /* optional uint32 hero_bullets_hit = 36; */
    if (message.heroBulletsHit !== undefined)
      writer.tag(36, WireType.Varint).uint32(message.heroBulletsHit);
    /* optional uint32 hero_bullets_hit_crit = 37; */
    if (message.heroBulletsHitCrit !== undefined)
      writer.tag(37, WireType.Varint).uint32(message.heroBulletsHitCrit);
    /* optional uint32 heal_prevented = 38; */
    if (message.healPrevented !== undefined)
      writer.tag(38, WireType.Varint).uint32(message.healPrevented);
    /* optional uint32 heal_lost = 39; */
    if (message.healLost !== undefined)
      writer.tag(39, WireType.Varint).uint32(message.healLost);
    /* repeated CMsgMatchMetaDataContents.GoldSource gold_sources = 40; */
    for (let i = 0; i < message.goldSources.length; i++)
      CMsgMatchMetaDataContents_GoldSource.internalBinaryWrite(
        message.goldSources[i],
        writer.tag(40, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.CustomUserStat custom_user_stats = 41; */
    for (let i = 0; i < message.customUserStats.length; i++)
      CMsgMatchMetaDataContents_CustomUserStat.internalBinaryWrite(
        message.customUserStats[i],
        writer.tag(41, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 damage_mitigated = 42; */
    if (message.damageMitigated !== undefined)
      writer.tag(42, WireType.Varint).uint32(message.damageMitigated);
    /* optional uint32 level = 43; */
    if (message.level !== undefined)
      writer.tag(43, WireType.Varint).uint32(message.level);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.PlayerStats
 */
export const CMsgMatchMetaDataContents_PlayerStats =
  new CMsgMatchMetaDataContents_PlayerStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_AbilityStat$Type extends MessageType<CMsgMatchMetaDataContents_AbilityStat> {
  constructor() {
    super("CMsgMatchMetaDataContents.AbilityStat", [
      {
        no: 1,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "ability_value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_AbilityStat>,
  ): CMsgMatchMetaDataContents_AbilityStat {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_AbilityStat>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_AbilityStat,
  ): CMsgMatchMetaDataContents_AbilityStat {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 ability_id */ 1:
          message.abilityId = reader.uint32();
          break;
        case /* optional uint32 ability_value */ 2:
          message.abilityValue = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_AbilityStat,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 ability_id = 1; */
    if (message.abilityId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.abilityId);
    /* optional uint32 ability_value = 2; */
    if (message.abilityValue !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.abilityValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.AbilityStat
 */
export const CMsgMatchMetaDataContents_AbilityStat =
  new CMsgMatchMetaDataContents_AbilityStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_BookReward$Type extends MessageType<CMsgMatchMetaDataContents_BookReward> {
  constructor() {
    super("CMsgMatchMetaDataContents.BookReward", [
      {
        no: 1,
        name: "book_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "xp_amount",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "starting_xp",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_BookReward>,
  ): CMsgMatchMetaDataContents_BookReward {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_BookReward>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_BookReward,
  ): CMsgMatchMetaDataContents_BookReward {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 book_id */ 1:
          message.bookId = reader.uint32();
          break;
        case /* optional uint32 xp_amount */ 2:
          message.xpAmount = reader.uint32();
          break;
        case /* optional uint32 starting_xp */ 3:
          message.startingXp = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_BookReward,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 book_id = 1; */
    if (message.bookId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.bookId);
    /* optional uint32 xp_amount = 2; */
    if (message.xpAmount !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.xpAmount);
    /* optional uint32 starting_xp = 3; */
    if (message.startingXp !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.startingXp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.BookReward
 */
export const CMsgMatchMetaDataContents_BookReward =
  new CMsgMatchMetaDataContents_BookReward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Players$Type extends MessageType<CMsgMatchMetaDataContents_Players> {
  constructor() {
    super("CMsgMatchMetaDataContents.Players", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "death_details",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Deaths,
      },
      {
        no: 4,
        name: "items",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Items,
      },
      {
        no: 5,
        name: "stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_PlayerStats,
      },
      {
        no: 6,
        name: "team",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelLobbyTeam", ECitadelLobbyTeam],
      },
      {
        no: 8,
        name: "kills",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "deaths",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "assists",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 11,
        name: "net_worth",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "last_hits",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "denies",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "ability_points",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "party",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "assigned_lane",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 18,
        name: "level",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 19,
        name: "pings",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Ping,
      },
      {
        no: 20,
        name: "ability_stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_AbilityStat,
      },
      {
        no: 21,
        name: "stats_type_stat",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 22,
        name: "book_rewards",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_BookReward,
      },
      {
        no: 23,
        name: "abandon_match_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Players>,
  ): CMsgMatchMetaDataContents_Players {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deathDetails = [];
    message.items = [];
    message.stats = [];
    message.pings = [];
    message.abilityStats = [];
    message.statsTypeStat = [];
    message.bookRewards = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Players>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Players,
  ): CMsgMatchMetaDataContents_Players {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 player_slot */ 2:
          message.playerSlot = reader.uint32();
          break;
        case /* repeated CMsgMatchMetaDataContents.Deaths death_details */ 3:
          message.deathDetails.push(
            CMsgMatchMetaDataContents_Deaths.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.Items items */ 4:
          message.items.push(
            CMsgMatchMetaDataContents_Items.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.PlayerStats stats */ 5:
          message.stats.push(
            CMsgMatchMetaDataContents_PlayerStats.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional ECitadelLobbyTeam team */ 6:
          message.team = reader.int32();
          break;
        case /* optional uint32 kills */ 8:
          message.kills = reader.uint32();
          break;
        case /* optional uint32 deaths */ 9:
          message.deaths = reader.uint32();
          break;
        case /* optional uint32 assists */ 10:
          message.assists = reader.uint32();
          break;
        case /* optional uint32 net_worth */ 11:
          message.netWorth = reader.uint32();
          break;
        case /* optional uint32 hero_id */ 12:
          message.heroId = reader.uint32();
          break;
        case /* optional uint32 last_hits */ 13:
          message.lastHits = reader.uint32();
          break;
        case /* optional uint32 denies */ 14:
          message.denies = reader.uint32();
          break;
        case /* optional uint32 ability_points */ 15:
          message.abilityPoints = reader.uint32();
          break;
        case /* optional uint32 party */ 16:
          message.party = reader.uint32();
          break;
        case /* optional uint32 assigned_lane */ 17:
          message.assignedLane = reader.uint32();
          break;
        case /* optional uint32 level */ 18:
          message.level = reader.uint32();
          break;
        case /* repeated CMsgMatchMetaDataContents.Ping pings */ 19:
          message.pings.push(
            CMsgMatchMetaDataContents_Ping.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.AbilityStat ability_stats */ 20:
          message.abilityStats.push(
            CMsgMatchMetaDataContents_AbilityStat.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated float stats_type_stat = 21 [packed = true];*/ 21:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.statsTypeStat.push(reader.float());
          else message.statsTypeStat.push(reader.float());
          break;
        case /* repeated CMsgMatchMetaDataContents.BookReward book_rewards */ 22:
          message.bookRewards.push(
            CMsgMatchMetaDataContents_BookReward.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint32 abandon_match_time_s */ 23:
          message.abandonMatchTimeS = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Players,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional uint32 player_slot = 2; */
    if (message.playerSlot !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.playerSlot);
    /* repeated CMsgMatchMetaDataContents.Deaths death_details = 3; */
    for (let i = 0; i < message.deathDetails.length; i++)
      CMsgMatchMetaDataContents_Deaths.internalBinaryWrite(
        message.deathDetails[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.Items items = 4; */
    for (let i = 0; i < message.items.length; i++)
      CMsgMatchMetaDataContents_Items.internalBinaryWrite(
        message.items[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.PlayerStats stats = 5; */
    for (let i = 0; i < message.stats.length; i++)
      CMsgMatchMetaDataContents_PlayerStats.internalBinaryWrite(
        message.stats[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional ECitadelLobbyTeam team = 6; */
    if (message.team !== undefined)
      writer.tag(6, WireType.Varint).int32(message.team);
    /* optional uint32 kills = 8; */
    if (message.kills !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.kills);
    /* optional uint32 deaths = 9; */
    if (message.deaths !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.deaths);
    /* optional uint32 assists = 10; */
    if (message.assists !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.assists);
    /* optional uint32 net_worth = 11; */
    if (message.netWorth !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.netWorth);
    /* optional uint32 hero_id = 12; */
    if (message.heroId !== undefined)
      writer.tag(12, WireType.Varint).uint32(message.heroId);
    /* optional uint32 last_hits = 13; */
    if (message.lastHits !== undefined)
      writer.tag(13, WireType.Varint).uint32(message.lastHits);
    /* optional uint32 denies = 14; */
    if (message.denies !== undefined)
      writer.tag(14, WireType.Varint).uint32(message.denies);
    /* optional uint32 ability_points = 15; */
    if (message.abilityPoints !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.abilityPoints);
    /* optional uint32 party = 16; */
    if (message.party !== undefined)
      writer.tag(16, WireType.Varint).uint32(message.party);
    /* optional uint32 assigned_lane = 17; */
    if (message.assignedLane !== undefined)
      writer.tag(17, WireType.Varint).uint32(message.assignedLane);
    /* optional uint32 level = 18; */
    if (message.level !== undefined)
      writer.tag(18, WireType.Varint).uint32(message.level);
    /* repeated CMsgMatchMetaDataContents.Ping pings = 19; */
    for (let i = 0; i < message.pings.length; i++)
      CMsgMatchMetaDataContents_Ping.internalBinaryWrite(
        message.pings[i],
        writer.tag(19, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.AbilityStat ability_stats = 20; */
    for (let i = 0; i < message.abilityStats.length; i++)
      CMsgMatchMetaDataContents_AbilityStat.internalBinaryWrite(
        message.abilityStats[i],
        writer.tag(20, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated float stats_type_stat = 21 [packed = true]; */
    if (message.statsTypeStat.length) {
      writer.tag(21, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.statsTypeStat.length; i++)
        writer.float(message.statsTypeStat[i]);
      writer.join();
    }
    /* repeated CMsgMatchMetaDataContents.BookReward book_rewards = 22; */
    for (let i = 0; i < message.bookRewards.length; i++)
      CMsgMatchMetaDataContents_BookReward.internalBinaryWrite(
        message.bookRewards[i],
        writer.tag(22, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 abandon_match_time_s = 23; */
    if (message.abandonMatchTimeS !== undefined)
      writer.tag(23, WireType.Varint).uint32(message.abandonMatchTimeS);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Players
 */
export const CMsgMatchMetaDataContents_Players =
  new CMsgMatchMetaDataContents_Players$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Objective$Type extends MessageType<CMsgMatchMetaDataContents_Objective> {
  constructor() {
    super("CMsgMatchMetaDataContents.Objective", [
      {
        no: 1,
        name: "legacy_objective_id",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelObjective", ECitadelObjective],
      },
      {
        no: 2,
        name: "destroyed_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "creep_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "creep_damage_mitigated",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "player_damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "player_damage_mitigated",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "first_damage_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "team_objective_id",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelTeamObjective", ECitadelTeamObjective],
      },
      {
        no: 10,
        name: "team",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelLobbyTeam", ECitadelLobbyTeam],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Objective>,
  ): CMsgMatchMetaDataContents_Objective {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Objective>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Objective,
  ): CMsgMatchMetaDataContents_Objective {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional ECitadelObjective legacy_objective_id */ 1:
          message.legacyObjectiveId = reader.int32();
          break;
        case /* optional uint32 destroyed_time_s */ 2:
          message.destroyedTimeS = reader.uint32();
          break;
        case /* optional uint32 creep_damage */ 4:
          message.creepDamage = reader.uint32();
          break;
        case /* optional uint32 creep_damage_mitigated */ 5:
          message.creepDamageMitigated = reader.uint32();
          break;
        case /* optional uint32 player_damage */ 6:
          message.playerDamage = reader.uint32();
          break;
        case /* optional uint32 player_damage_mitigated */ 7:
          message.playerDamageMitigated = reader.uint32();
          break;
        case /* optional uint32 first_damage_time_s */ 8:
          message.firstDamageTimeS = reader.uint32();
          break;
        case /* optional ECitadelTeamObjective team_objective_id */ 9:
          message.teamObjectiveId = reader.int32();
          break;
        case /* optional ECitadelLobbyTeam team */ 10:
          message.team = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Objective,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional ECitadelObjective legacy_objective_id = 1; */
    if (message.legacyObjectiveId !== undefined)
      writer.tag(1, WireType.Varint).int32(message.legacyObjectiveId);
    /* optional uint32 destroyed_time_s = 2; */
    if (message.destroyedTimeS !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.destroyedTimeS);
    /* optional uint32 creep_damage = 4; */
    if (message.creepDamage !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.creepDamage);
    /* optional uint32 creep_damage_mitigated = 5; */
    if (message.creepDamageMitigated !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.creepDamageMitigated);
    /* optional uint32 player_damage = 6; */
    if (message.playerDamage !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.playerDamage);
    /* optional uint32 player_damage_mitigated = 7; */
    if (message.playerDamageMitigated !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.playerDamageMitigated);
    /* optional uint32 first_damage_time_s = 8; */
    if (message.firstDamageTimeS !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.firstDamageTimeS);
    /* optional ECitadelTeamObjective team_objective_id = 9; */
    if (message.teamObjectiveId !== undefined)
      writer.tag(9, WireType.Varint).int32(message.teamObjectiveId);
    /* optional ECitadelLobbyTeam team = 10; */
    if (message.team !== undefined)
      writer.tag(10, WireType.Varint).int32(message.team);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Objective
 */
export const CMsgMatchMetaDataContents_Objective =
  new CMsgMatchMetaDataContents_Objective$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_MidBoss$Type extends MessageType<CMsgMatchMetaDataContents_MidBoss> {
  constructor() {
    super("CMsgMatchMetaDataContents.MidBoss", [
      {
        no: 1,
        name: "team_killed",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelLobbyTeam", ECitadelLobbyTeam],
      },
      {
        no: 2,
        name: "team_claimed",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelLobbyTeam", ECitadelLobbyTeam],
      },
      {
        no: 3,
        name: "destroyed_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_MidBoss>,
  ): CMsgMatchMetaDataContents_MidBoss {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_MidBoss>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_MidBoss,
  ): CMsgMatchMetaDataContents_MidBoss {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional ECitadelLobbyTeam team_killed */ 1:
          message.teamKilled = reader.int32();
          break;
        case /* optional ECitadelLobbyTeam team_claimed */ 2:
          message.teamClaimed = reader.int32();
          break;
        case /* optional uint32 destroyed_time_s */ 3:
          message.destroyedTimeS = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_MidBoss,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional ECitadelLobbyTeam team_killed = 1; */
    if (message.teamKilled !== undefined)
      writer.tag(1, WireType.Varint).int32(message.teamKilled);
    /* optional ECitadelLobbyTeam team_claimed = 2; */
    if (message.teamClaimed !== undefined)
      writer.tag(2, WireType.Varint).int32(message.teamClaimed);
    /* optional uint32 destroyed_time_s = 3; */
    if (message.destroyedTimeS !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.destroyedTimeS);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.MidBoss
 */
export const CMsgMatchMetaDataContents_MidBoss =
  new CMsgMatchMetaDataContents_MidBoss$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_Pause$Type extends MessageType<CMsgMatchMetaDataContents_Pause> {
  constructor() {
    super("CMsgMatchMetaDataContents.Pause", [
      {
        no: 1,
        name: "game_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "pause_duration_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_Pause>,
  ): CMsgMatchMetaDataContents_Pause {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_Pause>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_Pause,
  ): CMsgMatchMetaDataContents_Pause {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 game_time_s */ 1:
          message.gameTimeS = reader.uint32();
          break;
        case /* optional uint32 pause_duration_s */ 2:
          message.pauseDurationS = reader.uint32();
          break;
        case /* optional uint32 player_slot */ 3:
          message.playerSlot = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_Pause,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 game_time_s = 1; */
    if (message.gameTimeS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.gameTimeS);
    /* optional uint32 pause_duration_s = 2; */
    if (message.pauseDurationS !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.pauseDurationS);
    /* optional uint32 player_slot = 3; */
    if (message.playerSlot !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.playerSlot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.Pause
 */
export const CMsgMatchMetaDataContents_Pause =
  new CMsgMatchMetaDataContents_Pause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_WatchedDeathReplay$Type extends MessageType<CMsgMatchMetaDataContents_WatchedDeathReplay> {
  constructor() {
    super("CMsgMatchMetaDataContents.WatchedDeathReplay", [
      {
        no: 1,
        name: "game_time_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_WatchedDeathReplay>,
  ): CMsgMatchMetaDataContents_WatchedDeathReplay {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_WatchedDeathReplay>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_WatchedDeathReplay,
  ): CMsgMatchMetaDataContents_WatchedDeathReplay {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 game_time_s */ 1:
          message.gameTimeS = reader.uint32();
          break;
        case /* optional uint32 player_slot */ 2:
          message.playerSlot = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_WatchedDeathReplay,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 game_time_s = 1; */
    if (message.gameTimeS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.gameTimeS);
    /* optional uint32 player_slot = 2; */
    if (message.playerSlot !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.playerSlot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.WatchedDeathReplay
 */
export const CMsgMatchMetaDataContents_WatchedDeathReplay =
  new CMsgMatchMetaDataContents_WatchedDeathReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaDataContents_MatchInfo$Type extends MessageType<CMsgMatchMetaDataContents_MatchInfo> {
  constructor() {
    super("CMsgMatchMetaDataContents.MatchInfo", [
      {
        no: 1,
        name: "duration_s",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "match_outcome",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgMatchMetaDataContents.EMatchOutcome",
          CMsgMatchMetaDataContents_EMatchOutcome,
        ],
      },
      {
        no: 3,
        name: "winning_team",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelLobbyTeam", ECitadelLobbyTeam],
      },
      {
        no: 4,
        name: "players",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Players,
      },
      {
        no: 5,
        name: "start_time",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "match_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 8,
        name: "legacy_objectives_mask",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "game_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelGameMode", ECitadelGameMode],
      },
      {
        no: 10,
        name: "match_mode",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelMatchMode", ECitadelMatchMode],
      },
      {
        no: 11,
        name: "objectives",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Objective,
      },
      {
        no: 12,
        name: "match_paths",
        kind: "message",
        T: () => CMsgMatchPlayerPathsData,
      },
      {
        no: 13,
        name: "damage_matrix",
        kind: "message",
        T: () => CMsgMatchPlayerDamageMatrix,
      },
      {
        no: 14,
        name: "match_pauses",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_Pause,
      },
      {
        no: 15,
        name: "custom_user_stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_CustomUserStatInfo,
      },
      {
        no: 16,
        name: "watched_death_replays",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_WatchedDeathReplay,
      },
      {
        no: 17,
        name: "objectives_mask_team0",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 18,
        name: "objectives_mask_team1",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 19,
        name: "mid_boss",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgMatchMetaDataContents_MidBoss,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgMatchMetaDataContents_MatchInfo>,
  ): CMsgMatchMetaDataContents_MatchInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.players = [];
    message.objectives = [];
    message.matchPauses = [];
    message.customUserStats = [];
    message.watchedDeathReplays = [];
    message.midBoss = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaDataContents_MatchInfo>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaDataContents_MatchInfo,
  ): CMsgMatchMetaDataContents_MatchInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 duration_s */ 1:
          message.durationS = reader.uint32();
          break;
        case /* optional CMsgMatchMetaDataContents.EMatchOutcome match_outcome */ 2:
          message.matchOutcome = reader.int32();
          break;
        case /* optional ECitadelLobbyTeam winning_team */ 3:
          message.winningTeam = reader.int32();
          break;
        case /* repeated CMsgMatchMetaDataContents.Players players */ 4:
          message.players.push(
            CMsgMatchMetaDataContents_Players.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint32 start_time */ 5:
          message.startTime = reader.uint32();
          break;
        case /* optional uint64 match_id */ 6:
          message.matchId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 legacy_objectives_mask */ 8:
          message.legacyObjectivesMask = reader.uint32();
          break;
        case /* optional ECitadelGameMode game_mode */ 9:
          message.gameMode = reader.int32();
          break;
        case /* optional ECitadelMatchMode match_mode */ 10:
          message.matchMode = reader.int32();
          break;
        case /* repeated CMsgMatchMetaDataContents.Objective objectives */ 11:
          message.objectives.push(
            CMsgMatchMetaDataContents_Objective.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional CMsgMatchPlayerPathsData match_paths */ 12:
          message.matchPaths = CMsgMatchPlayerPathsData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.matchPaths,
          );
          break;
        case /* optional CMsgMatchPlayerDamageMatrix damage_matrix */ 13:
          message.damageMatrix = CMsgMatchPlayerDamageMatrix.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.damageMatrix,
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.Pause match_pauses */ 14:
          message.matchPauses.push(
            CMsgMatchMetaDataContents_Pause.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.CustomUserStatInfo custom_user_stats */ 15:
          message.customUserStats.push(
            CMsgMatchMetaDataContents_CustomUserStatInfo.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated CMsgMatchMetaDataContents.WatchedDeathReplay watched_death_replays */ 16:
          message.watchedDeathReplays.push(
            CMsgMatchMetaDataContents_WatchedDeathReplay.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint64 objectives_mask_team0 */ 17:
          message.objectivesMaskTeam0 = reader.uint64().toBigInt();
          break;
        case /* optional uint64 objectives_mask_team1 */ 18:
          message.objectivesMaskTeam1 = reader.uint64().toBigInt();
          break;
        case /* repeated CMsgMatchMetaDataContents.MidBoss mid_boss */ 19:
          message.midBoss.push(
            CMsgMatchMetaDataContents_MidBoss.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaDataContents_MatchInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 duration_s = 1; */
    if (message.durationS !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.durationS);
    /* optional CMsgMatchMetaDataContents.EMatchOutcome match_outcome = 2; */
    if (message.matchOutcome !== undefined)
      writer.tag(2, WireType.Varint).int32(message.matchOutcome);
    /* optional ECitadelLobbyTeam winning_team = 3; */
    if (message.winningTeam !== undefined)
      writer.tag(3, WireType.Varint).int32(message.winningTeam);
    /* repeated CMsgMatchMetaDataContents.Players players = 4; */
    for (let i = 0; i < message.players.length; i++)
      CMsgMatchMetaDataContents_Players.internalBinaryWrite(
        message.players[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 start_time = 5; */
    if (message.startTime !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.startTime);
    /* optional uint64 match_id = 6; */
    if (message.matchId !== undefined)
      writer.tag(6, WireType.Varint).uint64(message.matchId);
    /* optional uint32 legacy_objectives_mask = 8; */
    if (message.legacyObjectivesMask !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.legacyObjectivesMask);
    /* optional ECitadelGameMode game_mode = 9; */
    if (message.gameMode !== undefined)
      writer.tag(9, WireType.Varint).int32(message.gameMode);
    /* optional ECitadelMatchMode match_mode = 10; */
    if (message.matchMode !== undefined)
      writer.tag(10, WireType.Varint).int32(message.matchMode);
    /* repeated CMsgMatchMetaDataContents.Objective objectives = 11; */
    for (let i = 0; i < message.objectives.length; i++)
      CMsgMatchMetaDataContents_Objective.internalBinaryWrite(
        message.objectives[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgMatchPlayerPathsData match_paths = 12; */
    if (message.matchPaths)
      CMsgMatchPlayerPathsData.internalBinaryWrite(
        message.matchPaths,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgMatchPlayerDamageMatrix damage_matrix = 13; */
    if (message.damageMatrix)
      CMsgMatchPlayerDamageMatrix.internalBinaryWrite(
        message.damageMatrix,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.Pause match_pauses = 14; */
    for (let i = 0; i < message.matchPauses.length; i++)
      CMsgMatchMetaDataContents_Pause.internalBinaryWrite(
        message.matchPauses[i],
        writer.tag(14, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.CustomUserStatInfo custom_user_stats = 15; */
    for (let i = 0; i < message.customUserStats.length; i++)
      CMsgMatchMetaDataContents_CustomUserStatInfo.internalBinaryWrite(
        message.customUserStats[i],
        writer.tag(15, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgMatchMetaDataContents.WatchedDeathReplay watched_death_replays = 16; */
    for (let i = 0; i < message.watchedDeathReplays.length; i++)
      CMsgMatchMetaDataContents_WatchedDeathReplay.internalBinaryWrite(
        message.watchedDeathReplays[i],
        writer.tag(16, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint64 objectives_mask_team0 = 17; */
    if (message.objectivesMaskTeam0 !== undefined)
      writer.tag(17, WireType.Varint).uint64(message.objectivesMaskTeam0);
    /* optional uint64 objectives_mask_team1 = 18; */
    if (message.objectivesMaskTeam1 !== undefined)
      writer.tag(18, WireType.Varint).uint64(message.objectivesMaskTeam1);
    /* repeated CMsgMatchMetaDataContents.MidBoss mid_boss = 19; */
    for (let i = 0; i < message.midBoss.length; i++)
      CMsgMatchMetaDataContents_MidBoss.internalBinaryWrite(
        message.midBoss[i],
        writer.tag(19, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaDataContents.MatchInfo
 */
export const CMsgMatchMetaDataContents_MatchInfo =
  new CMsgMatchMetaDataContents_MatchInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMatchMetaData$Type extends MessageType<CMsgMatchMetaData> {
  constructor() {
    super("CMsgMatchMetaData", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "match_details",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 3,
        name: "match_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgMatchMetaData>): CMsgMatchMetaData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMatchMetaData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMatchMetaData,
  ): CMsgMatchMetaData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 version */ 1:
          message.version = reader.uint32();
          break;
        case /* optional bytes match_details */ 2:
          message.matchDetails = reader.bytes();
          break;
        case /* optional uint64 match_id */ 3:
          message.matchId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMatchMetaData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 version = 1; */
    if (message.version !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.version);
    /* optional bytes match_details = 2; */
    if (message.matchDetails !== undefined)
      writer.tag(2, WireType.LengthDelimited).bytes(message.matchDetails);
    /* optional uint64 match_id = 3; */
    if (message.matchId !== undefined)
      writer.tag(3, WireType.Varint).uint64(message.matchId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMatchMetaData
 */
export const CMsgMatchMetaData = new CMsgMatchMetaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMapLine$Type extends MessageType<CMsgMapLine> {
  constructor() {
    super("CMsgMapLine", [
      {
        no: 1,
        name: "x",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "y",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "initial",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgMapLine>): CMsgMapLine {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgMapLine>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgMapLine,
  ): CMsgMapLine {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 x */ 1:
          message.x = reader.int32();
          break;
        case /* optional int32 y */ 2:
          message.y = reader.int32();
          break;
        case /* optional bool initial */ 3:
          message.initial = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgMapLine,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 x = 1; */
    if (message.x !== undefined)
      writer.tag(1, WireType.Varint).int32(message.x);
    /* optional int32 y = 2; */
    if (message.y !== undefined)
      writer.tag(2, WireType.Varint).int32(message.y);
    /* optional bool initial = 3; */
    if (message.initial !== undefined)
      writer.tag(3, WireType.Varint).bool(message.initial);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgMapLine
 */
export const CMsgMapLine = new CMsgMapLine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAccountHeroStats$Type extends MessageType<CMsgAccountHeroStats> {
  constructor() {
    super("CMsgAccountHeroStats", [
      {
        no: 1,
        name: "hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "stat_id",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "total_value",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "medals_bronze",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "medals_silver",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "medals_gold",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAccountHeroStats>): CMsgAccountHeroStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.statId = [];
    message.totalValue = [];
    message.medalsBronze = [];
    message.medalsSilver = [];
    message.medalsGold = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAccountHeroStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAccountHeroStats,
  ): CMsgAccountHeroStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 hero_id */ 1:
          message.heroId = reader.uint32();
          break;
        case /* repeated uint32 stat_id */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.statId.push(reader.uint32());
          else message.statId.push(reader.uint32());
          break;
        case /* repeated uint64 total_value */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.totalValue.push(reader.uint64().toBigInt());
          else message.totalValue.push(reader.uint64().toBigInt());
          break;
        case /* repeated uint32 medals_bronze */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.medalsBronze.push(reader.uint32());
          else message.medalsBronze.push(reader.uint32());
          break;
        case /* repeated uint32 medals_silver */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.medalsSilver.push(reader.uint32());
          else message.medalsSilver.push(reader.uint32());
          break;
        case /* repeated uint32 medals_gold */ 6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.medalsGold.push(reader.uint32());
          else message.medalsGold.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAccountHeroStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 hero_id = 1; */
    if (message.heroId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.heroId);
    /* repeated uint32 stat_id = 2; */
    for (let i = 0; i < message.statId.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.statId[i]);
    /* repeated uint64 total_value = 3; */
    for (let i = 0; i < message.totalValue.length; i++)
      writer.tag(3, WireType.Varint).uint64(message.totalValue[i]);
    /* repeated uint32 medals_bronze = 4; */
    for (let i = 0; i < message.medalsBronze.length; i++)
      writer.tag(4, WireType.Varint).uint32(message.medalsBronze[i]);
    /* repeated uint32 medals_silver = 5; */
    for (let i = 0; i < message.medalsSilver.length; i++)
      writer.tag(5, WireType.Varint).uint32(message.medalsSilver[i]);
    /* repeated uint32 medals_gold = 6; */
    for (let i = 0; i < message.medalsGold.length; i++)
      writer.tag(6, WireType.Varint).uint32(message.medalsGold[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAccountHeroStats
 */
export const CMsgAccountHeroStats = new CMsgAccountHeroStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAccountBookStats$Type extends MessageType<CMsgAccountBookStats> {
  constructor() {
    super("CMsgAccountBookStats", [
      {
        no: 1,
        name: "book_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "book_xp",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "book_max_xp",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAccountBookStats>): CMsgAccountBookStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgAccountBookStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAccountBookStats,
  ): CMsgAccountBookStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 book_id */ 1:
          message.bookId = reader.uint32();
          break;
        case /* optional uint32 book_xp */ 2:
          message.bookXp = reader.uint32();
          break;
        case /* optional uint32 book_max_xp */ 3:
          message.bookMaxXp = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAccountBookStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 book_id = 1; */
    if (message.bookId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.bookId);
    /* optional uint32 book_xp = 2; */
    if (message.bookXp !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.bookXp);
    /* optional uint32 book_max_xp = 3; */
    if (message.bookMaxXp !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.bookMaxXp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAccountBookStats
 */
export const CMsgAccountBookStats = new CMsgAccountBookStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAccountStats$Type extends MessageType<CMsgAccountStats> {
  constructor() {
    super("CMsgAccountStats", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgAccountHeroStats,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAccountStats>): CMsgAccountStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.stats = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAccountStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAccountStats,
  ): CMsgAccountStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* repeated CMsgAccountHeroStats stats */ 2:
          message.stats.push(
            CMsgAccountHeroStats.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAccountStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* repeated CMsgAccountHeroStats stats = 2; */
    for (let i = 0; i < message.stats.length; i++)
      CMsgAccountHeroStats.internalBinaryWrite(
        message.stats[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAccountStats
 */
export const CMsgAccountStats = new CMsgAccountStats$Type();

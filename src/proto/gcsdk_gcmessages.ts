// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "gcsdk_gcmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CGCSystemMsg_GetAccountDetails_Response } from "./steammessages";
import { CMsgSteamLearnAccessTokens } from "./steammessages_steamlearn.steamworkssdk";
/**
 * @generated from protobuf message CExtraMsgBlock
 */
export interface CExtraMsgBlock {
    /**
     * @generated from protobuf field: optional uint32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional bytes contents = 2;
     */
    contents?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 msg_key = 3;
     */
    msgKey?: bigint;
    /**
     * @generated from protobuf field: optional bool is_compressed = 4;
     */
    isCompressed?: boolean;
}
/**
 * @generated from protobuf message CMsgSteamLearnServerInfo
 */
export interface CMsgSteamLearnServerInfo {
    /**
     * @generated from protobuf field: optional CMsgSteamLearnAccessTokens access_tokens = 4;
     */
    accessTokens?: CMsgSteamLearnAccessTokens;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos = 5;
     */
    projectInfos: CMsgSteamLearnServerInfo_ProjectInfo[];
}
/**
 * @generated from protobuf message CMsgSteamLearnServerInfo.ProjectInfo
 */
export interface CMsgSteamLearnServerInfo_ProjectInfo {
    /**
     * @generated from protobuf field: optional uint32 project_id = 1;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional uint32 snapshot_published_version = 2;
     */
    snapshotPublishedVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 inference_published_version = 3;
     */
    inferencePublishedVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 snapshot_percentage = 6;
     */
    snapshotPercentage?: number;
    /**
     * @generated from protobuf field: optional bool snapshot_enabled = 7;
     */
    snapshotEnabled?: boolean;
}
/**
 * @generated from protobuf message CMsgGCAssertJobData
 */
export interface CMsgGCAssertJobData {
    /**
     * @generated from protobuf field: optional string message_type = 1;
     */
    messageType?: string;
    /**
     * @generated from protobuf field: optional bytes message_data = 2;
     */
    messageData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCConCommand
 */
export interface CMsgGCConCommand {
    /**
     * @generated from protobuf field: optional string command = 1;
     */
    command?: string;
}
/**
 * @generated from protobuf message CMsgSDOAssert
 */
export interface CMsgSDOAssert {
    /**
     * @generated from protobuf field: optional int32 sdo_type = 1;
     */
    sdoType?: number;
    /**
     * @generated from protobuf field: repeated CMsgSDOAssert.Request requests = 2;
     */
    requests: CMsgSDOAssert_Request[];
}
/**
 * @generated from protobuf message CMsgSDOAssert.Request
 */
export interface CMsgSDOAssert_Request {
    /**
     * @generated from protobuf field: repeated uint64 key = 1;
     */
    key: bigint[];
    /**
     * @generated from protobuf field: optional string requesting_job = 2;
     */
    requestingJob?: string;
}
/**
 * @generated from protobuf message CMsgSOIDOwner
 */
export interface CMsgSOIDOwner {
    /**
     * @generated from protobuf field: optional uint32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint64 id = 2;
     */
    id?: bigint;
}
/**
 * @generated from protobuf message CMsgSOSingleObject
 */
export interface CMsgSOSingleObject {
    /**
     * @generated from protobuf field: optional int32 type_id = 2;
     */
    typeId?: number;
    /**
     * @generated from protobuf field: optional bytes object_data = 3;
     */
    objectData?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 version = 4;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 5;
     */
    ownerSoid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional uint32 service_id = 6;
     */
    serviceId?: number;
}
/**
 * @generated from protobuf message CMsgSOMultipleObjects
 */
export interface CMsgSOMultipleObjects {
    /**
     * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_modified = 2;
     */
    objectsModified: CMsgSOMultipleObjects_SingleObject[];
    /**
     * @generated from protobuf field: optional fixed64 version = 3;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_added = 4;
     */
    objectsAdded: CMsgSOMultipleObjects_SingleObject[];
    /**
     * @generated from protobuf field: repeated CMsgSOMultipleObjects.SingleObject objects_removed = 5;
     */
    objectsRemoved: CMsgSOMultipleObjects_SingleObject[];
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 6;
     */
    ownerSoid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional uint32 service_id = 7;
     */
    serviceId?: number;
}
/**
 * @generated from protobuf message CMsgSOMultipleObjects.SingleObject
 */
export interface CMsgSOMultipleObjects_SingleObject {
    /**
     * @generated from protobuf field: optional int32 type_id = 1;
     */
    typeId?: number;
    /**
     * @generated from protobuf field: optional bytes object_data = 2;
     */
    objectData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribed
 */
export interface CMsgSOCacheSubscribed {
    /**
     * @generated from protobuf field: repeated CMsgSOCacheSubscribed.SubscribedType objects = 2;
     */
    objects: CMsgSOCacheSubscribed_SubscribedType[];
    /**
     * @generated from protobuf field: optional fixed64 version = 3;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 4;
     */
    ownerSoid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional uint32 service_id = 5;
     */
    serviceId?: number;
    /**
     * @generated from protobuf field: repeated uint32 service_list = 6;
     */
    serviceList: number[];
    /**
     * @generated from protobuf field: optional fixed64 sync_version = 7;
     */
    syncVersion?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribed.SubscribedType
 */
export interface CMsgSOCacheSubscribed_SubscribedType {
    /**
     * @generated from protobuf field: optional int32 type_id = 1;
     */
    typeId?: number;
    /**
     * @generated from protobuf field: repeated bytes object_data = 2;
     */
    objectData: Uint8Array[];
}
/**
 * @generated from protobuf message CMsgSOCacheSubscribedUpToDate
 */
export interface CMsgSOCacheSubscribedUpToDate {
    /**
     * @generated from protobuf field: optional fixed64 version = 1;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
     */
    ownerSoid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional uint32 service_id = 3;
     */
    serviceId?: number;
    /**
     * @generated from protobuf field: repeated uint32 service_list = 4;
     */
    serviceList: number[];
    /**
     * @generated from protobuf field: optional fixed64 sync_version = 5;
     */
    syncVersion?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheUnsubscribed
 */
export interface CMsgSOCacheUnsubscribed {
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
     */
    ownerSoid?: CMsgSOIDOwner;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscriptionCheck
 */
export interface CMsgSOCacheSubscriptionCheck {
    /**
     * @generated from protobuf field: optional fixed64 version = 2;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 3;
     */
    ownerSoid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional uint32 service_id = 4;
     */
    serviceId?: number;
    /**
     * @generated from protobuf field: repeated uint32 service_list = 5;
     */
    serviceList: number[];
    /**
     * @generated from protobuf field: optional fixed64 sync_version = 6;
     */
    syncVersion?: bigint;
}
/**
 * @generated from protobuf message CMsgSOCacheSubscriptionRefresh
 */
export interface CMsgSOCacheSubscriptionRefresh {
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner owner_soid = 2;
     */
    ownerSoid?: CMsgSOIDOwner;
}
/**
 * @generated from protobuf message CMsgSOCacheVersion
 */
export interface CMsgSOCacheVersion {
    /**
     * @generated from protobuf field: optional fixed64 version = 1;
     */
    version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCMultiplexMessage
 */
export interface CMsgGCMultiplexMessage {
    /**
     * @generated from protobuf field: optional uint32 msgtype = 1;
     */
    msgtype?: number;
    /**
     * @generated from protobuf field: optional bytes payload = 2;
     */
    payload?: Uint8Array;
    /**
     * @generated from protobuf field: repeated fixed64 steamids = 3;
     */
    steamids: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCSubGCStarting
 */
export interface CMsgGCToGCSubGCStarting {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck
 */
export interface CGCToGCMsgMasterAck {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
    /**
     * @generated from protobuf field: optional string machine_name = 3;
     */
    machineName?: string;
    /**
     * @generated from protobuf field: optional string process_name = 4;
     */
    processName?: string;
    /**
     * @generated from protobuf field: repeated CGCToGCMsgMasterAck.Process directory = 6;
     */
    directory: CGCToGCMsgMasterAck_Process[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck.Process
 */
export interface CGCToGCMsgMasterAck_Process {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
    /**
     * @generated from protobuf field: repeated uint32 type_instances = 2;
     */
    typeInstances: number[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterAck_Response
 */
export interface CGCToGCMsgMasterAck_Response {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCUniverseStartup
 */
export interface CMsgGCToGCUniverseStartup {
    /**
     * @generated from protobuf field: optional bool is_initial_startup = 1;
     */
    isInitialStartup?: boolean;
}
/**
 * @generated from protobuf message CMsgGCToGCUniverseStartupResponse
 */
export interface CMsgGCToGCUniverseStartupResponse {
    /**
     * @generated from protobuf field: optional int32 eresult = 1;
     */
    eresult?: number;
}
/**
 * @generated from protobuf message CGCToGCMsgMasterStartupComplete
 */
export interface CGCToGCMsgMasterStartupComplete {
    /**
     * @generated from protobuf field: repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;
     */
    gcInfo: CGCToGCMsgMasterStartupComplete_GCInfo[];
}
/**
 * @generated from protobuf message CGCToGCMsgMasterStartupComplete.GCInfo
 */
export interface CGCToGCMsgMasterStartupComplete_GCInfo {
    /**
     * @generated from protobuf field: optional int32 dir_index = 1;
     */
    dirIndex?: number;
    /**
     * @generated from protobuf field: optional string machine_name = 2;
     */
    machineName?: string;
}
/**
 * @generated from protobuf message CGCToGCMsgRouted
 */
export interface CGCToGCMsgRouted {
    /**
     * @generated from protobuf field: optional uint32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional fixed64 sender_id = 2;
     */
    senderId?: bigint;
    /**
     * @generated from protobuf field: optional bytes net_message = 3;
     */
    netMessage?: Uint8Array;
}
/**
 * @generated from protobuf message CGCToGCMsgRoutedReply
 */
export interface CGCToGCMsgRoutedReply {
    /**
     * @generated from protobuf field: optional uint32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional bytes net_message = 2;
     */
    netMessage?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCUpdateSubGCSessionInfo
 */
export interface CMsgGCUpdateSubGCSessionInfo {
    /**
     * @generated from protobuf field: repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;
     */
    updates: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate[];
}
/**
 * @generated from protobuf message CMsgGCUpdateSubGCSessionInfo.CMsgUpdate
 */
export interface CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 ip = 2;
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional bool trusted = 3;
     */
    trusted?: boolean;
}
/**
 * @generated from protobuf message CMsgGCRequestSubGCSessionInfo
 */
export interface CMsgGCRequestSubGCSessionInfo {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CMsgGCRequestSubGCSessionInfoResponse
 */
export interface CMsgGCRequestSubGCSessionInfoResponse {
    /**
     * @generated from protobuf field: optional fixed32 ip = 1;
     */
    ip?: number;
    /**
     * @generated from protobuf field: optional bool trusted = 2;
     */
    trusted?: boolean;
    /**
     * @generated from protobuf field: optional uint32 port = 3;
     */
    port?: number;
    /**
     * @generated from protobuf field: optional bool success = 4;
     */
    success?: boolean;
}
/**
 * @generated from protobuf message CMsgSOCacheHaveVersion
 */
export interface CMsgSOCacheHaveVersion {
    /**
     * @generated from protobuf field: optional CMsgSOIDOwner soid = 1;
     */
    soid?: CMsgSOIDOwner;
    /**
     * @generated from protobuf field: optional fixed64 version = 2;
     */
    version?: bigint;
    /**
     * @generated from protobuf field: optional uint32 service_id = 3;
     */
    serviceId?: number;
    /**
     * @generated from protobuf field: optional uint32 cached_file_version = 4;
     */
    cachedFileVersion?: number;
}
/**
 * @generated from protobuf message CMsgClientHello
 */
export interface CMsgClientHello {
    /**
     * @generated from protobuf field: optional uint32 version = 1;
     */
    version?: number;
    /**
     * @generated from protobuf field: repeated CMsgSOCacheHaveVersion socache_have_versions = 2;
     */
    socacheHaveVersions: CMsgSOCacheHaveVersion[];
    /**
     * @generated from protobuf field: optional uint32 client_session_need = 3;
     */
    clientSessionNeed?: number;
    /**
     * @generated from protobuf field: optional PartnerAccountType client_launcher = 4;
     */
    clientLauncher?: PartnerAccountType;
    /**
     * @generated from protobuf field: optional string secret_key = 5;
     */
    secretKey?: string;
    /**
     * @generated from protobuf field: optional uint32 client_language = 6;
     */
    clientLanguage?: number;
    /**
     * @generated from protobuf field: optional ESourceEngine engine = 7;
     */
    engine?: ESourceEngine;
    /**
     * @generated from protobuf field: optional bytes steamdatagram_login = 8;
     */
    steamdatagramLogin?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 platform_id = 9;
     */
    platformId?: number;
    /**
     * @generated from protobuf field: optional bytes game_msg = 10;
     */
    gameMsg?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 os_type = 11;
     */
    osType?: number;
    /**
     * @generated from protobuf field: optional uint32 render_system = 12;
     */
    renderSystem?: number;
    /**
     * @generated from protobuf field: optional uint32 render_system_req = 13;
     */
    renderSystemReq?: number;
    /**
     * @generated from protobuf field: optional uint32 screen_width = 14;
     */
    screenWidth?: number;
    /**
     * @generated from protobuf field: optional uint32 screen_height = 15;
     */
    screenHeight?: number;
    /**
     * @generated from protobuf field: optional uint32 screen_refresh = 16;
     */
    screenRefresh?: number;
    /**
     * @generated from protobuf field: optional uint32 render_width = 17;
     */
    renderWidth?: number;
    /**
     * @generated from protobuf field: optional uint32 render_height = 18;
     */
    renderHeight?: number;
    /**
     * @generated from protobuf field: optional uint32 swap_width = 19;
     */
    swapWidth?: number;
    /**
     * @generated from protobuf field: optional uint32 swap_height = 20;
     */
    swapHeight?: number;
    /**
     * @generated from protobuf field: optional bool is_steam_china = 22;
     */
    isSteamChina?: boolean;
    /**
     * @generated from protobuf field: optional bool is_steam_china_client = 24;
     */
    isSteamChinaClient?: boolean;
    /**
     * @generated from protobuf field: optional string platform_name = 23;
     */
    platformName?: string;
}
/**
 * @generated from protobuf message CMsgClientWelcome
 */
export interface CMsgClientWelcome {
    /**
     * @generated from protobuf field: optional uint32 version = 1;
     */
    version?: number;
    /**
     * @generated from protobuf field: optional bytes game_data = 2;
     */
    gameData?: Uint8Array;
    /**
     * @generated from protobuf field: repeated CMsgSOCacheSubscribed outofdate_subscribed_caches = 3;
     */
    outofdateSubscribedCaches: CMsgSOCacheSubscribed[];
    /**
     * @generated from protobuf field: repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4;
     */
    uptodateSubscribedCaches: CMsgSOCacheSubscriptionCheck[];
    /**
     * @generated from protobuf field: optional CMsgClientWelcome.Location location = 5;
     */
    location?: CMsgClientWelcome_Location;
    /**
     * @generated from protobuf field: optional uint32 gc_socache_file_version = 9;
     */
    gcSocacheFileVersion?: number;
    /**
     * @generated from protobuf field: optional string txn_country_code = 10;
     */
    txnCountryCode?: string;
    /**
     * @generated from protobuf field: optional bytes game_data2 = 11;
     */
    gameData2?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 rtime32_gc_welcome_timestamp = 12;
     */
    rtime32GcWelcomeTimestamp?: number;
    /**
     * @generated from protobuf field: optional uint32 currency = 13;
     */
    currency?: number;
    /**
     * @generated from protobuf field: optional uint32 balance = 14;
     */
    balance?: number;
    /**
     * @generated from protobuf field: optional string balance_url = 15;
     */
    balanceUrl?: string;
    /**
     * @generated from protobuf field: optional bool has_accepted_china_ssa = 16;
     */
    hasAcceptedChinaSsa?: boolean;
    /**
     * @generated from protobuf field: optional bool is_banned_steam_china = 17;
     */
    isBannedSteamChina?: boolean;
    /**
     * @generated from protobuf field: optional CExtraMsgBlock additional_welcome_msgs = 18;
     */
    additionalWelcomeMsgs?: CExtraMsgBlock;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnServerInfo steam_learn_server_info = 20;
     */
    steamLearnServerInfo?: CMsgSteamLearnServerInfo;
}
/**
 * @generated from protobuf message CMsgClientWelcome.Location
 */
export interface CMsgClientWelcome_Location {
    /**
     * @generated from protobuf field: optional float latitude = 1;
     */
    latitude?: number;
    /**
     * @generated from protobuf field: optional float longitude = 2;
     */
    longitude?: number;
    /**
     * @generated from protobuf field: optional string country = 3;
     */
    country?: string;
}
/**
 * @generated from protobuf message CMsgConnectionStatus
 */
export interface CMsgConnectionStatus {
    /**
     * @generated from protobuf field: optional GCConnectionStatus status = 1;
     */
    status?: GCConnectionStatus;
    /**
     * @generated from protobuf field: optional uint32 client_session_need = 2;
     */
    clientSessionNeed?: number;
    /**
     * @generated from protobuf field: optional int32 queue_position = 3;
     */
    queuePosition?: number;
    /**
     * @generated from protobuf field: optional int32 queue_size = 4;
     */
    queueSize?: number;
    /**
     * @generated from protobuf field: optional int32 wait_seconds = 5;
     */
    waitSeconds?: number;
    /**
     * @generated from protobuf field: optional int32 estimated_wait_seconds_remaining = 6;
     */
    estimatedWaitSecondsRemaining?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheSubscribe
 */
export interface CMsgGCToGCSOCacheSubscribe {
    /**
     * @generated from protobuf field: optional fixed64 subscriber = 1;
     */
    subscriber?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 subscribe_to_id = 2;
     */
    subscribeToId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 sync_version = 3;
     */
    syncVersion?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;
     */
    haveVersions: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions[];
    /**
     * @generated from protobuf field: optional uint32 subscribe_to_type = 5;
     */
    subscribeToType?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions
 */
export interface CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    /**
     * @generated from protobuf field: optional uint32 service_id = 1;
     */
    serviceId?: number;
    /**
     * @generated from protobuf field: optional uint64 version = 2;
     */
    version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCToGCSOCacheUnsubscribe
 */
export interface CMsgGCToGCSOCacheUnsubscribe {
    /**
     * @generated from protobuf field: optional fixed64 subscriber = 1;
     */
    subscriber?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 unsubscribe_from_id = 2;
     */
    unsubscribeFromId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 unsubscribe_from_type = 3;
     */
    unsubscribeFromType?: number;
}
/**
 * @generated from protobuf message CMsgGCClientPing
 */
export interface CMsgGCClientPing {
}
/**
 * @generated from protobuf message CMsgGCToGCForwardAccountDetails
 */
export interface CMsgGCToGCForwardAccountDetails {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional CGCSystemMsg_GetAccountDetails_Response account_details = 2;
     */
    accountDetails?: CGCSystemMsg_GetAccountDetails_Response;
    /**
     * @generated from protobuf field: optional uint32 age_seconds = 3;
     */
    ageSeconds?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCLoadSessionSOCache
 */
export interface CMsgGCToGCLoadSessionSOCache {
    /**
     * @generated from protobuf field: optional uint32 account_id = 1;
     */
    accountId?: number;
    /**
     * @generated from protobuf field: optional CMsgGCToGCForwardAccountDetails forward_account_details = 2;
     */
    forwardAccountDetails?: CMsgGCToGCForwardAccountDetails;
}
/**
 * @generated from protobuf message CMsgGCToGCLoadSessionSOCacheResponse
 */
export interface CMsgGCToGCLoadSessionSOCacheResponse {
}
/**
 * @generated from protobuf message CMsgGCToGCUpdateSessionStats
 */
export interface CMsgGCToGCUpdateSessionStats {
    /**
     * @generated from protobuf field: optional uint32 user_sessions = 1;
     */
    userSessions?: number;
    /**
     * @generated from protobuf field: optional uint32 server_sessions = 2;
     */
    serverSessions?: number;
    /**
     * @generated from protobuf field: optional bool in_logon_surge = 3;
     */
    inLogonSurge?: boolean;
}
/**
 * @generated from protobuf message CMsgGCToClientRequestDropped
 */
export interface CMsgGCToClientRequestDropped {
}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request
 */
export interface CWorkshop_PopulateItemDescriptions_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;
     */
    languages: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock[];
}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription
 */
export interface CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 1;
     */
    gameitemid?: number;
    /**
     * @generated from protobuf field: optional string item_description = 2;
     */
    itemDescription?: string;
}
/**
 * @generated from protobuf message CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock
 */
export interface CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    /**
     * @generated from protobuf field: optional string language = 1;
     */
    language?: string;
    /**
     * @generated from protobuf field: repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;
     */
    descriptions: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription[];
}
/**
 * @generated from protobuf message CWorkshop_GetContributors_Request
 */
export interface CWorkshop_GetContributors_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 2;
     */
    gameitemid?: number;
}
/**
 * @generated from protobuf message CWorkshop_GetContributors_Response
 */
export interface CWorkshop_GetContributors_Response {
    /**
     * @generated from protobuf field: repeated fixed64 contributors = 1;
     */
    contributors: bigint[];
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request
 */
export interface CWorkshop_SetItemPaymentRules_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 gameitemid = 2;
     */
    gameitemid?: number;
    /**
     * @generated from protobuf field: repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;
     */
    associatedWorkshopFiles: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule[];
    /**
     * @generated from protobuf field: repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;
     */
    partnerAccounts: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule[];
    /**
     * @generated from protobuf field: optional bool validate_only = 5;
     */
    validateOnly?: boolean;
    /**
     * @generated from protobuf field: optional bool make_workshop_files_subscribable = 6;
     */
    makeWorkshopFilesSubscribable?: boolean;
    /**
     * @generated from protobuf field: optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7;
     */
    associatedWorkshopFileForDirectPayments?: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    /**
     * @generated from protobuf field: optional uint64 workshop_file_id = 1;
     */
    workshopFileId?: bigint;
    /**
     * @generated from protobuf field: optional float revenue_percentage = 2;
     */
    revenuePercentage?: number;
    /**
     * @generated from protobuf field: optional string rule_description = 3;
     */
    ruleDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 rule_type = 4;
     */
    ruleType?: number;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
    /**
     * @generated from protobuf field: optional uint64 workshop_file_id = 1;
     */
    workshopFileId?: bigint;
    /**
     * @generated from protobuf field: optional string rule_description = 2;
     */
    ruleDescription?: string;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule
 */
export interface CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    /**
     * @generated from protobuf field: optional uint32 account_id = 1;
     */
    accountId?: number;
    /**
     * @generated from protobuf field: optional float revenue_percentage = 2;
     */
    revenuePercentage?: number;
    /**
     * @generated from protobuf field: optional string rule_description = 3;
     */
    ruleDescription?: string;
}
/**
 * @generated from protobuf message CWorkshop_SetItemPaymentRules_Response
 */
export interface CWorkshop_SetItemPaymentRules_Response {
    /**
     * @generated from protobuf field: repeated string validation_errors = 1;
     */
    validationErrors: string[];
}
/**
 * @generated from protobuf message CCommunity_ClanAnnouncementInfo
 */
export interface CCommunity_ClanAnnouncementInfo {
    /**
     * @generated from protobuf field: optional uint64 gid = 1;
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 clanid = 2;
     */
    clanid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 posterid = 3;
     */
    posterid?: bigint;
    /**
     * @generated from protobuf field: optional string headline = 4;
     */
    headline?: string;
    /**
     * @generated from protobuf field: optional uint32 posttime = 5;
     */
    posttime?: number;
    /**
     * @generated from protobuf field: optional uint32 updatetime = 6;
     */
    updatetime?: number;
    /**
     * @generated from protobuf field: optional string body = 7;
     */
    body?: string;
    /**
     * @generated from protobuf field: optional int32 commentcount = 8;
     */
    commentcount?: number;
    /**
     * @generated from protobuf field: repeated string tags = 9;
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional int32 language = 10;
     */
    language?: number;
    /**
     * @generated from protobuf field: optional bool hidden = 11;
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 forum_topic_id = 12;
     */
    forumTopicId?: bigint;
}
/**
 * @generated from protobuf message CCommunity_GetClanAnnouncements_Request
 */
export interface CCommunity_GetClanAnnouncements_Request {
    /**
     * @generated from protobuf field: optional uint64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 offset = 2;
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional uint32 count = 3;
     */
    count?: number;
    /**
     * @generated from protobuf field: optional uint32 maxchars = 4;
     */
    maxchars?: number;
    /**
     * @generated from protobuf field: optional bool strip_html = 5;
     */
    stripHtml?: boolean;
    /**
     * @generated from protobuf field: repeated string required_tags = 6;
     */
    requiredTags: string[];
    /**
     * @generated from protobuf field: optional bool require_no_tags = 7;
     */
    requireNoTags?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 language_preference = 8;
     */
    languagePreference: number[];
    /**
     * @generated from protobuf field: optional bool hidden_only = 9;
     */
    hiddenOnly?: boolean;
    /**
     * @generated from protobuf field: optional bool only_gid = 10;
     */
    onlyGid?: boolean;
    /**
     * @generated from protobuf field: optional uint32 rtime_oldest_date = 11;
     */
    rtimeOldestDate?: number;
    /**
     * @generated from protobuf field: optional bool include_hidden = 12;
     */
    includeHidden?: boolean;
    /**
     * @generated from protobuf field: optional bool include_partner_events = 13;
     */
    includePartnerEvents?: boolean;
}
/**
 * @generated from protobuf message CCommunity_GetClanAnnouncements_Response
 */
export interface CCommunity_GetClanAnnouncements_Response {
    /**
     * @generated from protobuf field: optional uint32 maxchars = 1;
     */
    maxchars?: number;
    /**
     * @generated from protobuf field: optional bool strip_html = 2;
     */
    stripHtml?: boolean;
    /**
     * @generated from protobuf field: repeated CCommunity_ClanAnnouncementInfo announcements = 3;
     */
    announcements: CCommunity_ClanAnnouncementInfo[];
}
/**
 * @generated from protobuf message CBroadcast_PostGameDataFrame_Request
 */
export interface CBroadcast_PostGameDataFrame_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 2;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 broadcast_id = 3;
     */
    broadcastId?: bigint;
    /**
     * @generated from protobuf field: optional bytes frame_data = 4;
     */
    frameData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache
 */
export interface CMsgSerializedSOCache {
    /**
     * @generated from protobuf field: optional uint32 file_version = 1;
     */
    fileVersion?: number;
    /**
     * @generated from protobuf field: repeated CMsgSerializedSOCache.Cache caches = 2;
     */
    caches: CMsgSerializedSOCache_Cache[];
    /**
     * @generated from protobuf field: optional uint32 gc_socache_file_version = 3;
     */
    gcSocacheFileVersion?: number;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.TypeCache
 */
export interface CMsgSerializedSOCache_TypeCache {
    /**
     * @generated from protobuf field: optional uint32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: repeated bytes objects = 2;
     */
    objects: Uint8Array[];
    /**
     * @generated from protobuf field: optional uint32 service_id = 3;
     */
    serviceId?: number;
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.Cache
 */
export interface CMsgSerializedSOCache_Cache {
    /**
     * @generated from protobuf field: optional uint32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint64 id = 2;
     */
    id?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgSerializedSOCache.Cache.Version versions = 3;
     */
    versions: CMsgSerializedSOCache_Cache_Version[];
    /**
     * @generated from protobuf field: repeated CMsgSerializedSOCache.TypeCache type_caches = 4;
     */
    typeCaches: CMsgSerializedSOCache_TypeCache[];
}
/**
 * @generated from protobuf message CMsgSerializedSOCache.Cache.Version
 */
export interface CMsgSerializedSOCache_Cache_Version {
    /**
     * @generated from protobuf field: optional uint32 service = 1;
     */
    service?: number;
    /**
     * @generated from protobuf field: optional uint64 version = 2;
     */
    version?: bigint;
}
/**
 * @generated from protobuf message CMsgGCToClientPollConvarRequest
 */
export interface CMsgGCToClientPollConvarRequest {
    /**
     * @generated from protobuf field: optional string convar_name = 1;
     */
    convarName?: string;
    /**
     * @generated from protobuf field: optional uint32 poll_id = 2;
     */
    pollId?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientPollConvarResponse
 */
export interface CMsgGCToClientPollConvarResponse {
    /**
     * @generated from protobuf field: optional uint32 poll_id = 1;
     */
    pollId?: number;
    /**
     * @generated from protobuf field: optional string convar_value = 2;
     */
    convarValue?: string;
}
/**
 * @generated from protobuf message CGCMsgCompressedMsgToClient
 */
export interface CGCMsgCompressedMsgToClient {
    /**
     * @generated from protobuf field: optional uint32 msg_id = 1;
     */
    msgId?: number;
    /**
     * @generated from protobuf field: optional bytes compressed_msg = 2;
     */
    compressedMsg?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterBroadcastMessage
 */
export interface CMsgGCToGCMasterBroadcastMessage {
    /**
     * @generated from protobuf field: optional uint32 users_per_second = 1;
     */
    usersPerSecond?: number;
    /**
     * @generated from protobuf field: optional bool send_to_users = 2;
     */
    sendToUsers?: boolean;
    /**
     * @generated from protobuf field: optional bool send_to_servers = 3;
     */
    sendToServers?: boolean;
    /**
     * @generated from protobuf field: optional uint32 msg_id = 4;
     */
    msgId?: number;
    /**
     * @generated from protobuf field: optional bytes msg_data = 5;
     */
    msgData?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCache
 */
export interface CMsgGCToGCMasterSubscribeToCache {
    /**
     * @generated from protobuf field: optional uint32 soid_type = 1;
     */
    soidType?: number;
    /**
     * @generated from protobuf field: optional fixed64 soid_id = 2;
     */
    soidId?: bigint;
    /**
     * @generated from protobuf field: repeated uint32 account_ids = 3;
     */
    accountIds: number[];
    /**
     * @generated from protobuf field: repeated fixed64 steam_ids = 4;
     */
    steamIds: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCacheResponse
 */
export interface CMsgGCToGCMasterSubscribeToCacheResponse {
}
/**
 * @generated from protobuf message CMsgGCToGCMasterSubscribeToCacheAsync
 */
export interface CMsgGCToGCMasterSubscribeToCacheAsync {
    /**
     * @generated from protobuf field: optional CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1;
     */
    subscribeMsg?: CMsgGCToGCMasterSubscribeToCache;
}
/**
 * @generated from protobuf message CMsgGCToGCMasterUnsubscribeFromCache
 */
export interface CMsgGCToGCMasterUnsubscribeFromCache {
    /**
     * @generated from protobuf field: optional uint32 soid_type = 1;
     */
    soidType?: number;
    /**
     * @generated from protobuf field: optional fixed64 soid_id = 2;
     */
    soidId?: bigint;
    /**
     * @generated from protobuf field: repeated uint32 account_ids = 3;
     */
    accountIds: number[];
    /**
     * @generated from protobuf field: repeated fixed64 steam_ids = 4;
     */
    steamIds: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCMasterDestroyCache
 */
export interface CMsgGCToGCMasterDestroyCache {
    /**
     * @generated from protobuf field: optional uint32 soid_type = 1;
     */
    soidType?: number;
    /**
     * @generated from protobuf field: optional fixed64 soid_id = 2;
     */
    soidId?: bigint;
}
/**
 * @generated from protobuf enum ESourceEngine
 */
export enum ESourceEngine {
    /**
     * @generated from protobuf enum value: k_ESE_Source1 = 0;
     */
    k_ESE_Source1 = 0,
    /**
     * @generated from protobuf enum value: k_ESE_Source2 = 1;
     */
    k_ESE_Source2 = 1
}
/**
 * @generated from protobuf enum PartnerAccountType
 */
export enum PartnerAccountType {
    /**
     * @generated from protobuf enum value: PARTNER_NONE = 0;
     */
    PARTNER_NONE = 0,
    /**
     * @generated from protobuf enum value: PARTNER_PERFECT_WORLD = 1;
     */
    PARTNER_PERFECT_WORLD = 1,
    /**
     * @generated from protobuf enum value: PARTNER_INVALID = 3;
     */
    PARTNER_INVALID = 3
}
/**
 * @generated from protobuf enum GCConnectionStatus
 */
export enum GCConnectionStatus {
    /**
     * @generated from protobuf enum value: GCConnectionStatus_HAVE_SESSION = 0;
     */
    GCConnectionStatus_HAVE_SESSION = 0,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_GC_GOING_DOWN = 1;
     */
    GCConnectionStatus_GC_GOING_DOWN = 1,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_NO_SESSION = 2;
     */
    GCConnectionStatus_NO_SESSION = 2,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3;
     */
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_NO_STEAM = 4;
     */
    GCConnectionStatus_NO_STEAM = 4,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_SUSPENDED = 5;
     */
    GCConnectionStatus_SUSPENDED = 5,
    /**
     * @generated from protobuf enum value: GCConnectionStatus_STEAM_GOING_DOWN = 6;
     */
    GCConnectionStatus_STEAM_GOING_DOWN = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class CExtraMsgBlock$Type extends MessageType<CExtraMsgBlock> {
    constructor() {
        super("CExtraMsgBlock", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "contents", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "msg_key", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_compressed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CExtraMsgBlock>): CExtraMsgBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CExtraMsgBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CExtraMsgBlock): CExtraMsgBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_type */ 1:
                    message.msgType = reader.uint32();
                    break;
                case /* optional bytes contents */ 2:
                    message.contents = reader.bytes();
                    break;
                case /* optional uint64 msg_key */ 3:
                    message.msgKey = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_compressed */ 4:
                    message.isCompressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CExtraMsgBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgType);
        /* optional bytes contents = 2; */
        if (message.contents !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contents);
        /* optional uint64 msg_key = 3; */
        if (message.msgKey !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.msgKey);
        /* optional bool is_compressed = 4; */
        if (message.isCompressed !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isCompressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CExtraMsgBlock
 */
export const CExtraMsgBlock = new CExtraMsgBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnServerInfo$Type extends MessageType<CMsgSteamLearnServerInfo> {
    constructor() {
        super("CMsgSteamLearnServerInfo", [
            { no: 4, name: "access_tokens", kind: "message", T: () => CMsgSteamLearnAccessTokens },
            { no: 5, name: "project_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnServerInfo_ProjectInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnServerInfo>): CMsgSteamLearnServerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.projectInfos = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnServerInfo): CMsgSteamLearnServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamLearnAccessTokens access_tokens */ 4:
                    message.accessTokens = CMsgSteamLearnAccessTokens.internalBinaryRead(reader, reader.uint32(), options, message.accessTokens);
                    break;
                case /* repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos */ 5:
                    message.projectInfos.push(CMsgSteamLearnServerInfo_ProjectInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamLearnAccessTokens access_tokens = 4; */
        if (message.accessTokens)
            CMsgSteamLearnAccessTokens.internalBinaryWrite(message.accessTokens, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearnServerInfo.ProjectInfo project_infos = 5; */
        for (let i = 0; i < message.projectInfos.length; i++)
            CMsgSteamLearnServerInfo_ProjectInfo.internalBinaryWrite(message.projectInfos[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnServerInfo
 */
export const CMsgSteamLearnServerInfo = new CMsgSteamLearnServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnServerInfo_ProjectInfo$Type extends MessageType<CMsgSteamLearnServerInfo_ProjectInfo> {
    constructor() {
        super("CMsgSteamLearnServerInfo.ProjectInfo", [
            { no: 1, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "snapshot_published_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "inference_published_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "snapshot_percentage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "snapshot_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnServerInfo_ProjectInfo>): CMsgSteamLearnServerInfo_ProjectInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnServerInfo_ProjectInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnServerInfo_ProjectInfo): CMsgSteamLearnServerInfo_ProjectInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 project_id */ 1:
                    message.projectId = reader.uint32();
                    break;
                case /* optional uint32 snapshot_published_version */ 2:
                    message.snapshotPublishedVersion = reader.uint32();
                    break;
                case /* optional uint32 inference_published_version */ 3:
                    message.inferencePublishedVersion = reader.uint32();
                    break;
                case /* optional uint32 snapshot_percentage */ 6:
                    message.snapshotPercentage = reader.uint32();
                    break;
                case /* optional bool snapshot_enabled */ 7:
                    message.snapshotEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnServerInfo_ProjectInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 project_id = 1; */
        if (message.projectId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.projectId);
        /* optional uint32 snapshot_published_version = 2; */
        if (message.snapshotPublishedVersion !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.snapshotPublishedVersion);
        /* optional uint32 inference_published_version = 3; */
        if (message.inferencePublishedVersion !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.inferencePublishedVersion);
        /* optional uint32 snapshot_percentage = 6; */
        if (message.snapshotPercentage !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.snapshotPercentage);
        /* optional bool snapshot_enabled = 7; */
        if (message.snapshotEnabled !== undefined)
            writer.tag(7, WireType.Varint).bool(message.snapshotEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnServerInfo.ProjectInfo
 */
export const CMsgSteamLearnServerInfo_ProjectInfo = new CMsgSteamLearnServerInfo_ProjectInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCAssertJobData$Type extends MessageType<CMsgGCAssertJobData> {
    constructor() {
        super("CMsgGCAssertJobData", [
            { no: 1, name: "message_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCAssertJobData>): CMsgGCAssertJobData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCAssertJobData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCAssertJobData): CMsgGCAssertJobData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string message_type */ 1:
                    message.messageType = reader.string();
                    break;
                case /* optional bytes message_data */ 2:
                    message.messageData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCAssertJobData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string message_type = 1; */
        if (message.messageType !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.messageType);
        /* optional bytes message_data = 2; */
        if (message.messageData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.messageData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCAssertJobData
 */
export const CMsgGCAssertJobData = new CMsgGCAssertJobData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCConCommand$Type extends MessageType<CMsgGCConCommand> {
    constructor() {
        super("CMsgGCConCommand", [
            { no: 1, name: "command", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCConCommand>): CMsgGCConCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCConCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCConCommand): CMsgGCConCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string command */ 1:
                    message.command = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCConCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string command = 1; */
        if (message.command !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCConCommand
 */
export const CMsgGCConCommand = new CMsgGCConCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDOAssert$Type extends MessageType<CMsgSDOAssert> {
    constructor() {
        super("CMsgSDOAssert", [
            { no: 1, name: "sdo_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSDOAssert_Request }
        ]);
    }
    create(value?: PartialMessage<CMsgSDOAssert>): CMsgSDOAssert {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSDOAssert>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSDOAssert): CMsgSDOAssert {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sdo_type */ 1:
                    message.sdoType = reader.int32();
                    break;
                case /* repeated CMsgSDOAssert.Request requests */ 2:
                    message.requests.push(CMsgSDOAssert_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSDOAssert, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 sdo_type = 1; */
        if (message.sdoType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sdoType);
        /* repeated CMsgSDOAssert.Request requests = 2; */
        for (let i = 0; i < message.requests.length; i++)
            CMsgSDOAssert_Request.internalBinaryWrite(message.requests[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSDOAssert
 */
export const CMsgSDOAssert = new CMsgSDOAssert$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDOAssert_Request$Type extends MessageType<CMsgSDOAssert_Request> {
    constructor() {
        super("CMsgSDOAssert.Request", [
            { no: 1, name: "key", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "requesting_job", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSDOAssert_Request>): CMsgSDOAssert_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSDOAssert_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSDOAssert_Request): CMsgSDOAssert_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 key */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.key.push(reader.uint64().toBigInt());
                    else
                        message.key.push(reader.uint64().toBigInt());
                    break;
                case /* optional string requesting_job */ 2:
                    message.requestingJob = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSDOAssert_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 key = 1; */
        for (let i = 0; i < message.key.length; i++)
            writer.tag(1, WireType.Varint).uint64(message.key[i]);
        /* optional string requesting_job = 2; */
        if (message.requestingJob !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.requestingJob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSDOAssert.Request
 */
export const CMsgSDOAssert_Request = new CMsgSDOAssert_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOIDOwner$Type extends MessageType<CMsgSOIDOwner> {
    constructor() {
        super("CMsgSOIDOwner", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOIDOwner>): CMsgSOIDOwner {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOIDOwner>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOIDOwner): CMsgSOIDOwner {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* optional uint64 id */ 2:
                    message.id = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOIDOwner, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* optional uint64 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOIDOwner
 */
export const CMsgSOIDOwner = new CMsgSOIDOwner$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOSingleObject$Type extends MessageType<CMsgSOSingleObject> {
    constructor() {
        super("CMsgSOSingleObject", [
            { no: 2, name: "type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "object_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 6, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOSingleObject>): CMsgSOSingleObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOSingleObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOSingleObject): CMsgSOSingleObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type_id */ 2:
                    message.typeId = reader.int32();
                    break;
                case /* optional bytes object_data */ 3:
                    message.objectData = reader.bytes();
                    break;
                case /* optional fixed64 version */ 4:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgSOIDOwner owner_soid */ 5:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                case /* optional uint32 service_id */ 6:
                    message.serviceId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOSingleObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type_id = 2; */
        if (message.typeId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.typeId);
        /* optional bytes object_data = 3; */
        if (message.objectData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.objectData);
        /* optional fixed64 version = 4; */
        if (message.version !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.version);
        /* optional CMsgSOIDOwner owner_soid = 5; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 service_id = 6; */
        if (message.serviceId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.serviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOSingleObject
 */
export const CMsgSOSingleObject = new CMsgSOSingleObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOMultipleObjects$Type extends MessageType<CMsgSOMultipleObjects> {
    constructor() {
        super("CMsgSOMultipleObjects", [
            { no: 2, name: "objects_modified", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOMultipleObjects_SingleObject },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "objects_added", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOMultipleObjects_SingleObject },
            { no: 5, name: "objects_removed", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOMultipleObjects_SingleObject },
            { no: 6, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 7, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOMultipleObjects>): CMsgSOMultipleObjects {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectsModified = [];
        message.objectsAdded = [];
        message.objectsRemoved = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSOMultipleObjects>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOMultipleObjects): CMsgSOMultipleObjects {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSOMultipleObjects.SingleObject objects_modified */ 2:
                    message.objectsModified.push(CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional fixed64 version */ 3:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* repeated CMsgSOMultipleObjects.SingleObject objects_added */ 4:
                    message.objectsAdded.push(CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSOMultipleObjects.SingleObject objects_removed */ 5:
                    message.objectsRemoved.push(CMsgSOMultipleObjects_SingleObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional CMsgSOIDOwner owner_soid */ 6:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                case /* optional uint32 service_id */ 7:
                    message.serviceId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOMultipleObjects, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSOMultipleObjects.SingleObject objects_modified = 2; */
        for (let i = 0; i < message.objectsModified.length; i++)
            CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(message.objectsModified[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.version);
        /* repeated CMsgSOMultipleObjects.SingleObject objects_added = 4; */
        for (let i = 0; i < message.objectsAdded.length; i++)
            CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(message.objectsAdded[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSOMultipleObjects.SingleObject objects_removed = 5; */
        for (let i = 0; i < message.objectsRemoved.length; i++)
            CMsgSOMultipleObjects_SingleObject.internalBinaryWrite(message.objectsRemoved[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSOIDOwner owner_soid = 6; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 service_id = 7; */
        if (message.serviceId !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.serviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOMultipleObjects
 */
export const CMsgSOMultipleObjects = new CMsgSOMultipleObjects$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOMultipleObjects_SingleObject$Type extends MessageType<CMsgSOMultipleObjects_SingleObject> {
    constructor() {
        super("CMsgSOMultipleObjects.SingleObject", [
            { no: 1, name: "type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "object_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ], { msgpool_soft_limit: 256, msgpool_hard_limit: 1024 });
    }
    create(value?: PartialMessage<CMsgSOMultipleObjects_SingleObject>): CMsgSOMultipleObjects_SingleObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOMultipleObjects_SingleObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOMultipleObjects_SingleObject): CMsgSOMultipleObjects_SingleObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* optional bytes object_data */ 2:
                    message.objectData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOMultipleObjects_SingleObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type_id = 1; */
        if (message.typeId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* optional bytes object_data = 2; */
        if (message.objectData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.objectData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOMultipleObjects.SingleObject
 */
export const CMsgSOMultipleObjects_SingleObject = new CMsgSOMultipleObjects_SingleObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribed$Type extends MessageType<CMsgSOCacheSubscribed> {
    constructor() {
        super("CMsgSOCacheSubscribed", [
            { no: 2, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOCacheSubscribed_SubscribedType },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 5, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "service_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "sync_version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheSubscribed>): CMsgSOCacheSubscribed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objects = [];
        message.serviceList = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheSubscribed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheSubscribed): CMsgSOCacheSubscribed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSOCacheSubscribed.SubscribedType objects */ 2:
                    message.objects.push(CMsgSOCacheSubscribed_SubscribedType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional fixed64 version */ 3:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgSOIDOwner owner_soid */ 4:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                case /* optional uint32 service_id */ 5:
                    message.serviceId = reader.uint32();
                    break;
                case /* repeated uint32 service_list */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.serviceList.push(reader.uint32());
                    else
                        message.serviceList.push(reader.uint32());
                    break;
                case /* optional fixed64 sync_version */ 7:
                    message.syncVersion = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheSubscribed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSOCacheSubscribed.SubscribedType objects = 2; */
        for (let i = 0; i < message.objects.length; i++)
            CMsgSOCacheSubscribed_SubscribedType.internalBinaryWrite(message.objects[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.version);
        /* optional CMsgSOIDOwner owner_soid = 4; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 service_id = 5; */
        if (message.serviceId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.serviceId);
        /* repeated uint32 service_list = 6; */
        for (let i = 0; i < message.serviceList.length; i++)
            writer.tag(6, WireType.Varint).uint32(message.serviceList[i]);
        /* optional fixed64 sync_version = 7; */
        if (message.syncVersion !== undefined)
            writer.tag(7, WireType.Bit64).fixed64(message.syncVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribed
 */
export const CMsgSOCacheSubscribed = new CMsgSOCacheSubscribed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribed_SubscribedType$Type extends MessageType<CMsgSOCacheSubscribed_SubscribedType> {
    constructor() {
        super("CMsgSOCacheSubscribed.SubscribedType", [
            { no: 1, name: "type_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "object_data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheSubscribed_SubscribedType>): CMsgSOCacheSubscribed_SubscribedType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectData = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheSubscribed_SubscribedType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheSubscribed_SubscribedType): CMsgSOCacheSubscribed_SubscribedType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type_id */ 1:
                    message.typeId = reader.int32();
                    break;
                case /* repeated bytes object_data */ 2:
                    message.objectData.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheSubscribed_SubscribedType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type_id = 1; */
        if (message.typeId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.typeId);
        /* repeated bytes object_data = 2; */
        for (let i = 0; i < message.objectData.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.objectData[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribed.SubscribedType
 */
export const CMsgSOCacheSubscribed_SubscribedType = new CMsgSOCacheSubscribed_SubscribedType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscribedUpToDate$Type extends MessageType<CMsgSOCacheSubscribedUpToDate> {
    constructor() {
        super("CMsgSOCacheSubscribedUpToDate", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 3, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "service_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sync_version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheSubscribedUpToDate>): CMsgSOCacheSubscribedUpToDate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceList = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheSubscribedUpToDate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheSubscribedUpToDate): CMsgSOCacheSubscribedUpToDate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 version */ 1:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgSOIDOwner owner_soid */ 2:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                case /* optional uint32 service_id */ 3:
                    message.serviceId = reader.uint32();
                    break;
                case /* repeated uint32 service_list */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.serviceList.push(reader.uint32());
                    else
                        message.serviceList.push(reader.uint32());
                    break;
                case /* optional fixed64 sync_version */ 5:
                    message.syncVersion = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheSubscribedUpToDate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.version);
        /* optional CMsgSOIDOwner owner_soid = 2; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 service_id = 3; */
        if (message.serviceId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.serviceId);
        /* repeated uint32 service_list = 4; */
        for (let i = 0; i < message.serviceList.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.serviceList[i]);
        /* optional fixed64 sync_version = 5; */
        if (message.syncVersion !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.syncVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscribedUpToDate
 */
export const CMsgSOCacheSubscribedUpToDate = new CMsgSOCacheSubscribedUpToDate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheUnsubscribed$Type extends MessageType<CMsgSOCacheUnsubscribed> {
    constructor() {
        super("CMsgSOCacheUnsubscribed", [
            { no: 2, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheUnsubscribed>): CMsgSOCacheUnsubscribed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheUnsubscribed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheUnsubscribed): CMsgSOCacheUnsubscribed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSOIDOwner owner_soid */ 2:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheUnsubscribed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSOIDOwner owner_soid = 2; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheUnsubscribed
 */
export const CMsgSOCacheUnsubscribed = new CMsgSOCacheUnsubscribed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscriptionCheck$Type extends MessageType<CMsgSOCacheSubscriptionCheck> {
    constructor() {
        super("CMsgSOCacheSubscriptionCheck", [
            { no: 2, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 4, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "service_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sync_version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheSubscriptionCheck>): CMsgSOCacheSubscriptionCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceList = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheSubscriptionCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheSubscriptionCheck): CMsgSOCacheSubscriptionCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 version */ 2:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgSOIDOwner owner_soid */ 3:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                case /* optional uint32 service_id */ 4:
                    message.serviceId = reader.uint32();
                    break;
                case /* repeated uint32 service_list */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.serviceList.push(reader.uint32());
                    else
                        message.serviceList.push(reader.uint32());
                    break;
                case /* optional fixed64 sync_version */ 6:
                    message.syncVersion = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheSubscriptionCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 version = 2; */
        if (message.version !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.version);
        /* optional CMsgSOIDOwner owner_soid = 3; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 service_id = 4; */
        if (message.serviceId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.serviceId);
        /* repeated uint32 service_list = 5; */
        for (let i = 0; i < message.serviceList.length; i++)
            writer.tag(5, WireType.Varint).uint32(message.serviceList[i]);
        /* optional fixed64 sync_version = 6; */
        if (message.syncVersion !== undefined)
            writer.tag(6, WireType.Bit64).fixed64(message.syncVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscriptionCheck
 */
export const CMsgSOCacheSubscriptionCheck = new CMsgSOCacheSubscriptionCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheSubscriptionRefresh$Type extends MessageType<CMsgSOCacheSubscriptionRefresh> {
    constructor() {
        super("CMsgSOCacheSubscriptionRefresh", [
            { no: 2, name: "owner_soid", kind: "message", T: () => CMsgSOIDOwner }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheSubscriptionRefresh>): CMsgSOCacheSubscriptionRefresh {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheSubscriptionRefresh>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheSubscriptionRefresh): CMsgSOCacheSubscriptionRefresh {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSOIDOwner owner_soid */ 2:
                    message.ownerSoid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.ownerSoid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheSubscriptionRefresh, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSOIDOwner owner_soid = 2; */
        if (message.ownerSoid)
            CMsgSOIDOwner.internalBinaryWrite(message.ownerSoid, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheSubscriptionRefresh
 */
export const CMsgSOCacheSubscriptionRefresh = new CMsgSOCacheSubscriptionRefresh$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheVersion$Type extends MessageType<CMsgSOCacheVersion> {
    constructor() {
        super("CMsgSOCacheVersion", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheVersion>): CMsgSOCacheVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheVersion): CMsgSOCacheVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 version */ 1:
                    message.version = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheVersion
 */
export const CMsgSOCacheVersion = new CMsgSOCacheVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCMultiplexMessage$Type extends MessageType<CMsgGCMultiplexMessage> {
    constructor() {
        super("CMsgGCMultiplexMessage", [
            { no: 1, name: "msgtype", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "payload", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "steamids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCMultiplexMessage>): CMsgGCMultiplexMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steamids = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCMultiplexMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCMultiplexMessage): CMsgGCMultiplexMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msgtype */ 1:
                    message.msgtype = reader.uint32();
                    break;
                case /* optional bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                case /* repeated fixed64 steamids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamids.push(reader.fixed64().toBigInt());
                    else
                        message.steamids.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCMultiplexMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msgtype = 1; */
        if (message.msgtype !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgtype);
        /* optional bytes payload = 2; */
        if (message.payload !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        /* repeated fixed64 steamids = 3; */
        for (let i = 0; i < message.steamids.length; i++)
            writer.tag(3, WireType.Bit64).fixed64(message.steamids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCMultiplexMessage
 */
export const CMsgGCMultiplexMessage = new CMsgGCMultiplexMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSubGCStarting$Type extends MessageType<CMsgGCToGCSubGCStarting> {
    constructor() {
        super("CMsgGCToGCSubGCStarting", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCSubGCStarting>): CMsgGCToGCSubGCStarting {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCSubGCStarting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCSubGCStarting): CMsgGCToGCSubGCStarting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCSubGCStarting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSubGCStarting
 */
export const CMsgGCToGCSubGCStarting = new CMsgGCToGCSubGCStarting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck$Type extends MessageType<CGCToGCMsgMasterAck> {
    constructor() {
        super("CGCToGCMsgMasterAck", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "process_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "directory", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCToGCMsgMasterAck_Process }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgMasterAck>): CGCToGCMsgMasterAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.directory = [];
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgMasterAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgMasterAck): CGCToGCMsgMasterAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                case /* optional string machine_name */ 3:
                    message.machineName = reader.string();
                    break;
                case /* optional string process_name */ 4:
                    message.processName = reader.string();
                    break;
                case /* repeated CGCToGCMsgMasterAck.Process directory */ 6:
                    message.directory.push(CGCToGCMsgMasterAck_Process.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgMasterAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        /* optional string machine_name = 3; */
        if (message.machineName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.machineName);
        /* optional string process_name = 4; */
        if (message.processName !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.processName);
        /* repeated CGCToGCMsgMasterAck.Process directory = 6; */
        for (let i = 0; i < message.directory.length; i++)
            CGCToGCMsgMasterAck_Process.internalBinaryWrite(message.directory[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck
 */
export const CGCToGCMsgMasterAck = new CGCToGCMsgMasterAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck_Process$Type extends MessageType<CGCToGCMsgMasterAck_Process> {
    constructor() {
        super("CGCToGCMsgMasterAck.Process", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_instances", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgMasterAck_Process>): CGCToGCMsgMasterAck_Process {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeInstances = [];
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgMasterAck_Process>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgMasterAck_Process): CGCToGCMsgMasterAck_Process {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                case /* repeated uint32 type_instances */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.typeInstances.push(reader.uint32());
                    else
                        message.typeInstances.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgMasterAck_Process, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        /* repeated uint32 type_instances = 2; */
        for (let i = 0; i < message.typeInstances.length; i++)
            writer.tag(2, WireType.Varint).uint32(message.typeInstances[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck.Process
 */
export const CGCToGCMsgMasterAck_Process = new CGCToGCMsgMasterAck_Process$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterAck_Response$Type extends MessageType<CGCToGCMsgMasterAck_Response> {
    constructor() {
        super("CGCToGCMsgMasterAck_Response", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgMasterAck_Response>): CGCToGCMsgMasterAck_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgMasterAck_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgMasterAck_Response): CGCToGCMsgMasterAck_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgMasterAck_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterAck_Response
 */
export const CGCToGCMsgMasterAck_Response = new CGCToGCMsgMasterAck_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUniverseStartup$Type extends MessageType<CMsgGCToGCUniverseStartup> {
    constructor() {
        super("CMsgGCToGCUniverseStartup", [
            { no: 1, name: "is_initial_startup", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCUniverseStartup>): CMsgGCToGCUniverseStartup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCUniverseStartup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCUniverseStartup): CMsgGCToGCUniverseStartup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_initial_startup */ 1:
                    message.isInitialStartup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCUniverseStartup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_initial_startup = 1; */
        if (message.isInitialStartup !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isInitialStartup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUniverseStartup
 */
export const CMsgGCToGCUniverseStartup = new CMsgGCToGCUniverseStartup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUniverseStartupResponse$Type extends MessageType<CMsgGCToGCUniverseStartupResponse> {
    constructor() {
        super("CMsgGCToGCUniverseStartupResponse", [
            { no: 1, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCUniverseStartupResponse>): CMsgGCToGCUniverseStartupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCUniverseStartupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCUniverseStartupResponse): CMsgGCToGCUniverseStartupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eresult */ 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCUniverseStartupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eresult = 1; */
        if (message.eresult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eresult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUniverseStartupResponse
 */
export const CMsgGCToGCUniverseStartupResponse = new CMsgGCToGCUniverseStartupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterStartupComplete$Type extends MessageType<CGCToGCMsgMasterStartupComplete> {
    constructor() {
        super("CGCToGCMsgMasterStartupComplete", [
            { no: 1, name: "gc_info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CGCToGCMsgMasterStartupComplete_GCInfo }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgMasterStartupComplete>): CGCToGCMsgMasterStartupComplete {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gcInfo = [];
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgMasterStartupComplete>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgMasterStartupComplete): CGCToGCMsgMasterStartupComplete {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info */ 1:
                    message.gcInfo.push(CGCToGCMsgMasterStartupComplete_GCInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgMasterStartupComplete, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1; */
        for (let i = 0; i < message.gcInfo.length; i++)
            CGCToGCMsgMasterStartupComplete_GCInfo.internalBinaryWrite(message.gcInfo[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterStartupComplete
 */
export const CGCToGCMsgMasterStartupComplete = new CGCToGCMsgMasterStartupComplete$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgMasterStartupComplete_GCInfo$Type extends MessageType<CGCToGCMsgMasterStartupComplete_GCInfo> {
    constructor() {
        super("CGCToGCMsgMasterStartupComplete.GCInfo", [
            { no: 1, name: "dir_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "machine_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgMasterStartupComplete_GCInfo>): CGCToGCMsgMasterStartupComplete_GCInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgMasterStartupComplete_GCInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgMasterStartupComplete_GCInfo): CGCToGCMsgMasterStartupComplete_GCInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dir_index */ 1:
                    message.dirIndex = reader.int32();
                    break;
                case /* optional string machine_name */ 2:
                    message.machineName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgMasterStartupComplete_GCInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dir_index = 1; */
        if (message.dirIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dirIndex);
        /* optional string machine_name = 2; */
        if (message.machineName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.machineName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgMasterStartupComplete.GCInfo
 */
export const CGCToGCMsgMasterStartupComplete_GCInfo = new CGCToGCMsgMasterStartupComplete_GCInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgRouted$Type extends MessageType<CGCToGCMsgRouted> {
    constructor() {
        super("CGCToGCMsgRouted", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sender_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "net_message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgRouted>): CGCToGCMsgRouted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgRouted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgRouted): CGCToGCMsgRouted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_type */ 1:
                    message.msgType = reader.uint32();
                    break;
                case /* optional fixed64 sender_id */ 2:
                    message.senderId = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes net_message */ 3:
                    message.netMessage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgRouted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgType);
        /* optional fixed64 sender_id = 2; */
        if (message.senderId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.senderId);
        /* optional bytes net_message = 3; */
        if (message.netMessage !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.netMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgRouted
 */
export const CGCToGCMsgRouted = new CGCToGCMsgRouted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCToGCMsgRoutedReply$Type extends MessageType<CGCToGCMsgRoutedReply> {
    constructor() {
        super("CGCToGCMsgRoutedReply", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "net_message", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCToGCMsgRoutedReply>): CGCToGCMsgRoutedReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCToGCMsgRoutedReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCToGCMsgRoutedReply): CGCToGCMsgRoutedReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_type */ 1:
                    message.msgType = reader.uint32();
                    break;
                case /* optional bytes net_message */ 2:
                    message.netMessage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCToGCMsgRoutedReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgType);
        /* optional bytes net_message = 2; */
        if (message.netMessage !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.netMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCToGCMsgRoutedReply
 */
export const CGCToGCMsgRoutedReply = new CGCToGCMsgRoutedReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCUpdateSubGCSessionInfo$Type extends MessageType<CMsgGCUpdateSubGCSessionInfo> {
    constructor() {
        super("CMsgGCUpdateSubGCSessionInfo", [
            { no: 1, name: "updates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCUpdateSubGCSessionInfo_CMsgUpdate }
        ]);
    }
    create(value?: PartialMessage<CMsgGCUpdateSubGCSessionInfo>): CMsgGCUpdateSubGCSessionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCUpdateSubGCSessionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCUpdateSubGCSessionInfo): CMsgGCUpdateSubGCSessionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates */ 1:
                    message.updates.push(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCUpdateSubGCSessionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            CMsgGCUpdateSubGCSessionInfo_CMsgUpdate.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCUpdateSubGCSessionInfo
 */
export const CMsgGCUpdateSubGCSessionInfo = new CMsgGCUpdateSubGCSessionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCUpdateSubGCSessionInfo_CMsgUpdate$Type extends MessageType<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> {
    constructor() {
        super("CMsgGCUpdateSubGCSessionInfo.CMsgUpdate", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "trusted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate): CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 ip */ 2:
                    message.ip = reader.fixed32();
                    break;
                case /* optional bool trusted */ 3:
                    message.trusted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCUpdateSubGCSessionInfo_CMsgUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional fixed32 ip = 2; */
        if (message.ip !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.ip);
        /* optional bool trusted = 3; */
        if (message.trusted !== undefined)
            writer.tag(3, WireType.Varint).bool(message.trusted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCUpdateSubGCSessionInfo.CMsgUpdate
 */
export const CMsgGCUpdateSubGCSessionInfo_CMsgUpdate = new CMsgGCUpdateSubGCSessionInfo_CMsgUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRequestSubGCSessionInfo$Type extends MessageType<CMsgGCRequestSubGCSessionInfo> {
    constructor() {
        super("CMsgGCRequestSubGCSessionInfo", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCRequestSubGCSessionInfo>): CMsgGCRequestSubGCSessionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCRequestSubGCSessionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCRequestSubGCSessionInfo): CMsgGCRequestSubGCSessionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCRequestSubGCSessionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCRequestSubGCSessionInfo
 */
export const CMsgGCRequestSubGCSessionInfo = new CMsgGCRequestSubGCSessionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCRequestSubGCSessionInfoResponse$Type extends MessageType<CMsgGCRequestSubGCSessionInfoResponse> {
    constructor() {
        super("CMsgGCRequestSubGCSessionInfoResponse", [
            { no: 1, name: "ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "trusted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCRequestSubGCSessionInfoResponse>): CMsgGCRequestSubGCSessionInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCRequestSubGCSessionInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCRequestSubGCSessionInfoResponse): CMsgGCRequestSubGCSessionInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 ip */ 1:
                    message.ip = reader.fixed32();
                    break;
                case /* optional bool trusted */ 2:
                    message.trusted = reader.bool();
                    break;
                case /* optional uint32 port */ 3:
                    message.port = reader.uint32();
                    break;
                case /* optional bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCRequestSubGCSessionInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 ip = 1; */
        if (message.ip !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.ip);
        /* optional bool trusted = 2; */
        if (message.trusted !== undefined)
            writer.tag(2, WireType.Varint).bool(message.trusted);
        /* optional uint32 port = 3; */
        if (message.port !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.port);
        /* optional bool success = 4; */
        if (message.success !== undefined)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCRequestSubGCSessionInfoResponse
 */
export const CMsgGCRequestSubGCSessionInfoResponse = new CMsgGCRequestSubGCSessionInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSOCacheHaveVersion$Type extends MessageType<CMsgSOCacheHaveVersion> {
    constructor() {
        super("CMsgSOCacheHaveVersion", [
            { no: 1, name: "soid", kind: "message", T: () => CMsgSOIDOwner },
            { no: 2, name: "version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cached_file_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSOCacheHaveVersion>): CMsgSOCacheHaveVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSOCacheHaveVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSOCacheHaveVersion): CMsgSOCacheHaveVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSOIDOwner soid */ 1:
                    message.soid = CMsgSOIDOwner.internalBinaryRead(reader, reader.uint32(), options, message.soid);
                    break;
                case /* optional fixed64 version */ 2:
                    message.version = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 service_id */ 3:
                    message.serviceId = reader.uint32();
                    break;
                case /* optional uint32 cached_file_version */ 4:
                    message.cachedFileVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSOCacheHaveVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSOIDOwner soid = 1; */
        if (message.soid)
            CMsgSOIDOwner.internalBinaryWrite(message.soid, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 version = 2; */
        if (message.version !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.version);
        /* optional uint32 service_id = 3; */
        if (message.serviceId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.serviceId);
        /* optional uint32 cached_file_version = 4; */
        if (message.cachedFileVersion !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cachedFileVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSOCacheHaveVersion
 */
export const CMsgSOCacheHaveVersion = new CMsgSOCacheHaveVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientHello$Type extends MessageType<CMsgClientHello> {
    constructor() {
        super("CMsgClientHello", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "socache_have_versions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOCacheHaveVersion },
            { no: 3, name: "client_session_need", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "client_launcher", kind: "enum", opt: true, T: () => ["PartnerAccountType", PartnerAccountType] },
            { no: 5, name: "secret_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "client_language", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "engine", kind: "enum", opt: true, T: () => ["ESourceEngine", ESourceEngine] },
            { no: 8, name: "steamdatagram_login", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "platform_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "game_msg", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "os_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "render_system", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "render_system_req", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "screen_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "screen_height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "screen_refresh", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "render_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "render_height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "swap_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "swap_height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "is_steam_china", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "is_steam_china_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "platform_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientHello>): CMsgClientHello {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socacheHaveVersions = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientHello>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientHello): CMsgClientHello {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* repeated CMsgSOCacheHaveVersion socache_have_versions */ 2:
                    message.socacheHaveVersions.push(CMsgSOCacheHaveVersion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 client_session_need */ 3:
                    message.clientSessionNeed = reader.uint32();
                    break;
                case /* optional PartnerAccountType client_launcher */ 4:
                    message.clientLauncher = reader.int32();
                    break;
                case /* optional string secret_key */ 5:
                    message.secretKey = reader.string();
                    break;
                case /* optional uint32 client_language */ 6:
                    message.clientLanguage = reader.uint32();
                    break;
                case /* optional ESourceEngine engine */ 7:
                    message.engine = reader.int32();
                    break;
                case /* optional bytes steamdatagram_login */ 8:
                    message.steamdatagramLogin = reader.bytes();
                    break;
                case /* optional uint32 platform_id */ 9:
                    message.platformId = reader.uint32();
                    break;
                case /* optional bytes game_msg */ 10:
                    message.gameMsg = reader.bytes();
                    break;
                case /* optional int32 os_type */ 11:
                    message.osType = reader.int32();
                    break;
                case /* optional uint32 render_system */ 12:
                    message.renderSystem = reader.uint32();
                    break;
                case /* optional uint32 render_system_req */ 13:
                    message.renderSystemReq = reader.uint32();
                    break;
                case /* optional uint32 screen_width */ 14:
                    message.screenWidth = reader.uint32();
                    break;
                case /* optional uint32 screen_height */ 15:
                    message.screenHeight = reader.uint32();
                    break;
                case /* optional uint32 screen_refresh */ 16:
                    message.screenRefresh = reader.uint32();
                    break;
                case /* optional uint32 render_width */ 17:
                    message.renderWidth = reader.uint32();
                    break;
                case /* optional uint32 render_height */ 18:
                    message.renderHeight = reader.uint32();
                    break;
                case /* optional uint32 swap_width */ 19:
                    message.swapWidth = reader.uint32();
                    break;
                case /* optional uint32 swap_height */ 20:
                    message.swapHeight = reader.uint32();
                    break;
                case /* optional bool is_steam_china */ 22:
                    message.isSteamChina = reader.bool();
                    break;
                case /* optional bool is_steam_china_client */ 24:
                    message.isSteamChinaClient = reader.bool();
                    break;
                case /* optional string platform_name */ 23:
                    message.platformName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientHello, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* repeated CMsgSOCacheHaveVersion socache_have_versions = 2; */
        for (let i = 0; i < message.socacheHaveVersions.length; i++)
            CMsgSOCacheHaveVersion.internalBinaryWrite(message.socacheHaveVersions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 client_session_need = 3; */
        if (message.clientSessionNeed !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.clientSessionNeed);
        /* optional PartnerAccountType client_launcher = 4; */
        if (message.clientLauncher !== undefined)
            writer.tag(4, WireType.Varint).int32(message.clientLauncher);
        /* optional string secret_key = 5; */
        if (message.secretKey !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.secretKey);
        /* optional uint32 client_language = 6; */
        if (message.clientLanguage !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.clientLanguage);
        /* optional ESourceEngine engine = 7; */
        if (message.engine !== undefined)
            writer.tag(7, WireType.Varint).int32(message.engine);
        /* optional bytes steamdatagram_login = 8; */
        if (message.steamdatagramLogin !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.steamdatagramLogin);
        /* optional uint32 platform_id = 9; */
        if (message.platformId !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.platformId);
        /* optional bytes game_msg = 10; */
        if (message.gameMsg !== undefined)
            writer.tag(10, WireType.LengthDelimited).bytes(message.gameMsg);
        /* optional int32 os_type = 11; */
        if (message.osType !== undefined)
            writer.tag(11, WireType.Varint).int32(message.osType);
        /* optional uint32 render_system = 12; */
        if (message.renderSystem !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.renderSystem);
        /* optional uint32 render_system_req = 13; */
        if (message.renderSystemReq !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.renderSystemReq);
        /* optional uint32 screen_width = 14; */
        if (message.screenWidth !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.screenWidth);
        /* optional uint32 screen_height = 15; */
        if (message.screenHeight !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.screenHeight);
        /* optional uint32 screen_refresh = 16; */
        if (message.screenRefresh !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.screenRefresh);
        /* optional uint32 render_width = 17; */
        if (message.renderWidth !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.renderWidth);
        /* optional uint32 render_height = 18; */
        if (message.renderHeight !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.renderHeight);
        /* optional uint32 swap_width = 19; */
        if (message.swapWidth !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.swapWidth);
        /* optional uint32 swap_height = 20; */
        if (message.swapHeight !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.swapHeight);
        /* optional bool is_steam_china = 22; */
        if (message.isSteamChina !== undefined)
            writer.tag(22, WireType.Varint).bool(message.isSteamChina);
        /* optional bool is_steam_china_client = 24; */
        if (message.isSteamChinaClient !== undefined)
            writer.tag(24, WireType.Varint).bool(message.isSteamChinaClient);
        /* optional string platform_name = 23; */
        if (message.platformName !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.platformName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientHello
 */
export const CMsgClientHello = new CMsgClientHello$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWelcome$Type extends MessageType<CMsgClientWelcome> {
    constructor() {
        super("CMsgClientWelcome", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "game_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "outofdate_subscribed_caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOCacheSubscribed },
            { no: 4, name: "uptodate_subscribed_caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSOCacheSubscriptionCheck },
            { no: 5, name: "location", kind: "message", T: () => CMsgClientWelcome_Location },
            { no: 9, name: "gc_socache_file_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "txn_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "game_data2", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "rtime32_gc_welcome_timestamp", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "currency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "balance", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "balance_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "has_accepted_china_ssa", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_banned_steam_china", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "additional_welcome_msgs", kind: "message", T: () => CExtraMsgBlock },
            { no: 20, name: "steam_learn_server_info", kind: "message", T: () => CMsgSteamLearnServerInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWelcome>): CMsgClientWelcome {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.outofdateSubscribedCaches = [];
        message.uptodateSubscribedCaches = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWelcome>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWelcome): CMsgClientWelcome {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 version */ 1:
                    message.version = reader.uint32();
                    break;
                case /* optional bytes game_data */ 2:
                    message.gameData = reader.bytes();
                    break;
                case /* repeated CMsgSOCacheSubscribed outofdate_subscribed_caches */ 3:
                    message.outofdateSubscribedCaches.push(CMsgSOCacheSubscribed.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches */ 4:
                    message.uptodateSubscribedCaches.push(CMsgSOCacheSubscriptionCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional CMsgClientWelcome.Location location */ 5:
                    message.location = CMsgClientWelcome_Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* optional uint32 gc_socache_file_version */ 9:
                    message.gcSocacheFileVersion = reader.uint32();
                    break;
                case /* optional string txn_country_code */ 10:
                    message.txnCountryCode = reader.string();
                    break;
                case /* optional bytes game_data2 */ 11:
                    message.gameData2 = reader.bytes();
                    break;
                case /* optional uint32 rtime32_gc_welcome_timestamp */ 12:
                    message.rtime32GcWelcomeTimestamp = reader.uint32();
                    break;
                case /* optional uint32 currency */ 13:
                    message.currency = reader.uint32();
                    break;
                case /* optional uint32 balance */ 14:
                    message.balance = reader.uint32();
                    break;
                case /* optional string balance_url */ 15:
                    message.balanceUrl = reader.string();
                    break;
                case /* optional bool has_accepted_china_ssa */ 16:
                    message.hasAcceptedChinaSsa = reader.bool();
                    break;
                case /* optional bool is_banned_steam_china */ 17:
                    message.isBannedSteamChina = reader.bool();
                    break;
                case /* optional CExtraMsgBlock additional_welcome_msgs */ 18:
                    message.additionalWelcomeMsgs = CExtraMsgBlock.internalBinaryRead(reader, reader.uint32(), options, message.additionalWelcomeMsgs);
                    break;
                case /* optional CMsgSteamLearnServerInfo steam_learn_server_info */ 20:
                    message.steamLearnServerInfo = CMsgSteamLearnServerInfo.internalBinaryRead(reader, reader.uint32(), options, message.steamLearnServerInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWelcome, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.version);
        /* optional bytes game_data = 2; */
        if (message.gameData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.gameData);
        /* repeated CMsgSOCacheSubscribed outofdate_subscribed_caches = 3; */
        for (let i = 0; i < message.outofdateSubscribedCaches.length; i++)
            CMsgSOCacheSubscribed.internalBinaryWrite(message.outofdateSubscribedCaches[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSOCacheSubscriptionCheck uptodate_subscribed_caches = 4; */
        for (let i = 0; i < message.uptodateSubscribedCaches.length; i++)
            CMsgSOCacheSubscriptionCheck.internalBinaryWrite(message.uptodateSubscribedCaches[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgClientWelcome.Location location = 5; */
        if (message.location)
            CMsgClientWelcome_Location.internalBinaryWrite(message.location, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 gc_socache_file_version = 9; */
        if (message.gcSocacheFileVersion !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.gcSocacheFileVersion);
        /* optional string txn_country_code = 10; */
        if (message.txnCountryCode !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.txnCountryCode);
        /* optional bytes game_data2 = 11; */
        if (message.gameData2 !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.gameData2);
        /* optional uint32 rtime32_gc_welcome_timestamp = 12; */
        if (message.rtime32GcWelcomeTimestamp !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.rtime32GcWelcomeTimestamp);
        /* optional uint32 currency = 13; */
        if (message.currency !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.currency);
        /* optional uint32 balance = 14; */
        if (message.balance !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.balance);
        /* optional string balance_url = 15; */
        if (message.balanceUrl !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.balanceUrl);
        /* optional bool has_accepted_china_ssa = 16; */
        if (message.hasAcceptedChinaSsa !== undefined)
            writer.tag(16, WireType.Varint).bool(message.hasAcceptedChinaSsa);
        /* optional bool is_banned_steam_china = 17; */
        if (message.isBannedSteamChina !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isBannedSteamChina);
        /* optional CExtraMsgBlock additional_welcome_msgs = 18; */
        if (message.additionalWelcomeMsgs)
            CExtraMsgBlock.internalBinaryWrite(message.additionalWelcomeMsgs, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamLearnServerInfo steam_learn_server_info = 20; */
        if (message.steamLearnServerInfo)
            CMsgSteamLearnServerInfo.internalBinaryWrite(message.steamLearnServerInfo, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWelcome
 */
export const CMsgClientWelcome = new CMsgClientWelcome$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientWelcome_Location$Type extends MessageType<CMsgClientWelcome_Location> {
    constructor() {
        super("CMsgClientWelcome.Location", [
            { no: 1, name: "latitude", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "longitude", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "country", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgClientWelcome_Location>): CMsgClientWelcome_Location {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgClientWelcome_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgClientWelcome_Location): CMsgClientWelcome_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float latitude */ 1:
                    message.latitude = reader.float();
                    break;
                case /* optional float longitude */ 2:
                    message.longitude = reader.float();
                    break;
                case /* optional string country */ 3:
                    message.country = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgClientWelcome_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float latitude = 1; */
        if (message.latitude !== undefined)
            writer.tag(1, WireType.Bit32).float(message.latitude);
        /* optional float longitude = 2; */
        if (message.longitude !== undefined)
            writer.tag(2, WireType.Bit32).float(message.longitude);
        /* optional string country = 3; */
        if (message.country !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.country);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgClientWelcome.Location
 */
export const CMsgClientWelcome_Location = new CMsgClientWelcome_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgConnectionStatus$Type extends MessageType<CMsgConnectionStatus> {
    constructor() {
        super("CMsgConnectionStatus", [
            { no: 1, name: "status", kind: "enum", opt: true, T: () => ["GCConnectionStatus", GCConnectionStatus] },
            { no: 2, name: "client_session_need", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "queue_position", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "queue_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "wait_seconds", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "estimated_wait_seconds_remaining", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgConnectionStatus>): CMsgConnectionStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgConnectionStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgConnectionStatus): CMsgConnectionStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional GCConnectionStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* optional uint32 client_session_need */ 2:
                    message.clientSessionNeed = reader.uint32();
                    break;
                case /* optional int32 queue_position */ 3:
                    message.queuePosition = reader.int32();
                    break;
                case /* optional int32 queue_size */ 4:
                    message.queueSize = reader.int32();
                    break;
                case /* optional int32 wait_seconds */ 5:
                    message.waitSeconds = reader.int32();
                    break;
                case /* optional int32 estimated_wait_seconds_remaining */ 6:
                    message.estimatedWaitSecondsRemaining = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgConnectionStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional GCConnectionStatus status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* optional uint32 client_session_need = 2; */
        if (message.clientSessionNeed !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.clientSessionNeed);
        /* optional int32 queue_position = 3; */
        if (message.queuePosition !== undefined)
            writer.tag(3, WireType.Varint).int32(message.queuePosition);
        /* optional int32 queue_size = 4; */
        if (message.queueSize !== undefined)
            writer.tag(4, WireType.Varint).int32(message.queueSize);
        /* optional int32 wait_seconds = 5; */
        if (message.waitSeconds !== undefined)
            writer.tag(5, WireType.Varint).int32(message.waitSeconds);
        /* optional int32 estimated_wait_seconds_remaining = 6; */
        if (message.estimatedWaitSecondsRemaining !== undefined)
            writer.tag(6, WireType.Varint).int32(message.estimatedWaitSecondsRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgConnectionStatus
 */
export const CMsgConnectionStatus = new CMsgConnectionStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheSubscribe$Type extends MessageType<CMsgGCToGCSOCacheSubscribe> {
    constructor() {
        super("CMsgGCToGCSOCacheSubscribe", [
            { no: 1, name: "subscriber", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "subscribe_to_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sync_version", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "have_versions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions },
            { no: 5, name: "subscribe_to_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCSOCacheSubscribe>): CMsgGCToGCSOCacheSubscribe {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.haveVersions = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCSOCacheSubscribe>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCSOCacheSubscribe): CMsgGCToGCSOCacheSubscribe {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 subscriber */ 1:
                    message.subscriber = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 subscribe_to_id */ 2:
                    message.subscribeToId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 sync_version */ 3:
                    message.syncVersion = reader.fixed64().toBigInt();
                    break;
                case /* repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions */ 4:
                    message.haveVersions.push(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 subscribe_to_type */ 5:
                    message.subscribeToType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCSOCacheSubscribe, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 subscriber = 1; */
        if (message.subscriber !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.subscriber);
        /* optional fixed64 subscribe_to_id = 2; */
        if (message.subscribeToId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.subscribeToId);
        /* optional fixed64 sync_version = 3; */
        if (message.syncVersion !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.syncVersion);
        /* repeated CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4; */
        for (let i = 0; i < message.haveVersions.length; i++)
            CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions.internalBinaryWrite(message.haveVersions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 subscribe_to_type = 5; */
        if (message.subscribeToType !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.subscribeToType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheSubscribe
 */
export const CMsgGCToGCSOCacheSubscribe = new CMsgGCToGCSOCacheSubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions$Type extends MessageType<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> {
    constructor() {
        super("CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions", [
            { no: 1, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "version", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions): CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 service_id */ 1:
                    message.serviceId = reader.uint32();
                    break;
                case /* optional uint64 version */ 2:
                    message.version = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 service_id = 1; */
        if (message.serviceId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.serviceId);
        /* optional uint64 version = 2; */
        if (message.version !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions
 */
export const CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions = new CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCSOCacheUnsubscribe$Type extends MessageType<CMsgGCToGCSOCacheUnsubscribe> {
    constructor() {
        super("CMsgGCToGCSOCacheUnsubscribe", [
            { no: 1, name: "subscriber", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "unsubscribe_from_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "unsubscribe_from_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCSOCacheUnsubscribe>): CMsgGCToGCSOCacheUnsubscribe {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCSOCacheUnsubscribe>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCSOCacheUnsubscribe): CMsgGCToGCSOCacheUnsubscribe {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 subscriber */ 1:
                    message.subscriber = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 unsubscribe_from_id */ 2:
                    message.unsubscribeFromId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 unsubscribe_from_type */ 3:
                    message.unsubscribeFromType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCSOCacheUnsubscribe, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 subscriber = 1; */
        if (message.subscriber !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.subscriber);
        /* optional fixed64 unsubscribe_from_id = 2; */
        if (message.unsubscribeFromId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.unsubscribeFromId);
        /* optional uint32 unsubscribe_from_type = 3; */
        if (message.unsubscribeFromType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.unsubscribeFromType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCSOCacheUnsubscribe
 */
export const CMsgGCToGCSOCacheUnsubscribe = new CMsgGCToGCSOCacheUnsubscribe$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCClientPing$Type extends MessageType<CMsgGCClientPing> {
    constructor() {
        super("CMsgGCClientPing", []);
    }
    create(value?: PartialMessage<CMsgGCClientPing>): CMsgGCClientPing {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCClientPing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCClientPing): CMsgGCClientPing {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CMsgGCClientPing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCClientPing
 */
export const CMsgGCClientPing = new CMsgGCClientPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCForwardAccountDetails$Type extends MessageType<CMsgGCToGCForwardAccountDetails> {
    constructor() {
        super("CMsgGCToGCForwardAccountDetails", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "account_details", kind: "message", T: () => CGCSystemMsg_GetAccountDetails_Response },
            { no: 3, name: "age_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCForwardAccountDetails>): CMsgGCToGCForwardAccountDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCForwardAccountDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCForwardAccountDetails): CMsgGCToGCForwardAccountDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional CGCSystemMsg_GetAccountDetails_Response account_details */ 2:
                    message.accountDetails = CGCSystemMsg_GetAccountDetails_Response.internalBinaryRead(reader, reader.uint32(), options, message.accountDetails);
                    break;
                case /* optional uint32 age_seconds */ 3:
                    message.ageSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCForwardAccountDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional CGCSystemMsg_GetAccountDetails_Response account_details = 2; */
        if (message.accountDetails)
            CGCSystemMsg_GetAccountDetails_Response.internalBinaryWrite(message.accountDetails, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 age_seconds = 3; */
        if (message.ageSeconds !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.ageSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCForwardAccountDetails
 */
export const CMsgGCToGCForwardAccountDetails = new CMsgGCToGCForwardAccountDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCLoadSessionSOCache$Type extends MessageType<CMsgGCToGCLoadSessionSOCache> {
    constructor() {
        super("CMsgGCToGCLoadSessionSOCache", [
            { no: 1, name: "account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "forward_account_details", kind: "message", T: () => CMsgGCToGCForwardAccountDetails }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCLoadSessionSOCache>): CMsgGCToGCLoadSessionSOCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCLoadSessionSOCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCLoadSessionSOCache): CMsgGCToGCLoadSessionSOCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 account_id */ 1:
                    message.accountId = reader.uint32();
                    break;
                case /* optional CMsgGCToGCForwardAccountDetails forward_account_details */ 2:
                    message.forwardAccountDetails = CMsgGCToGCForwardAccountDetails.internalBinaryRead(reader, reader.uint32(), options, message.forwardAccountDetails);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCLoadSessionSOCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 account_id = 1; */
        if (message.accountId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountId);
        /* optional CMsgGCToGCForwardAccountDetails forward_account_details = 2; */
        if (message.forwardAccountDetails)
            CMsgGCToGCForwardAccountDetails.internalBinaryWrite(message.forwardAccountDetails, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCLoadSessionSOCache
 */
export const CMsgGCToGCLoadSessionSOCache = new CMsgGCToGCLoadSessionSOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCLoadSessionSOCacheResponse$Type extends MessageType<CMsgGCToGCLoadSessionSOCacheResponse> {
    constructor() {
        super("CMsgGCToGCLoadSessionSOCacheResponse", []);
    }
    create(value?: PartialMessage<CMsgGCToGCLoadSessionSOCacheResponse>): CMsgGCToGCLoadSessionSOCacheResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCLoadSessionSOCacheResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCLoadSessionSOCacheResponse): CMsgGCToGCLoadSessionSOCacheResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CMsgGCToGCLoadSessionSOCacheResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCLoadSessionSOCacheResponse
 */
export const CMsgGCToGCLoadSessionSOCacheResponse = new CMsgGCToGCLoadSessionSOCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUpdateSessionStats$Type extends MessageType<CMsgGCToGCUpdateSessionStats> {
    constructor() {
        super("CMsgGCToGCUpdateSessionStats", [
            { no: 1, name: "user_sessions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_sessions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "in_logon_surge", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCUpdateSessionStats>): CMsgGCToGCUpdateSessionStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCUpdateSessionStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCUpdateSessionStats): CMsgGCToGCUpdateSessionStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 user_sessions */ 1:
                    message.userSessions = reader.uint32();
                    break;
                case /* optional uint32 server_sessions */ 2:
                    message.serverSessions = reader.uint32();
                    break;
                case /* optional bool in_logon_surge */ 3:
                    message.inLogonSurge = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCUpdateSessionStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 user_sessions = 1; */
        if (message.userSessions !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.userSessions);
        /* optional uint32 server_sessions = 2; */
        if (message.serverSessions !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.serverSessions);
        /* optional bool in_logon_surge = 3; */
        if (message.inLogonSurge !== undefined)
            writer.tag(3, WireType.Varint).bool(message.inLogonSurge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUpdateSessionStats
 */
export const CMsgGCToGCUpdateSessionStats = new CMsgGCToGCUpdateSessionStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientRequestDropped$Type extends MessageType<CMsgGCToClientRequestDropped> {
    constructor() {
        super("CMsgGCToClientRequestDropped", []);
    }
    create(value?: PartialMessage<CMsgGCToClientRequestDropped>): CMsgGCToClientRequestDropped {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToClientRequestDropped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToClientRequestDropped): CMsgGCToClientRequestDropped {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CMsgGCToClientRequestDropped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientRequestDropped
 */
export const CMsgGCToClientRequestDropped = new CMsgGCToClientRequestDropped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request> {
    constructor() {
        super("CWorkshop_PopulateItemDescriptions_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "languages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request>): CWorkshop_PopulateItemDescriptions_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.languages = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_PopulateItemDescriptions_Request): CWorkshop_PopulateItemDescriptions_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages */ 2:
                    message.languages.push(CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_PopulateItemDescriptions_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* repeated CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2; */
        for (let i = 0; i < message.languages.length; i++)
            CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock.internalBinaryWrite(message.languages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request
 */
export const CWorkshop_PopulateItemDescriptions_Request = new CWorkshop_PopulateItemDescriptions_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription> {
    constructor() {
        super("CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription", [
            { no: 1, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "item_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>): CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription): CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 gameitemid */ 1:
                    message.gameitemid = reader.uint32();
                    break;
                case /* optional string item_description */ 2:
                    message.itemDescription = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 gameitemid = 1; */
        if (message.gameitemid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.gameitemid);
        /* optional string item_description = 2; */
        if (message.itemDescription !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.itemDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription
 */
export const CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription = new CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock$Type extends MessageType<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock> {
    constructor() {
        super("CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock", [
            { no: 1, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>): CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptions = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock): CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string language */ 1:
                    message.language = reader.string();
                    break;
                case /* repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions */ 2:
                    message.descriptions.push(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string language = 1; */
        if (message.language !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* repeated CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2; */
        for (let i = 0; i < message.descriptions.length; i++)
            CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription.internalBinaryWrite(message.descriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock
 */
export const CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock = new CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetContributors_Request$Type extends MessageType<CWorkshop_GetContributors_Request> {
    constructor() {
        super("CWorkshop_GetContributors_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_GetContributors_Request>): CWorkshop_GetContributors_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_GetContributors_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_GetContributors_Request): CWorkshop_GetContributors_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 gameitemid */ 2:
                    message.gameitemid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_GetContributors_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 gameitemid = 2; */
        if (message.gameitemid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameitemid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetContributors_Request
 */
export const CWorkshop_GetContributors_Request = new CWorkshop_GetContributors_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_GetContributors_Response$Type extends MessageType<CWorkshop_GetContributors_Response> {
    constructor() {
        super("CWorkshop_GetContributors_Response", [
            { no: 1, name: "contributors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_GetContributors_Response>): CWorkshop_GetContributors_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contributors = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_GetContributors_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_GetContributors_Response): CWorkshop_GetContributors_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 contributors */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.contributors.push(reader.fixed64().toBigInt());
                    else
                        message.contributors.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_GetContributors_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 contributors = 1; */
        for (let i = 0; i < message.contributors.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.contributors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_GetContributors_Response
 */
export const CWorkshop_GetContributors_Response = new CWorkshop_GetContributors_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request> {
    constructor() {
        super("CWorkshop_SetItemPaymentRules_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameitemid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "associated_workshop_files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule },
            { no: 4, name: "partner_accounts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule },
            { no: 5, name: "validate_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "make_workshop_files_subscribable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "associated_workshop_file_for_direct_payments", kind: "message", T: () => CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request>): CWorkshop_SetItemPaymentRules_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.associatedWorkshopFiles = [];
        message.partnerAccounts = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_SetItemPaymentRules_Request): CWorkshop_SetItemPaymentRules_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 gameitemid */ 2:
                    message.gameitemid = reader.uint32();
                    break;
                case /* repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files */ 3:
                    message.associatedWorkshopFiles.push(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts */ 4:
                    message.partnerAccounts.push(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool validate_only */ 5:
                    message.validateOnly = reader.bool();
                    break;
                case /* optional bool make_workshop_files_subscribable */ 6:
                    message.makeWorkshopFilesSubscribable = reader.bool();
                    break;
                case /* optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments */ 7:
                    message.associatedWorkshopFileForDirectPayments = CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule.internalBinaryRead(reader, reader.uint32(), options, message.associatedWorkshopFileForDirectPayments);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_SetItemPaymentRules_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 gameitemid = 2; */
        if (message.gameitemid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameitemid);
        /* repeated CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3; */
        for (let i = 0; i < message.associatedWorkshopFiles.length; i++)
            CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule.internalBinaryWrite(message.associatedWorkshopFiles[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4; */
        for (let i = 0; i < message.partnerAccounts.length; i++)
            CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule.internalBinaryWrite(message.partnerAccounts[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bool validate_only = 5; */
        if (message.validateOnly !== undefined)
            writer.tag(5, WireType.Varint).bool(message.validateOnly);
        /* optional bool make_workshop_files_subscribable = 6; */
        if (message.makeWorkshopFilesSubscribable !== undefined)
            writer.tag(6, WireType.Varint).bool(message.makeWorkshopFilesSubscribable);
        /* optional CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule associated_workshop_file_for_direct_payments = 7; */
        if (message.associatedWorkshopFileForDirectPayments)
            CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule.internalBinaryWrite(message.associatedWorkshopFileForDirectPayments, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request
 */
export const CWorkshop_SetItemPaymentRules_Request = new CWorkshop_SetItemPaymentRules_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule> {
    constructor() {
        super("CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule", [
            { no: 1, name: "workshop_file_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "revenue_percentage", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "rule_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rule_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>): CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule): CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 workshop_file_id */ 1:
                    message.workshopFileId = reader.uint64().toBigInt();
                    break;
                case /* optional float revenue_percentage */ 2:
                    message.revenuePercentage = reader.float();
                    break;
                case /* optional string rule_description */ 3:
                    message.ruleDescription = reader.string();
                    break;
                case /* optional uint32 rule_type */ 4:
                    message.ruleType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 workshop_file_id = 1; */
        if (message.workshopFileId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.workshopFileId);
        /* optional float revenue_percentage = 2; */
        if (message.revenuePercentage !== undefined)
            writer.tag(2, WireType.Bit32).float(message.revenuePercentage);
        /* optional string rule_description = 3; */
        if (message.ruleDescription !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.ruleDescription);
        /* optional uint32 rule_type = 4; */
        if (message.ruleType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.ruleType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule = new CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule> {
    constructor() {
        super("CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule", [
            { no: 1, name: "workshop_file_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rule_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>): CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule): CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 workshop_file_id */ 1:
                    message.workshopFileId = reader.uint64().toBigInt();
                    break;
                case /* optional string rule_description */ 2:
                    message.ruleDescription = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 workshop_file_id = 1; */
        if (message.workshopFileId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.workshopFileId);
        /* optional string rule_description = 2; */
        if (message.ruleDescription !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.ruleDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule = new CWorkshop_SetItemPaymentRules_Request_WorkshopDirectPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule$Type extends MessageType<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule> {
    constructor() {
        super("CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule", [
            { no: 1, name: "account_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "revenue_percentage", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "rule_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>): CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule): CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 account_id */ 1:
                    message.accountId = reader.uint32();
                    break;
                case /* optional float revenue_percentage */ 2:
                    message.revenuePercentage = reader.float();
                    break;
                case /* optional string rule_description */ 3:
                    message.ruleDescription = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 account_id = 1; */
        if (message.accountId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.accountId);
        /* optional float revenue_percentage = 2; */
        if (message.revenuePercentage !== undefined)
            writer.tag(2, WireType.Bit32).float(message.revenuePercentage);
        /* optional string rule_description = 3; */
        if (message.ruleDescription !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.ruleDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule
 */
export const CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule = new CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CWorkshop_SetItemPaymentRules_Response$Type extends MessageType<CWorkshop_SetItemPaymentRules_Response> {
    constructor() {
        super("CWorkshop_SetItemPaymentRules_Response", [
            { no: 1, name: "validation_errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CWorkshop_SetItemPaymentRules_Response>): CWorkshop_SetItemPaymentRules_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.validationErrors = [];
        if (value !== undefined)
            reflectionMergePartial<CWorkshop_SetItemPaymentRules_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CWorkshop_SetItemPaymentRules_Response): CWorkshop_SetItemPaymentRules_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string validation_errors */ 1:
                    message.validationErrors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CWorkshop_SetItemPaymentRules_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string validation_errors = 1; */
        for (let i = 0; i < message.validationErrors.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.validationErrors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CWorkshop_SetItemPaymentRules_Response
 */
export const CWorkshop_SetItemPaymentRules_Response = new CWorkshop_SetItemPaymentRules_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_ClanAnnouncementInfo$Type extends MessageType<CCommunity_ClanAnnouncementInfo> {
    constructor() {
        super("CCommunity_ClanAnnouncementInfo", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clanid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "posterid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "posttime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "updatetime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "body", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "commentcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "forum_topic_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CCommunity_ClanAnnouncementInfo>): CCommunity_ClanAnnouncementInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CCommunity_ClanAnnouncementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCommunity_ClanAnnouncementInfo): CCommunity_ClanAnnouncementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gid */ 1:
                    message.gid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 clanid */ 2:
                    message.clanid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 posterid */ 3:
                    message.posterid = reader.uint64().toBigInt();
                    break;
                case /* optional string headline */ 4:
                    message.headline = reader.string();
                    break;
                case /* optional uint32 posttime */ 5:
                    message.posttime = reader.uint32();
                    break;
                case /* optional uint32 updatetime */ 6:
                    message.updatetime = reader.uint32();
                    break;
                case /* optional string body */ 7:
                    message.body = reader.string();
                    break;
                case /* optional int32 commentcount */ 8:
                    message.commentcount = reader.int32();
                    break;
                case /* repeated string tags */ 9:
                    message.tags.push(reader.string());
                    break;
                case /* optional int32 language */ 10:
                    message.language = reader.int32();
                    break;
                case /* optional bool hidden */ 11:
                    message.hidden = reader.bool();
                    break;
                case /* optional fixed64 forum_topic_id */ 12:
                    message.forumTopicId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCommunity_ClanAnnouncementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gid);
        /* optional uint64 clanid = 2; */
        if (message.clanid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.clanid);
        /* optional uint64 posterid = 3; */
        if (message.posterid !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.posterid);
        /* optional string headline = 4; */
        if (message.headline !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.headline);
        /* optional uint32 posttime = 5; */
        if (message.posttime !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.posttime);
        /* optional uint32 updatetime = 6; */
        if (message.updatetime !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.updatetime);
        /* optional string body = 7; */
        if (message.body !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.body);
        /* optional int32 commentcount = 8; */
        if (message.commentcount !== undefined)
            writer.tag(8, WireType.Varint).int32(message.commentcount);
        /* repeated string tags = 9; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.tags[i]);
        /* optional int32 language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.Varint).int32(message.language);
        /* optional bool hidden = 11; */
        if (message.hidden !== undefined)
            writer.tag(11, WireType.Varint).bool(message.hidden);
        /* optional fixed64 forum_topic_id = 12; */
        if (message.forumTopicId !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.forumTopicId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCommunity_ClanAnnouncementInfo
 */
export const CCommunity_ClanAnnouncementInfo = new CCommunity_ClanAnnouncementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_GetClanAnnouncements_Request$Type extends MessageType<CCommunity_GetClanAnnouncements_Request> {
    constructor() {
        super("CCommunity_GetClanAnnouncements_Request", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "maxchars", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "strip_html", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "required_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "require_no_tags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "language_preference", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "hidden_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "only_gid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "rtime_oldest_date", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "include_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "include_partner_events", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CCommunity_GetClanAnnouncements_Request>): CCommunity_GetClanAnnouncements_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiredTags = [];
        message.languagePreference = [];
        if (value !== undefined)
            reflectionMergePartial<CCommunity_GetClanAnnouncements_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCommunity_GetClanAnnouncements_Request): CCommunity_GetClanAnnouncements_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 steamid */ 1:
                    message.steamid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                case /* optional uint32 count */ 3:
                    message.count = reader.uint32();
                    break;
                case /* optional uint32 maxchars */ 4:
                    message.maxchars = reader.uint32();
                    break;
                case /* optional bool strip_html */ 5:
                    message.stripHtml = reader.bool();
                    break;
                case /* repeated string required_tags */ 6:
                    message.requiredTags.push(reader.string());
                    break;
                case /* optional bool require_no_tags */ 7:
                    message.requireNoTags = reader.bool();
                    break;
                case /* repeated uint32 language_preference */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.languagePreference.push(reader.uint32());
                    else
                        message.languagePreference.push(reader.uint32());
                    break;
                case /* optional bool hidden_only */ 9:
                    message.hiddenOnly = reader.bool();
                    break;
                case /* optional bool only_gid */ 10:
                    message.onlyGid = reader.bool();
                    break;
                case /* optional uint32 rtime_oldest_date */ 11:
                    message.rtimeOldestDate = reader.uint32();
                    break;
                case /* optional bool include_hidden */ 12:
                    message.includeHidden = reader.bool();
                    break;
                case /* optional bool include_partner_events */ 13:
                    message.includePartnerEvents = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCommunity_GetClanAnnouncements_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.steamid);
        /* optional uint32 offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        /* optional uint32 count = 3; */
        if (message.count !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.count);
        /* optional uint32 maxchars = 4; */
        if (message.maxchars !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.maxchars);
        /* optional bool strip_html = 5; */
        if (message.stripHtml !== undefined)
            writer.tag(5, WireType.Varint).bool(message.stripHtml);
        /* repeated string required_tags = 6; */
        for (let i = 0; i < message.requiredTags.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.requiredTags[i]);
        /* optional bool require_no_tags = 7; */
        if (message.requireNoTags !== undefined)
            writer.tag(7, WireType.Varint).bool(message.requireNoTags);
        /* repeated uint32 language_preference = 8; */
        for (let i = 0; i < message.languagePreference.length; i++)
            writer.tag(8, WireType.Varint).uint32(message.languagePreference[i]);
        /* optional bool hidden_only = 9; */
        if (message.hiddenOnly !== undefined)
            writer.tag(9, WireType.Varint).bool(message.hiddenOnly);
        /* optional bool only_gid = 10; */
        if (message.onlyGid !== undefined)
            writer.tag(10, WireType.Varint).bool(message.onlyGid);
        /* optional uint32 rtime_oldest_date = 11; */
        if (message.rtimeOldestDate !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.rtimeOldestDate);
        /* optional bool include_hidden = 12; */
        if (message.includeHidden !== undefined)
            writer.tag(12, WireType.Varint).bool(message.includeHidden);
        /* optional bool include_partner_events = 13; */
        if (message.includePartnerEvents !== undefined)
            writer.tag(13, WireType.Varint).bool(message.includePartnerEvents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCommunity_GetClanAnnouncements_Request
 */
export const CCommunity_GetClanAnnouncements_Request = new CCommunity_GetClanAnnouncements_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_GetClanAnnouncements_Response$Type extends MessageType<CCommunity_GetClanAnnouncements_Response> {
    constructor() {
        super("CCommunity_GetClanAnnouncements_Response", [
            { no: 1, name: "maxchars", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "strip_html", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "announcements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CCommunity_ClanAnnouncementInfo }
        ]);
    }
    create(value?: PartialMessage<CCommunity_GetClanAnnouncements_Response>): CCommunity_GetClanAnnouncements_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.announcements = [];
        if (value !== undefined)
            reflectionMergePartial<CCommunity_GetClanAnnouncements_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCommunity_GetClanAnnouncements_Response): CCommunity_GetClanAnnouncements_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 maxchars */ 1:
                    message.maxchars = reader.uint32();
                    break;
                case /* optional bool strip_html */ 2:
                    message.stripHtml = reader.bool();
                    break;
                case /* repeated CCommunity_ClanAnnouncementInfo announcements */ 3:
                    message.announcements.push(CCommunity_ClanAnnouncementInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCommunity_GetClanAnnouncements_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 maxchars = 1; */
        if (message.maxchars !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.maxchars);
        /* optional bool strip_html = 2; */
        if (message.stripHtml !== undefined)
            writer.tag(2, WireType.Varint).bool(message.stripHtml);
        /* repeated CCommunity_ClanAnnouncementInfo announcements = 3; */
        for (let i = 0; i < message.announcements.length; i++)
            CCommunity_ClanAnnouncementInfo.internalBinaryWrite(message.announcements[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCommunity_GetClanAnnouncements_Response
 */
export const CCommunity_GetClanAnnouncements_Response = new CCommunity_GetClanAnnouncements_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBroadcast_PostGameDataFrame_Request$Type extends MessageType<CBroadcast_PostGameDataFrame_Request> {
    constructor() {
        super("CBroadcast_PostGameDataFrame_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "broadcast_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "frame_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CBroadcast_PostGameDataFrame_Request>): CBroadcast_PostGameDataFrame_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CBroadcast_PostGameDataFrame_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CBroadcast_PostGameDataFrame_Request): CBroadcast_PostGameDataFrame_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional fixed64 steamid */ 2:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 broadcast_id */ 3:
                    message.broadcastId = reader.fixed64().toBigInt();
                    break;
                case /* optional bytes frame_data */ 4:
                    message.frameData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CBroadcast_PostGameDataFrame_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional fixed64 steamid = 2; */
        if (message.steamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamid);
        /* optional fixed64 broadcast_id = 3; */
        if (message.broadcastId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.broadcastId);
        /* optional bytes frame_data = 4; */
        if (message.frameData !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.frameData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CBroadcast_PostGameDataFrame_Request
 */
export const CBroadcast_PostGameDataFrame_Request = new CBroadcast_PostGameDataFrame_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache$Type extends MessageType<CMsgSerializedSOCache> {
    constructor() {
        super("CMsgSerializedSOCache", [
            { no: 1, name: "file_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSerializedSOCache_Cache },
            { no: 3, name: "gc_socache_file_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSerializedSOCache>): CMsgSerializedSOCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.caches = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSerializedSOCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSerializedSOCache): CMsgSerializedSOCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 file_version */ 1:
                    message.fileVersion = reader.uint32();
                    break;
                case /* repeated CMsgSerializedSOCache.Cache caches */ 2:
                    message.caches.push(CMsgSerializedSOCache_Cache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 gc_socache_file_version */ 3:
                    message.gcSocacheFileVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSerializedSOCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 file_version = 1; */
        if (message.fileVersion !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.fileVersion);
        /* repeated CMsgSerializedSOCache.Cache caches = 2; */
        for (let i = 0; i < message.caches.length; i++)
            CMsgSerializedSOCache_Cache.internalBinaryWrite(message.caches[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 gc_socache_file_version = 3; */
        if (message.gcSocacheFileVersion !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.gcSocacheFileVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache
 */
export const CMsgSerializedSOCache = new CMsgSerializedSOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_TypeCache$Type extends MessageType<CMsgSerializedSOCache_TypeCache> {
    constructor() {
        super("CMsgSerializedSOCache.TypeCache", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "objects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "service_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSerializedSOCache_TypeCache>): CMsgSerializedSOCache_TypeCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objects = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSerializedSOCache_TypeCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSerializedSOCache_TypeCache): CMsgSerializedSOCache_TypeCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* repeated bytes objects */ 2:
                    message.objects.push(reader.bytes());
                    break;
                case /* optional uint32 service_id */ 3:
                    message.serviceId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSerializedSOCache_TypeCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* repeated bytes objects = 2; */
        for (let i = 0; i < message.objects.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.objects[i]);
        /* optional uint32 service_id = 3; */
        if (message.serviceId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.serviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.TypeCache
 */
export const CMsgSerializedSOCache_TypeCache = new CMsgSerializedSOCache_TypeCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_Cache$Type extends MessageType<CMsgSerializedSOCache_Cache> {
    constructor() {
        super("CMsgSerializedSOCache.Cache", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "versions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSerializedSOCache_Cache_Version },
            { no: 4, name: "type_caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSerializedSOCache_TypeCache }
        ]);
    }
    create(value?: PartialMessage<CMsgSerializedSOCache_Cache>): CMsgSerializedSOCache_Cache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versions = [];
        message.typeCaches = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSerializedSOCache_Cache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSerializedSOCache_Cache): CMsgSerializedSOCache_Cache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* optional uint64 id */ 2:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* repeated CMsgSerializedSOCache.Cache.Version versions */ 3:
                    message.versions.push(CMsgSerializedSOCache_Cache_Version.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSerializedSOCache.TypeCache type_caches */ 4:
                    message.typeCaches.push(CMsgSerializedSOCache_TypeCache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSerializedSOCache_Cache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* optional uint64 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.id);
        /* repeated CMsgSerializedSOCache.Cache.Version versions = 3; */
        for (let i = 0; i < message.versions.length; i++)
            CMsgSerializedSOCache_Cache_Version.internalBinaryWrite(message.versions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSerializedSOCache.TypeCache type_caches = 4; */
        for (let i = 0; i < message.typeCaches.length; i++)
            CMsgSerializedSOCache_TypeCache.internalBinaryWrite(message.typeCaches[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.Cache
 */
export const CMsgSerializedSOCache_Cache = new CMsgSerializedSOCache_Cache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSerializedSOCache_Cache_Version$Type extends MessageType<CMsgSerializedSOCache_Cache_Version> {
    constructor() {
        super("CMsgSerializedSOCache.Cache.Version", [
            { no: 1, name: "service", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "version", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSerializedSOCache_Cache_Version>): CMsgSerializedSOCache_Cache_Version {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSerializedSOCache_Cache_Version>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSerializedSOCache_Cache_Version): CMsgSerializedSOCache_Cache_Version {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 service */ 1:
                    message.service = reader.uint32();
                    break;
                case /* optional uint64 version */ 2:
                    message.version = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSerializedSOCache_Cache_Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 service = 1; */
        if (message.service !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.service);
        /* optional uint64 version = 2; */
        if (message.version !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSerializedSOCache.Cache.Version
 */
export const CMsgSerializedSOCache_Cache_Version = new CMsgSerializedSOCache_Cache_Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollConvarRequest$Type extends MessageType<CMsgGCToClientPollConvarRequest> {
    constructor() {
        super("CMsgGCToClientPollConvarRequest", [
            { no: 1, name: "convar_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "poll_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToClientPollConvarRequest>): CMsgGCToClientPollConvarRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToClientPollConvarRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToClientPollConvarRequest): CMsgGCToClientPollConvarRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string convar_name */ 1:
                    message.convarName = reader.string();
                    break;
                case /* optional uint32 poll_id */ 2:
                    message.pollId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToClientPollConvarRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string convar_name = 1; */
        if (message.convarName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.convarName);
        /* optional uint32 poll_id = 2; */
        if (message.pollId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pollId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollConvarRequest
 */
export const CMsgGCToClientPollConvarRequest = new CMsgGCToClientPollConvarRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollConvarResponse$Type extends MessageType<CMsgGCToClientPollConvarResponse> {
    constructor() {
        super("CMsgGCToClientPollConvarResponse", [
            { no: 1, name: "poll_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "convar_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToClientPollConvarResponse>): CMsgGCToClientPollConvarResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToClientPollConvarResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToClientPollConvarResponse): CMsgGCToClientPollConvarResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 poll_id */ 1:
                    message.pollId = reader.uint32();
                    break;
                case /* optional string convar_value */ 2:
                    message.convarValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToClientPollConvarResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 poll_id = 1; */
        if (message.pollId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.pollId);
        /* optional string convar_value = 2; */
        if (message.convarValue !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.convarValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollConvarResponse
 */
export const CMsgGCToClientPollConvarResponse = new CMsgGCToClientPollConvarResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CGCMsgCompressedMsgToClient$Type extends MessageType<CGCMsgCompressedMsgToClient> {
    constructor() {
        super("CGCMsgCompressedMsgToClient", [
            { no: 1, name: "msg_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "compressed_msg", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CGCMsgCompressedMsgToClient>): CGCMsgCompressedMsgToClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CGCMsgCompressedMsgToClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CGCMsgCompressedMsgToClient): CGCMsgCompressedMsgToClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 msg_id */ 1:
                    message.msgId = reader.uint32();
                    break;
                case /* optional bytes compressed_msg */ 2:
                    message.compressedMsg = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CGCMsgCompressedMsgToClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 msg_id = 1; */
        if (message.msgId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.msgId);
        /* optional bytes compressed_msg = 2; */
        if (message.compressedMsg !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.compressedMsg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CGCMsgCompressedMsgToClient
 */
export const CGCMsgCompressedMsgToClient = new CGCMsgCompressedMsgToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterBroadcastMessage$Type extends MessageType<CMsgGCToGCMasterBroadcastMessage> {
    constructor() {
        super("CMsgGCToGCMasterBroadcastMessage", [
            { no: 1, name: "users_per_second", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "send_to_users", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "send_to_servers", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "msg_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "msg_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterBroadcastMessage>): CMsgGCToGCMasterBroadcastMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterBroadcastMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterBroadcastMessage): CMsgGCToGCMasterBroadcastMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 users_per_second */ 1:
                    message.usersPerSecond = reader.uint32();
                    break;
                case /* optional bool send_to_users */ 2:
                    message.sendToUsers = reader.bool();
                    break;
                case /* optional bool send_to_servers */ 3:
                    message.sendToServers = reader.bool();
                    break;
                case /* optional uint32 msg_id */ 4:
                    message.msgId = reader.uint32();
                    break;
                case /* optional bytes msg_data */ 5:
                    message.msgData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCMasterBroadcastMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 users_per_second = 1; */
        if (message.usersPerSecond !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.usersPerSecond);
        /* optional bool send_to_users = 2; */
        if (message.sendToUsers !== undefined)
            writer.tag(2, WireType.Varint).bool(message.sendToUsers);
        /* optional bool send_to_servers = 3; */
        if (message.sendToServers !== undefined)
            writer.tag(3, WireType.Varint).bool(message.sendToServers);
        /* optional uint32 msg_id = 4; */
        if (message.msgId !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.msgId);
        /* optional bytes msg_data = 5; */
        if (message.msgData !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.msgData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterBroadcastMessage
 */
export const CMsgGCToGCMasterBroadcastMessage = new CMsgGCToGCMasterBroadcastMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCache$Type extends MessageType<CMsgGCToGCMasterSubscribeToCache> {
    constructor() {
        super("CMsgGCToGCMasterSubscribeToCache", [
            { no: 1, name: "soid_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "soid_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "account_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "steam_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCache>): CMsgGCToGCMasterSubscribeToCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountIds = [];
        message.steamIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterSubscribeToCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterSubscribeToCache): CMsgGCToGCMasterSubscribeToCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 soid_type */ 1:
                    message.soidType = reader.uint32();
                    break;
                case /* optional fixed64 soid_id */ 2:
                    message.soidId = reader.fixed64().toBigInt();
                    break;
                case /* repeated uint32 account_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.accountIds.push(reader.uint32());
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case /* repeated fixed64 steam_ids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamIds.push(reader.fixed64().toBigInt());
                    else
                        message.steamIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCMasterSubscribeToCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 soid_type = 1; */
        if (message.soidType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.soidType);
        /* optional fixed64 soid_id = 2; */
        if (message.soidId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.soidId);
        /* repeated uint32 account_ids = 3; */
        for (let i = 0; i < message.accountIds.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.accountIds[i]);
        /* repeated fixed64 steam_ids = 4; */
        for (let i = 0; i < message.steamIds.length; i++)
            writer.tag(4, WireType.Bit64).fixed64(message.steamIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCache
 */
export const CMsgGCToGCMasterSubscribeToCache = new CMsgGCToGCMasterSubscribeToCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCacheResponse$Type extends MessageType<CMsgGCToGCMasterSubscribeToCacheResponse> {
    constructor() {
        super("CMsgGCToGCMasterSubscribeToCacheResponse", []);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCacheResponse>): CMsgGCToGCMasterSubscribeToCacheResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterSubscribeToCacheResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterSubscribeToCacheResponse): CMsgGCToGCMasterSubscribeToCacheResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CMsgGCToGCMasterSubscribeToCacheResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCacheResponse
 */
export const CMsgGCToGCMasterSubscribeToCacheResponse = new CMsgGCToGCMasterSubscribeToCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterSubscribeToCacheAsync$Type extends MessageType<CMsgGCToGCMasterSubscribeToCacheAsync> {
    constructor() {
        super("CMsgGCToGCMasterSubscribeToCacheAsync", [
            { no: 1, name: "subscribe_msg", kind: "message", T: () => CMsgGCToGCMasterSubscribeToCache }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterSubscribeToCacheAsync>): CMsgGCToGCMasterSubscribeToCacheAsync {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterSubscribeToCacheAsync>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterSubscribeToCacheAsync): CMsgGCToGCMasterSubscribeToCacheAsync {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgGCToGCMasterSubscribeToCache subscribe_msg */ 1:
                    message.subscribeMsg = CMsgGCToGCMasterSubscribeToCache.internalBinaryRead(reader, reader.uint32(), options, message.subscribeMsg);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCMasterSubscribeToCacheAsync, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgGCToGCMasterSubscribeToCache subscribe_msg = 1; */
        if (message.subscribeMsg)
            CMsgGCToGCMasterSubscribeToCache.internalBinaryWrite(message.subscribeMsg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterSubscribeToCacheAsync
 */
export const CMsgGCToGCMasterSubscribeToCacheAsync = new CMsgGCToGCMasterSubscribeToCacheAsync$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterUnsubscribeFromCache$Type extends MessageType<CMsgGCToGCMasterUnsubscribeFromCache> {
    constructor() {
        super("CMsgGCToGCMasterUnsubscribeFromCache", [
            { no: 1, name: "soid_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "soid_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "account_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "steam_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterUnsubscribeFromCache>): CMsgGCToGCMasterUnsubscribeFromCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accountIds = [];
        message.steamIds = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterUnsubscribeFromCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterUnsubscribeFromCache): CMsgGCToGCMasterUnsubscribeFromCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 soid_type */ 1:
                    message.soidType = reader.uint32();
                    break;
                case /* optional fixed64 soid_id */ 2:
                    message.soidId = reader.fixed64().toBigInt();
                    break;
                case /* repeated uint32 account_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.accountIds.push(reader.uint32());
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case /* repeated fixed64 steam_ids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.steamIds.push(reader.fixed64().toBigInt());
                    else
                        message.steamIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCMasterUnsubscribeFromCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 soid_type = 1; */
        if (message.soidType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.soidType);
        /* optional fixed64 soid_id = 2; */
        if (message.soidId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.soidId);
        /* repeated uint32 account_ids = 3; */
        for (let i = 0; i < message.accountIds.length; i++)
            writer.tag(3, WireType.Varint).uint32(message.accountIds[i]);
        /* repeated fixed64 steam_ids = 4; */
        for (let i = 0; i < message.steamIds.length; i++)
            writer.tag(4, WireType.Bit64).fixed64(message.steamIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterUnsubscribeFromCache
 */
export const CMsgGCToGCMasterUnsubscribeFromCache = new CMsgGCToGCMasterUnsubscribeFromCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCMasterDestroyCache$Type extends MessageType<CMsgGCToGCMasterDestroyCache> {
    constructor() {
        super("CMsgGCToGCMasterDestroyCache", [
            { no: 1, name: "soid_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "soid_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgGCToGCMasterDestroyCache>): CMsgGCToGCMasterDestroyCache {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgGCToGCMasterDestroyCache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgGCToGCMasterDestroyCache): CMsgGCToGCMasterDestroyCache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 soid_type */ 1:
                    message.soidType = reader.uint32();
                    break;
                case /* optional fixed64 soid_id */ 2:
                    message.soidId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgGCToGCMasterDestroyCache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 soid_type = 1; */
        if (message.soidType !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.soidType);
        /* optional fixed64 soid_id = 2; */
        if (message.soidId !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.soidId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCMasterDestroyCache
 */
export const CMsgGCToGCMasterDestroyCache = new CMsgGCToGCMasterDestroyCache$Type();

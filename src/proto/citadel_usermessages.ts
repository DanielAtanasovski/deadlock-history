// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "citadel_usermessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgSosSetLibraryStackFields } from "./gameevents";
import { CMsgSosSetSoundEventParams } from "./gameevents";
import { CMsgSosStopSoundEventHash } from "./gameevents";
import { CMsgSosStopSoundEvent } from "./gameevents";
import { CMsgSosStartSoundEvent } from "./gameevents";
import { CMsgQAngle } from "./networkbasetypes";
import { CEntityMsg } from "./networkbasetypes";
import { CMsgMapLine } from "./citadel_gcmessages_common";
import { CMsgLaneColor } from "./citadel_gcmessages_common";
import { CMsgVector } from "./networkbasetypes";
/**
 * @generated from protobuf message CUserMessageEmpty
 */
export interface CUserMessageEmpty {
  /**
   * @generated from protobuf field: optional uint32 empty = 1;
   */
  empty?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_Damage
 */
export interface CCitadelUserMessage_Damage {
  /**
   * @generated from protobuf field: optional int32 damage = 1;
   */
  damage?: number;
  /**
   * @generated from protobuf field: optional int32 pre_damage = 2;
   */
  preDamage?: number;
  /**
   * @generated from protobuf field: optional int32 type = 3;
   */
  type?: number;
  /**
   * @generated from protobuf field: optional int32 citadel_type = 4;
   */
  citadelType?: number;
  /**
   * @generated from protobuf field: optional CMsgVector origin = 5;
   */
  origin?: CMsgVector;
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 6;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_inflictor = 7;
   */
  entindexInflictor?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_attacker = 8;
   */
  entindexAttacker?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_ability = 9;
   */
  entindexAbility?: number;
  /**
   * @generated from protobuf field: optional int32 damage_absorbed = 10;
   */
  damageAbsorbed?: number;
  /**
   * @generated from protobuf field: optional int32 victim_health_max = 11;
   */
  victimHealthMax?: number;
  /**
   * @generated from protobuf field: optional int32 victim_health_new = 12;
   */
  victimHealthNew?: number;
  /**
   * @generated from protobuf field: optional uint64 flags = 13;
   */
  flags?: bigint;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 14;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional uint32 attacker_class = 15;
   */
  attackerClass?: number;
  /**
   * @generated from protobuf field: optional uint32 victim_class = 16;
   */
  victimClass?: number;
  /**
   * @generated from protobuf field: optional int32 victim_shield_max = 17;
   */
  victimShieldMax?: number;
  /**
   * @generated from protobuf field: optional int32 victim_shield_new = 18;
   */
  victimShieldNew?: number;
  /**
   * @generated from protobuf field: optional int32 hits = 19;
   */
  hits?: number;
  /**
   * @generated from protobuf field: optional int32 health_lost = 20;
   */
  healthLost?: number;
}
/**
 * @generated from protobuf message PingCommonData
 */
export interface PingCommonData {
  /**
   * @generated from protobuf field: optional uint32 ping_message_id = 1;
   */
  pingMessageId?: number;
  /**
   * @generated from protobuf field: optional CMsgVector ping_location = 2;
   */
  pingLocation?: CMsgVector;
  /**
   * @generated from protobuf field: optional uint32 entity_index = 3;
   */
  entityIndex?: number;
  /**
   * @generated from protobuf field: optional int32 sender_player_slot = 4;
   */
  senderPlayerSlot?: number;
  /**
   * @generated from protobuf field: optional int32 speech_concept = 5;
   */
  speechConcept?: number;
  /**
   * @generated from protobuf field: optional string response_chosen = 6;
   */
  responseChosen?: string;
  /**
   * @generated from protobuf field: optional float cooldown_time = 7;
   */
  cooldownTime?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_MapPing
 */
export interface CCitadelUserMsg_MapPing {
  /**
   * @generated from protobuf field: PingCommonData ping_data = 1;
   */
  pingData?: PingCommonData;
  /**
   * @generated from protobuf field: optional uint32 event_type = 2;
   */
  eventType?: number;
  /**
   * @generated from protobuf field: optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 3;
   */
  pingMarkerAndSoundInfo?: ChatMsgPingMarkerInfo;
  /**
   * @generated from protobuf field: optional bool pinged_enemy_entity = 4;
   */
  pingedEnemyEntity?: boolean;
  /**
   * @generated from protobuf field: optional uint32 pinged_entity_class = 5;
   */
  pingedEntityClass?: number;
  /**
   * @generated from protobuf field: optional bool is_minimap_ping = 6;
   */
  isMinimapPing?: boolean;
  /**
   * @generated from protobuf field: optional string pinged_hero_name = 7;
   */
  pingedHeroName?: string;
  /**
   * @generated from protobuf field: optional bool is_blind_ping = 8;
   */
  isBlindPing?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PingWheel
 */
export interface CCitadelUserMsg_PingWheel {
  /**
   * @generated from protobuf field: PingCommonData ping_data = 1;
   */
  pingData?: PingCommonData;
  /**
   * @generated from protobuf field: optional uint32 ping_wheel_option_id = 2;
   */
  pingWheelOptionId?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityPing
 */
export interface CCitadelUserMsg_AbilityPing {
  /**
   * @generated from protobuf field: optional PingCommonData ping_data = 1;
   */
  pingData?: PingCommonData;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 2;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional float ability_cooldown = 3;
   */
  abilityCooldown?: number;
  /**
   * @generated from protobuf field: optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 4;
   */
  pingMarkerAndSoundInfo?: ChatMsgPingMarkerInfo;
}
/**
 * @generated from protobuf message CCitadelUserMsg_QuickResponse
 */
export interface CCitadelUserMsg_QuickResponse {
  /**
   * @generated from protobuf field: PingCommonData ping_data = 1;
   */
  pingData?: PingCommonData;
  /**
   * @generated from protobuf field: optional uint32 responding_to_ping_message_id = 2;
   */
  respondingToPingMessageId?: number;
  /**
   * @generated from protobuf field: optional int32 responding_to_player_slot = 3;
   */
  respondingToPlayerSlot?: number;
  /**
   * @generated from protobuf field: optional CMsgLaneColor lane_color = 4;
   */
  laneColor?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_MapLine
 */
export interface CCitadelUserMsg_MapLine {
  /**
   * @generated from protobuf field: optional int32 sender_player_slot = 1;
   */
  senderPlayerSlot?: number;
  /**
   * @generated from protobuf field: optional CMsgMapLine mapline = 2;
   */
  mapline?: CMsgMapLine;
}
/**
 * @generated from protobuf message CCitadelUserMsg_TeamRewards
 */
export interface CCitadelUserMsg_TeamRewards {
  /**
   * @generated from protobuf field: optional uint32 xp = 1;
   */
  xp?: number;
  /**
   * @generated from protobuf field: optional uint32 gold = 2;
   */
  gold?: number;
  /**
   * @generated from protobuf field: optional bool winner = 3;
   */
  winner?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_TriggerDamageFlash
 */
export interface CCitadelUserMsg_TriggerDamageFlash {
  /**
   * @generated from protobuf field: optional int32 entindex_flash_victim = 1;
   */
  entindexFlashVictim?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_flash_attacker = 2;
   */
  entindexFlashAttacker?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_flash_hitgroup = 3;
   */
  entindexFlashHitgroup?: number;
  /**
   * @generated from protobuf field: optional uint32 flash_value = 4;
   */
  flashValue?: number;
  /**
   * @generated from protobuf field: optional uint32 flash_type = 5;
   */
  flashType?: number;
  /**
   * @generated from protobuf field: optional uint32 flash_flags = 6;
   */
  flashFlags?: number;
  /**
   * @generated from protobuf field: optional CMsgVector flash_position = 7;
   */
  flashPosition?: CMsgVector;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilitiesChanged
 */
export interface CCitadelUserMsg_AbilitiesChanged {
  /**
   * @generated from protobuf field: optional int32 entindex_purchaser = 1;
   */
  entindexPurchaser?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_ability = 2;
   */
  entindexAbility?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 3;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_AbilitiesChanged.Change change = 4;
   */
  change?: CCitadelUserMsg_AbilitiesChanged_Change;
}
/**
 * @generated from protobuf enum CCitadelUserMsg_AbilitiesChanged.Change
 */
export enum CCitadelUserMsg_AbilitiesChanged_Change {
  /**
   * @generated from protobuf enum value: EInvalid = -1;
   */
  EInvalid = -1,
  /**
   * @generated from protobuf enum value: EPurchased = 0;
   */
  EPurchased = 0,
  /**
   * @generated from protobuf enum value: EUpgraded = 1;
   */
  EUpgraded = 1,
  /**
   * @generated from protobuf enum value: ESold = 2;
   */
  ESold = 2,
  /**
   * @generated from protobuf enum value: ESwappedActivatedAbility = 3;
   */
  ESwappedActivatedAbility = 3,
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityInterrupted
 */
export interface CCitadelUserMsg_AbilityInterrupted {
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 1;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_interrupter = 2;
   */
  entindexInterrupter?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id_interrupted = 3;
   */
  abilityIdInterrupted?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id_interrupter = 4;
   */
  abilityIdInterrupter?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_id_interrupter = 5;
   */
  heroIdInterrupter?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_AbilityLateFailure
 */
export interface CCitadelUserMsg_AbilityLateFailure {
  /**
   * @generated from protobuf field: optional int32 entindex_caster = 1;
   */
  entindexCaster?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_ability = 2;
   */
  entindexAbility?: number;
  /**
   * @generated from protobuf field: optional uint32 failure_type = 3;
   */
  failureType?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary
 */
export interface CCitadelUserMsg_RecentDamageSummary {
  /**
   * @generated from protobuf field: optional int32 player_slot = 1;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records = 2;
   */
  damageRecords: CCitadelUserMsg_RecentDamageSummary_DamageRecord[];
  /**
   * @generated from protobuf field: optional float start_time = 3;
   */
  startTime?: number;
  /**
   * @generated from protobuf field: optional float end_time = 4;
   */
  endTime?: number;
  /**
   * @generated from protobuf field: optional int32 total_damage = 5;
   */
  totalDamage?: number;
  /**
   * @generated from protobuf field: optional int32 lost_gold = 6;
   */
  lostGold?: number;
  /**
   * @generated from protobuf field: repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records = 7;
   */
  modifierRecords: CCitadelUserMsg_RecentDamageSummary_ModifierRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary.DamageRecord
 */
export interface CCitadelUserMsg_RecentDamageSummary_DamageRecord {
  /**
   * @generated from protobuf field: optional int32 damage = 1;
   */
  damage?: number;
  /**
   * @generated from protobuf field: optional int32 hits = 2;
   */
  hits?: number;
  /**
   * @generated from protobuf field: optional uint32 damage_type = 3;
   */
  damageType?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_id = 4;
   */
  heroId?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 5;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional uint32 attacker_class = 6;
   */
  attackerClass?: number;
  /**
   * @generated from protobuf field: optional int32 damage_absorbed = 7;
   */
  damageAbsorbed?: number;
  /**
   * @generated from protobuf field: optional bool is_killing_blow = 8;
   */
  isKillingBlow?: boolean;
  /**
   * @generated from protobuf field: optional uint32 victim_hero_id = 9;
   */
  victimHeroId?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_RecentDamageSummary.ModifierRecord
 */
export interface CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
  /**
   * @generated from protobuf field: optional uint32 ability_id = 1;
   */
  abilityId?: number;
  /**
   * @generated from protobuf field: optional uint32 modifier_type_id = 2;
   */
  modifierTypeId?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_caster = 3;
   */
  entindexCaster?: number;
  /**
   * @generated from protobuf field: optional float start_time = 4;
   */
  startTime?: number;
  /**
   * @generated from protobuf field: optional float end_time = 5;
   */
  endTime?: number;
  /**
   * @generated from protobuf field: optional bool debuff = 6;
   */
  debuff?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_SpectatorTeamChanged
 */
export interface CCitadelUserMsg_SpectatorTeamChanged {
  /**
   * @generated from protobuf field: optional int32 teamnumber = 1;
   */
  teamnumber?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatWheel
 */
export interface CCitadelUserMsg_ChatWheel {
  /**
   * @generated from protobuf field: optional uint32 chat_message_id = 1;
   */
  chatMessageId?: number;
  /**
   * @generated from protobuf field: optional int32 player_slot = 2;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: optional int32 pawn_entindex = 3;
   */
  pawnEntindex?: number;
  /**
   * @generated from protobuf field: optional uint32 account_id = 4;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 hero_id = 5;
   */
  heroId?: number;
  /**
   * @generated from protobuf field: optional string param_1 = 6;
   */
  param1?: string;
  /**
   * @generated from protobuf field: optional CMsgLaneColor lane_color = 7;
   */
  laneColor?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatMsg
 */
export interface CCitadelUserMsg_ChatMsg {
  /**
   * @generated from protobuf field: optional int32 player_slot = 1;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: optional string text = 2;
   */
  text?: string;
  /**
   * @generated from protobuf field: optional bool all_chat = 3;
   */
  allChat?: boolean;
  /**
   * @generated from protobuf field: optional CMsgLaneColor lane_color = 4;
   */
  laneColor?: CMsgLaneColor;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory
 */
export interface CCitadelUserMsg_GoldHistory {
  /**
   * @generated from protobuf field: optional int32 entindex_player = 1;
   */
  entindexPlayer?: number;
  /**
   * @generated from protobuf field: repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records = 2;
   */
  minuteRecords: CCitadelUserMsg_GoldHistory_MinuteRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory.GoldRecord
 */
export interface CCitadelUserMsg_GoldHistory_GoldRecord {
  /**
   * @generated from protobuf field: optional int32 currency_source = 1;
   */
  currencySource?: number;
  /**
   * @generated from protobuf field: optional int32 gold = 2;
   */
  gold?: number;
  /**
   * @generated from protobuf field: optional int32 events = 3;
   */
  events?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GoldHistory.MinuteRecord
 */
export interface CCitadelUserMsg_GoldHistory_MinuteRecord {
  /**
   * @generated from protobuf field: optional int32 match_minute = 1;
   */
  matchMinute?: number;
  /**
   * @generated from protobuf field: repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records = 2;
   */
  goldRecords: CCitadelUserMsg_GoldHistory_GoldRecord[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController
 */
export interface CCitadelUserMsg_CameraController {
  /**
   * @generated from protobuf field: CameraAction action = 1;
   */
  action: CameraAction;
  /**
   * @generated from protobuf field: optional CameraOperation operation = 2;
   */
  operation?: CameraOperation;
  /**
   * @generated from protobuf field: optional CameraParam param = 3;
   */
  param?: CameraParam;
  /**
   * @generated from protobuf field: optional CameraParamMode param_mode = 12;
   */
  paramMode?: CameraParamMode;
  /**
   * @generated from protobuf field: optional float delay = 4;
   */
  delay?: number;
  /**
   * @generated from protobuf field: optional bool relative_values = 11;
   */
  relativeValues?: boolean;
  /**
   * @generated from protobuf field: optional uint32 context_symbol_id = 5;
   */
  contextSymbolId?: number;
  /**
   * @generated from protobuf field: optional uint32 priority = 13;
   */
  priority?: number;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Maintain maintain = 6;
   */
  maintain?: CCitadelUserMsg_CameraController_Maintain;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Approach approach = 7;
   */
  approach?: CCitadelUserMsg_CameraController_Approach;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Spring spring = 8;
   */
  spring?: CCitadelUserMsg_CameraController_Spring;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Lerp lerp = 9;
   */
  lerp?: CCitadelUserMsg_CameraController_Lerp;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_CameraController.Lag lag = 10;
   */
  lag?: CCitadelUserMsg_CameraController_Lag;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Maintain
 */
export interface CCitadelUserMsg_CameraController_Maintain {
  /**
   * @generated from protobuf field: optional float duration = 1;
   */
  duration?: number;
  /**
   * @generated from protobuf field: optional CMsgVector maintain_vector = 2;
   */
  maintainVector?: CMsgVector;
  /**
   * @generated from protobuf field: optional float maintain_float = 3;
   */
  maintainFloat?: number;
  /**
   * @generated from protobuf field: optional bool maintain_current = 4;
   */
  maintainCurrent?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Approach
 */
export interface CCitadelUserMsg_CameraController_Approach {
  /**
   * @generated from protobuf field: optional float speed = 1;
   */
  speed?: number;
  /**
   * @generated from protobuf field: optional float default_speed = 2;
   */
  defaultSpeed?: number;
  /**
   * @generated from protobuf field: optional float acceleration = 3;
   */
  acceleration?: number;
  /**
   * @generated from protobuf field: optional float min_duration = 4;
   */
  minDuration?: number;
  /**
   * @generated from protobuf field: optional float approach_float = 5;
   */
  approachFloat?: number;
  /**
   * @generated from protobuf field: optional CMsgVector approach_vector = 6;
   */
  approachVector?: CMsgVector;
  /**
   * @generated from protobuf field: optional bool chase_default = 7;
   */
  chaseDefault?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Spring
 */
export interface CCitadelUserMsg_CameraController_Spring {
  /**
   * @generated from protobuf field: optional float spring_strength = 1;
   */
  springStrength?: number;
  /**
   * @generated from protobuf field: optional float min_speed = 4;
   */
  minSpeed?: number;
  /**
   * @generated from protobuf field: optional float max_duration = 5;
   */
  maxDuration?: number;
  /**
   * @generated from protobuf field: optional float target_float = 6;
   */
  targetFloat?: number;
  /**
   * @generated from protobuf field: optional CMsgVector target_vector = 7;
   */
  targetVector?: CMsgVector;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Lerp
 */
export interface CCitadelUserMsg_CameraController_Lerp {
  /**
   * @generated from protobuf field: optional float start_float = 1;
   */
  startFloat?: number;
  /**
   * @generated from protobuf field: optional CMsgVector start_vector = 2;
   */
  startVector?: CMsgVector;
  /**
   * @generated from protobuf field: optional float end_float = 3;
   */
  endFloat?: number;
  /**
   * @generated from protobuf field: optional CMsgVector end_vector = 4;
   */
  endVector?: CMsgVector;
  /**
   * @generated from protobuf field: optional float bias = 5;
   */
  bias?: number;
  /**
   * @generated from protobuf field: optional float gain = 6;
   */
  gain?: number;
  /**
   * @generated from protobuf field: optional float duration = 7;
   */
  duration?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_CameraController.Lag
 */
export interface CCitadelUserMsg_CameraController_Lag {
  /**
   * @generated from protobuf field: optional float min_duration = 1;
   */
  minDuration?: number;
  /**
   * @generated from protobuf field: optional float lag_time = 2;
   */
  lagTime?: number;
  /**
   * @generated from protobuf field: optional float max_speed = 3;
   */
  maxSpeed?: number;
  /**
   * @generated from protobuf field: optional float spring_strength = 4;
   */
  springStrength?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PostMatchDetails
 */
export interface CCitadelUserMsg_PostMatchDetails {
  /**
   * @generated from protobuf field: optional bytes match_details = 1;
   */
  matchDetails?: Uint8Array;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ChatEvent
 */
export interface CCitadelUserMsg_ChatEvent {
  /**
   * @generated from protobuf field: optional ECitadelChatMessage type = 1;
   */
  type?: ECitadelChatMessage;
  /**
   * @generated from protobuf field: repeated uint32 values = 2;
   */
  values: number[];
  /**
   * @generated from protobuf field: repeated int32 player_slots = 3;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_HeroKilled
 */
export interface CCitadelUserMsg_HeroKilled {
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 1;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_inflictor = 2;
   */
  entindexInflictor?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_attacker = 3;
   */
  entindexAttacker?: number;
  /**
   * @generated from protobuf field: repeated int32 entindex_assisters = 4;
   */
  entindexAssisters: number[];
  /**
   * @generated from protobuf field: optional int32 entindex_scorer = 5;
   */
  entindexScorer?: number;
  /**
   * @generated from protobuf field: optional int32 respawn_reason = 6;
   */
  respawnReason?: number;
}
/**
 * @generated from protobuf message CCitadelEntityMsg_BreakablePropSpawnDebris
 */
export interface CCitadelEntityMsg_BreakablePropSpawnDebris {
  /**
   * @generated from protobuf field: optional CEntityMsg entity_msg = 1;
   */
  entityMsg?: CEntityMsg;
  /**
   * @generated from protobuf field: optional CMsgVector damage_pos = 2;
   */
  damagePos?: CMsgVector;
  /**
   * @generated from protobuf field: optional float damage = 3;
   */
  damage?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ReturnIdol
 */
export interface CCitadelUserMsg_ReturnIdol {
  /**
   * @generated from protobuf field: optional int32 location_index = 1;
   */
  locationIndex?: number;
  /**
   * @generated from protobuf field: optional CMsgVector return_location = 2;
   */
  returnLocation?: CMsgVector;
  /**
   * @generated from protobuf field: optional bool location_enabled = 3;
   */
  locationEnabled?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_SetClientCameraAngles
 */
export interface CCitadelUserMsg_SetClientCameraAngles {
  /**
   * @generated from protobuf field: optional int32 player_slot = 1;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: optional CMsgQAngle camera_angles = 2;
   */
  cameraAngles?: CMsgQAngle;
}
/**
 * @generated from protobuf message CCitadelUserMessage_BulletHit
 */
export interface CCitadelUserMessage_BulletHit {
  /**
   * @generated from protobuf field: optional int32 shotid = 1;
   */
  shotid?: number;
  /**
   * @generated from protobuf field: optional int32 pellet = 2;
   */
  pellet?: number;
  /**
   * @generated from protobuf field: optional int32 hit_entindex = 3;
   */
  hitEntindex?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_ObjectiveMask
 */
export interface CCitadelUserMessage_ObjectiveMask {
  /**
   * @generated from protobuf field: optional uint64 objective_mask_team0 = 2;
   */
  objectiveMaskTeam0?: bigint;
  /**
   * @generated from protobuf field: optional uint64 objective_mask_team1 = 3;
   */
  objectiveMaskTeam1?: bigint;
}
/**
 * @generated from protobuf message CCitadelUserMessage_ModifierApplied
 */
export interface CCitadelUserMessage_ModifierApplied {
  /**
   * @generated from protobuf field: optional int32 entindex_caster = 1;
   */
  entindexCaster?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_parent = 2;
   */
  entindexParent?: number;
  /**
   * @generated from protobuf field: optional int32 serial_number = 3;
   */
  serialNumber?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_AuraModifierApplied
 */
export interface CCitadelUserMessage_AuraModifierApplied {
  /**
   * @generated from protobuf field: optional int32 entindex_caster = 1;
   */
  entindexCaster?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_target = 2;
   */
  entindexTarget?: number;
  /**
   * @generated from protobuf field: optional uint32 modifier_type_id = 3;
   */
  modifierTypeId?: number;
  /**
   * @generated from protobuf field: optional int32 modifier_serial_number = 4;
   */
  modifierSerialNumber?: number;
  /**
   * @generated from protobuf field: optional float aura_start_time = 5;
   */
  auraStartTime?: number;
  /**
   * @generated from protobuf field: optional float aura_end_time = 6;
   */
  auraEndTime?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ObstructedShotFired
 */
export interface CCitadelUserMsg_ObstructedShotFired {}
/**
 * @generated from protobuf message CCitadelUserMsg_PostProcessingAnim
 */
export interface CCitadelUserMsg_PostProcessingAnim {
  /**
   * @generated from protobuf field: optional int32 entindex_owner = 1;
   */
  entindexOwner?: number;
  /**
   * @generated from protobuf field: optional bool clear_all_states = 2;
   */
  clearAllStates?: boolean;
  /**
   * @generated from protobuf field: optional PostProcessingGameStates state = 3;
   */
  state?: PostProcessingGameStates;
  /**
   * @generated from protobuf field: optional float start_time = 4;
   */
  startTime?: number;
  /**
   * @generated from protobuf field: optional float fade_in_time = 5;
   */
  fadeInTime?: number;
  /**
   * @generated from protobuf field: optional float hold_time = 6;
   */
  holdTime?: number;
  /**
   * @generated from protobuf field: optional float fade_out_time = 7;
   */
  fadeOutTime?: number;
  /**
   * @generated from protobuf field: optional float scale = 8;
   */
  scale?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_DeathReplayData
 */
export interface CCitadelUserMsg_DeathReplayData {
  /**
   * @generated from protobuf field: optional int32 killer_scorer = 1;
   */
  killerScorer?: number;
  /**
   * @generated from protobuf field: optional int32 killer_inflictor = 2;
   */
  killerInflictor?: number;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_RecentDamageSummary damage_summary = 3;
   */
  damageSummary?: CCitadelUserMsg_RecentDamageSummary;
}
/**
 * @generated from protobuf message CCitadelUserMsg_ForceShopClosed
 */
export interface CCitadelUserMsg_ForceShopClosed {}
/**
 * @generated from protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo
 */
export interface CCitadelUserMsg_PlayerLifetimeStatInfo {
  /**
   * @generated from protobuf field: repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats = 1;
   */
  stats: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat[];
  /**
   * @generated from protobuf field: optional uint64 match_id = 2;
   */
  matchId?: bigint;
  /**
   * @generated from protobuf field: optional bool end_of_match = 3;
   */
  endOfMatch?: boolean;
  /**
   * @generated from protobuf field: optional bool is_official_match = 4;
   */
  isOfficialMatch?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo.Stat
 */
export interface CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
  /**
   * @generated from protobuf field: optional string stat_name = 1;
   */
  statName?: string;
  /**
   * @generated from protobuf field: optional uint32 match_total = 2;
   */
  matchTotal?: number;
  /**
   * @generated from protobuf field: optional uint32 lifetime_value = 3;
   */
  lifetimeValue?: number;
  /**
   * @generated from protobuf field: optional uint32 priority = 4;
   */
  priority?: number;
  /**
   * @generated from protobuf field: optional uint32 prev_lifetime_max = 5;
   */
  prevLifetimeMax?: number;
  /**
   * @generated from protobuf field: optional uint32 stat_type = 6;
   */
  statType?: number;
  /**
   * @generated from protobuf field: optional uint32 stat_type_id = 7;
   */
  statTypeId?: number;
}
/**
 * @generated from protobuf message CCitadelUserMsg_StaminaDrained
 */
export interface CCitadelUserMsg_StaminaDrained {
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 1;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional int32 stamina_drained = 2;
   */
  staminaDrained?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_AbilityNotify
 */
export interface CCitadelUserMessage_AbilityNotify {
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 1;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional int32 entindex_attacker = 2;
   */
  entindexAttacker?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 3;
   */
  abilityId?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_CurrencyChanged
 */
export interface CCitadelUserMessage_CurrencyChanged {
  /**
   * @generated from protobuf field: optional int32 entindex_hero_pawn = 1;
   */
  entindexHeroPawn?: number;
  /**
   * @generated from protobuf field: optional int32 currency_type = 2;
   */
  currencyType?: number;
  /**
   * @generated from protobuf field: optional int32 currency_source = 3;
   */
  currencySource?: number;
  /**
   * @generated from protobuf field: optional int32 delta = 4;
   */
  delta?: number;
  /**
   * @generated from protobuf field: optional bool notification = 5;
   */
  notification?: boolean;
  /**
   * @generated from protobuf field: optional int32 entindex_victim = 6;
   */
  entindexVictim?: number;
  /**
   * @generated from protobuf field: optional CMsgVector victim_pos = 7;
   */
  victimPos?: CMsgVector;
  /**
   * @generated from protobuf field: optional int32 playsound = 8;
   */
  playsound?: number;
  /**
   * @generated from protobuf field: optional uint32 ability_id = 9;
   */
  abilityId?: number;
}
/**
 * @generated from protobuf message CCitadelUserMessage_GameOver
 */
export interface CCitadelUserMessage_GameOver {
  /**
   * @generated from protobuf field: optional int32 winning_team = 1;
   */
  winningTeam?: number;
  /**
   * @generated from protobuf field: optional bool just_a_test = 2;
   */
  justATest?: boolean;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GetDamageStatsResponse
 */
export interface CCitadelUserMsg_GetDamageStatsResponse {
  /**
   * @generated from protobuf field: optional uint32 player_slot = 1;
   */
  playerSlot?: number;
  /**
   * @generated from protobuf field: optional string ability_name = 2;
   */
  abilityName?: string;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage = 3;
   */
  damage?: CCitadelUserMsg_GetDamageStatsResponse_StatType;
  /**
   * @generated from protobuf field: optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing = 4;
   */
  healing?: CCitadelUserMsg_GetDamageStatsResponse_StatType;
}
/**
 * @generated from protobuf message CCitadelUserMsg_GetDamageStatsResponse.StatType
 */
export interface CCitadelUserMsg_GetDamageStatsResponse_StatType {
  /**
   * @generated from protobuf field: repeated uint32 target_player_slot = 1 [packed = true];
   */
  targetPlayerSlot: number[];
  /**
   * @generated from protobuf field: repeated uint32 value = 2 [packed = true];
   */
  value: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStartSoundEvent
 */
export interface CCitadelUserMsg_ParticipantStartSoundEvent {
  /**
   * @generated from protobuf field: CMsgSosStartSoundEvent event = 1;
   */
  event?: CMsgSosStartSoundEvent;
  /**
   * @generated from protobuf field: repeated int32 player_slots = 2;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStopSoundEvent
 */
export interface CCitadelUserMsg_ParticipantStopSoundEvent {
  /**
   * @generated from protobuf field: CMsgSosStopSoundEvent event = 1;
   */
  event?: CMsgSosStopSoundEvent;
  /**
   * @generated from protobuf field: repeated int32 player_slots = 2;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantStopSoundEventHash
 */
export interface CCitadelUserMsg_ParticipantStopSoundEventHash {
  /**
   * @generated from protobuf field: CMsgSosStopSoundEventHash event = 1;
   */
  event?: CMsgSosStopSoundEventHash;
  /**
   * @generated from protobuf field: repeated int32 player_slots = 2;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantSetSoundEventParams
 */
export interface CCitadelUserMsg_ParticipantSetSoundEventParams {
  /**
   * @generated from protobuf field: CMsgSosSetSoundEventParams event = 1;
   */
  event?: CMsgSosSetSoundEventParams;
  /**
   * @generated from protobuf field: repeated int32 player_slots = 2;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_ParticipantSetLibraryStackFields
 */
export interface CCitadelUserMsg_ParticipantSetLibraryStackFields {
  /**
   * @generated from protobuf field: CMsgSosSetLibraryStackFields event = 1;
   */
  event?: CMsgSosSetLibraryStackFields;
  /**
   * @generated from protobuf field: repeated int32 player_slots = 2;
   */
  playerSlots: number[];
}
/**
 * @generated from protobuf message CCitadelUserMsg_BossKilled
 */
export interface CCitadelUserMsg_BossKilled {
  /**
   * @generated from protobuf field: optional int32 objective_team = 1;
   */
  objectiveTeam?: number;
  /**
   * @generated from protobuf field: optional int32 objective_mask_change = 2;
   */
  objectiveMaskChange?: number;
  /**
   * @generated from protobuf field: uint32 entity_killed = 3;
   */
  entityKilled: number;
  /**
   * @generated from protobuf field: int32 entity_killed_class = 4;
   */
  entityKilledClass: number;
  /**
   * @generated from protobuf field: uint32 entity_killer = 5;
   */
  entityKiller: number;
  /**
   * @generated from protobuf field: float gametime = 6;
   */
  gametime: number;
}
/**
 * @generated from protobuf enum CitadelUserMessageIds
 */
export enum CitadelUserMessageIds {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_EUserMsg_Damage = 300;
   */
  k_EUserMsg_Damage = 300,
  /**
   * @generated from protobuf enum value: k_EUserMsg_MapPing = 303;
   */
  k_EUserMsg_MapPing = 303,
  /**
   * @generated from protobuf enum value: k_EUserMsg_TeamRewards = 304;
   */
  k_EUserMsg_TeamRewards = 304,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilityFailed = 306;
   */
  k_EUserMsg_AbilityFailed = 306,
  /**
   * @generated from protobuf enum value: k_EUserMsg_TriggerDamageFlash = 308;
   */
  k_EUserMsg_TriggerDamageFlash = 308,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilitiesChanged = 309;
   */
  k_EUserMsg_AbilitiesChanged = 309,
  /**
   * @generated from protobuf enum value: k_EUserMsg_RecentDamageSummary = 310;
   */
  k_EUserMsg_RecentDamageSummary = 310,
  /**
   * @generated from protobuf enum value: k_EUserMsg_SpectatorTeamChanged = 311;
   */
  k_EUserMsg_SpectatorTeamChanged = 311,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ChatWheel = 312;
   */
  k_EUserMsg_ChatWheel = 312,
  /**
   * @generated from protobuf enum value: k_EUserMsg_GoldHistory = 313;
   */
  k_EUserMsg_GoldHistory = 313,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ChatMsg = 314;
   */
  k_EUserMsg_ChatMsg = 314,
  /**
   * @generated from protobuf enum value: k_EUserMsg_QuickResponse = 315;
   */
  k_EUserMsg_QuickResponse = 315,
  /**
   * @generated from protobuf enum value: k_EUserMsg_PostMatchDetails = 316;
   */
  k_EUserMsg_PostMatchDetails = 316,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ChatEvent = 317;
   */
  k_EUserMsg_ChatEvent = 317,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilityInterrupted = 318;
   */
  k_EUserMsg_AbilityInterrupted = 318,
  /**
   * @generated from protobuf enum value: k_EUserMsg_HeroKilled = 319;
   */
  k_EUserMsg_HeroKilled = 319,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ReturnIdol = 320;
   */
  k_EUserMsg_ReturnIdol = 320,
  /**
   * @generated from protobuf enum value: k_EUserMsg_SetClientCameraAngles = 321;
   */
  k_EUserMsg_SetClientCameraAngles = 321,
  /**
   * @generated from protobuf enum value: k_EUserMsg_MapLine = 322;
   */
  k_EUserMsg_MapLine = 322,
  /**
   * @generated from protobuf enum value: k_EUserMsg_BulletHit = 323;
   */
  k_EUserMsg_BulletHit = 323,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ObjectiveMask = 324;
   */
  k_EUserMsg_ObjectiveMask = 324,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ModifierApplied = 325;
   */
  k_EUserMsg_ModifierApplied = 325,
  /**
   * @generated from protobuf enum value: k_EUserMsg_CameraController = 326;
   */
  k_EUserMsg_CameraController = 326,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AuraModifierApplied = 327;
   */
  k_EUserMsg_AuraModifierApplied = 327,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ObstructedShotFired = 329;
   */
  k_EUserMsg_ObstructedShotFired = 329,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilityLateFailure = 330;
   */
  k_EUserMsg_AbilityLateFailure = 330,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilityPing = 331;
   */
  k_EUserMsg_AbilityPing = 331,
  /**
   * @generated from protobuf enum value: k_EUserMsg_PostProcessingAnim = 332;
   */
  k_EUserMsg_PostProcessingAnim = 332,
  /**
   * @generated from protobuf enum value: k_EUserMsg_DeathReplayData = 333;
   */
  k_EUserMsg_DeathReplayData = 333,
  /**
   * @generated from protobuf enum value: k_EUserMsg_PlayerLifetimeStatInfo = 334;
   */
  k_EUserMsg_PlayerLifetimeStatInfo = 334,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ForceShopClosed = 336;
   */
  k_EUserMsg_ForceShopClosed = 336,
  /**
   * @generated from protobuf enum value: k_EUserMsg_StaminaDrained = 337;
   */
  k_EUserMsg_StaminaDrained = 337,
  /**
   * @generated from protobuf enum value: k_EUserMsg_AbilityNotify = 338;
   */
  k_EUserMsg_AbilityNotify = 338,
  /**
   * @generated from protobuf enum value: k_EUserMsg_GetDamageStatsResponse = 339;
   */
  k_EUserMsg_GetDamageStatsResponse = 339,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ParticipantStartSoundEvent = 340;
   */
  k_EUserMsg_ParticipantStartSoundEvent = 340,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ParticipantStopSoundEvent = 341;
   */
  k_EUserMsg_ParticipantStopSoundEvent = 341,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ParticipantStopSoundEventHash = 342;
   */
  k_EUserMsg_ParticipantStopSoundEventHash = 342,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ParticipantSetSoundEventParams = 343;
   */
  k_EUserMsg_ParticipantSetSoundEventParams = 343,
  /**
   * @generated from protobuf enum value: k_EUserMsg_ParticipantSetLibraryStackFields = 344;
   */
  k_EUserMsg_ParticipantSetLibraryStackFields = 344,
  /**
   * @generated from protobuf enum value: k_EUserMsg_CurrencyChanged = 345;
   */
  k_EUserMsg_CurrencyChanged = 345,
  /**
   * @generated from protobuf enum value: k_EUserMsg_GameOver = 346;
   */
  k_EUserMsg_GameOver = 346,
  /**
   * @generated from protobuf enum value: k_EUserMsg_BossKilled = 347;
   */
  k_EUserMsg_BossKilled = 347,
}
/**
 * @generated from protobuf enum CitadelEntityMessageIds
 */
export enum CitadelEntityMessageIds {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_EEntityMsg_BreakablePropSpawnDebris = 500;
   */
  k_EEntityMsg_BreakablePropSpawnDebris = 500,
}
/**
 * @generated from protobuf enum ChatMsgPingMarkerInfo
 */
export enum ChatMsgPingMarkerInfo {
  /**
   * @generated from protobuf enum value: k_EPingMarkerInfo_ShowMarkerAndSound = 0;
   */
  k_EPingMarkerInfo_ShowMarkerAndSound = 0,
  /**
   * @generated from protobuf enum value: k_EPingMarkerInfo_HideMarkerAndSound = 1;
   */
  k_EPingMarkerInfo_HideMarkerAndSound = 1,
  /**
   * @generated from protobuf enum value: k_EPingMarkerInfo_ShowMarkerOnSender = 2;
   */
  k_EPingMarkerInfo_ShowMarkerOnSender = 2,
  /**
   * @generated from protobuf enum value: k_EPingMarkerInfo_OnlyShowMarker = 3;
   */
  k_EPingMarkerInfo_OnlyShowMarker = 3,
  /**
   * @generated from protobuf enum value: k_EPingMarkerInfo_OnlyPlaySound = 4;
   */
  k_EPingMarkerInfo_OnlyPlaySound = 4,
}
/**
 * @generated from protobuf enum CameraOperation
 */
export enum CameraOperation {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_ECameraOp_Maintain = 2;
   */
  k_ECameraOp_Maintain = 2,
  /**
   * @generated from protobuf enum value: k_ECameraOp_Approach = 3;
   */
  k_ECameraOp_Approach = 3,
  /**
   * @generated from protobuf enum value: k_ECameraOp_Spring = 4;
   */
  k_ECameraOp_Spring = 4,
  /**
   * @generated from protobuf enum value: k_ECameraOp_Lerp = 5;
   */
  k_ECameraOp_Lerp = 5,
  /**
   * @generated from protobuf enum value: k_ECameraOp_Lag = 6;
   */
  k_ECameraOp_Lag = 6,
}
/**
 * @generated from protobuf enum CameraParam
 */
export enum CameraParam {
  /**
   * @generated from protobuf enum value: k_EParam_ClearAllOps = 0;
   */
  k_EParam_ClearAllOps = 0,
  /**
   * @generated from protobuf enum value: k_EParam_ClearAllOpsForContext = 1;
   */
  k_EParam_ClearAllOpsForContext = 1,
  /**
   * @generated from protobuf enum value: k_EParam_Distance = 2;
   */
  k_EParam_Distance = 2,
  /**
   * @generated from protobuf enum value: k_EParam_FOV = 3;
   */
  k_EParam_FOV = 3,
  /**
   * @generated from protobuf enum value: k_EParam_TargetPosition = 4;
   */
  k_EParam_TargetPosition = 4,
  /**
   * @generated from protobuf enum value: k_EParam_VertOffset = 5;
   */
  k_EParam_VertOffset = 5,
  /**
   * @generated from protobuf enum value: k_EParam_HorizOffset = 6;
   */
  k_EParam_HorizOffset = 6,
}
/**
 * @generated from protobuf enum CameraParamMode
 */
export enum CameraParamMode {
  /**
   * @generated from protobuf enum value: k_EParamMode_AllowInOneContext = 0;
   */
  k_EParamMode_AllowInOneContext = 0,
  /**
   * @generated from protobuf enum value: k_EParamMode_AllowInMultipleContexts = 1;
   */
  k_EParamMode_AllowInMultipleContexts = 1,
}
/**
 * @generated from protobuf enum CameraAction
 */
export enum CameraAction {
  /**
   * @generated from protobuf enum value: k_EAction_AddOp = 0;
   */
  k_EAction_AddOp = 0,
  /**
   * @generated from protobuf enum value: k_EAction_ClearAllOps = 1;
   */
  k_EAction_ClearAllOps = 1,
  /**
   * @generated from protobuf enum value: k_EAction_ClearOpsForContext = 2;
   */
  k_EAction_ClearOpsForContext = 2,
}
/**
 * @generated from protobuf enum ECitadelChatMessage
 */
export enum ECitadelChatMessage {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 1;
   */
  CITADEL_CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 1,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_UNPAUSED = 2;
   */
  CITADEL_CHAT_MESSAGE_UNPAUSED = 2,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED = 3;
   */
  CITADEL_CHAT_MESSAGE_AUTO_UNPAUSED = 3,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN = 4;
   */
  CITADEL_CHAT_MESSAGE_PAUSE_COUNTDOWN = 4,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PAUSED = 5;
   */
  CITADEL_CHAT_MESSAGE_PAUSED = 5,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_YOUPAUSED = 6;
   */
  CITADEL_CHAT_MESSAGE_YOUPAUSED = 6,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTPAUSE = 7;
   */
  CITADEL_CHAT_MESSAGE_CANTPAUSE = 7,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM = 8;
   */
  CITADEL_CHAT_MESSAGE_CANTUNPAUSETEAM = 8,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_NOPAUSESLEFT = 9;
   */
  CITADEL_CHAT_MESSAGE_NOPAUSESLEFT = 9,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_CANTPAUSEYET = 10;
   */
  CITADEL_CHAT_MESSAGE_CANTPAUSEYET = 10,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN = 11;
   */
  CITADEL_CHAT_MESSAGE_PREGAME_COUNTDOWN = 11,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_NOTEAMPAUSESLEFT = 12;
   */
  CITADEL_CHAT_MESSAGE_NOTEAMPAUSESLEFT = 12,
  /**
   * @generated from protobuf enum value: CITADEL_CHAT_MESSAGE_COMMS_RESTRICTED = 13;
   */
  CITADEL_CHAT_MESSAGE_COMMS_RESTRICTED = 13,
}
/**
 * @generated from protobuf enum PostProcessingGameStates
 */
export enum PostProcessingGameStates {
  /**
   * @generated from protobuf enum value: PostProcState_Killed = 0;
   */
  PostProcState_Killed = 0,
  /**
   * @generated from protobuf enum value: PostProcState_Black = 1;
   */
  PostProcState_Black = 1,
  /**
   * @generated from protobuf enum value: PostProcState_Blinded = 2;
   */
  PostProcState_Blinded = 2,
  /**
   * @generated from protobuf enum value: PostProcState_ShivPossessed = 3;
   */
  PostProcState_ShivPossessed = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class CUserMessageEmpty$Type extends MessageType<CUserMessageEmpty> {
  constructor() {
    super("CUserMessageEmpty", [
      {
        no: 1,
        name: "empty",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CUserMessageEmpty>): CUserMessageEmpty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CUserMessageEmpty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CUserMessageEmpty,
  ): CUserMessageEmpty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 empty */ 1:
          message.empty = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CUserMessageEmpty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 empty = 1; */
    if (message.empty !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.empty);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CUserMessageEmpty
 */
export const CUserMessageEmpty = new CUserMessageEmpty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_Damage$Type extends MessageType<CCitadelUserMessage_Damage> {
  constructor() {
    super("CCitadelUserMessage_Damage", [
      {
        no: 1,
        name: "damage",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "pre_damage",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "type",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "citadel_type",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 5, name: "origin", kind: "message", T: () => CMsgVector },
      {
        no: 6,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 7,
        name: "entindex_inflictor",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: "entindex_attacker",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "entindex_ability",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 10,
        name: "damage_absorbed",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 11,
        name: "victim_health_max",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 12,
        name: "victim_health_new",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 13,
        name: "flags",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 14,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "attacker_class",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "victim_class",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "victim_shield_max",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 18,
        name: "victim_shield_new",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 19,
        name: "hits",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 20,
        name: "health_lost",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_Damage>,
  ): CCitadelUserMessage_Damage {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_Damage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_Damage,
  ): CCitadelUserMessage_Damage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 damage */ 1:
          message.damage = reader.int32();
          break;
        case /* optional int32 pre_damage */ 2:
          message.preDamage = reader.int32();
          break;
        case /* optional int32 type */ 3:
          message.type = reader.int32();
          break;
        case /* optional int32 citadel_type */ 4:
          message.citadelType = reader.int32();
          break;
        case /* optional CMsgVector origin */ 5:
          message.origin = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.origin,
          );
          break;
        case /* optional int32 entindex_victim */ 6:
          message.entindexVictim = reader.int32();
          break;
        case /* optional int32 entindex_inflictor */ 7:
          message.entindexInflictor = reader.int32();
          break;
        case /* optional int32 entindex_attacker */ 8:
          message.entindexAttacker = reader.int32();
          break;
        case /* optional int32 entindex_ability */ 9:
          message.entindexAbility = reader.int32();
          break;
        case /* optional int32 damage_absorbed */ 10:
          message.damageAbsorbed = reader.int32();
          break;
        case /* optional int32 victim_health_max */ 11:
          message.victimHealthMax = reader.int32();
          break;
        case /* optional int32 victim_health_new */ 12:
          message.victimHealthNew = reader.int32();
          break;
        case /* optional uint64 flags */ 13:
          message.flags = reader.uint64().toBigInt();
          break;
        case /* optional uint32 ability_id */ 14:
          message.abilityId = reader.uint32();
          break;
        case /* optional uint32 attacker_class */ 15:
          message.attackerClass = reader.uint32();
          break;
        case /* optional uint32 victim_class */ 16:
          message.victimClass = reader.uint32();
          break;
        case /* optional int32 victim_shield_max */ 17:
          message.victimShieldMax = reader.int32();
          break;
        case /* optional int32 victim_shield_new */ 18:
          message.victimShieldNew = reader.int32();
          break;
        case /* optional int32 hits */ 19:
          message.hits = reader.int32();
          break;
        case /* optional int32 health_lost */ 20:
          message.healthLost = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_Damage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 damage = 1; */
    if (message.damage !== undefined)
      writer.tag(1, WireType.Varint).int32(message.damage);
    /* optional int32 pre_damage = 2; */
    if (message.preDamage !== undefined)
      writer.tag(2, WireType.Varint).int32(message.preDamage);
    /* optional int32 type = 3; */
    if (message.type !== undefined)
      writer.tag(3, WireType.Varint).int32(message.type);
    /* optional int32 citadel_type = 4; */
    if (message.citadelType !== undefined)
      writer.tag(4, WireType.Varint).int32(message.citadelType);
    /* optional CMsgVector origin = 5; */
    if (message.origin)
      CMsgVector.internalBinaryWrite(
        message.origin,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional int32 entindex_victim = 6; */
    if (message.entindexVictim !== undefined)
      writer.tag(6, WireType.Varint).int32(message.entindexVictim);
    /* optional int32 entindex_inflictor = 7; */
    if (message.entindexInflictor !== undefined)
      writer.tag(7, WireType.Varint).int32(message.entindexInflictor);
    /* optional int32 entindex_attacker = 8; */
    if (message.entindexAttacker !== undefined)
      writer.tag(8, WireType.Varint).int32(message.entindexAttacker);
    /* optional int32 entindex_ability = 9; */
    if (message.entindexAbility !== undefined)
      writer.tag(9, WireType.Varint).int32(message.entindexAbility);
    /* optional int32 damage_absorbed = 10; */
    if (message.damageAbsorbed !== undefined)
      writer.tag(10, WireType.Varint).int32(message.damageAbsorbed);
    /* optional int32 victim_health_max = 11; */
    if (message.victimHealthMax !== undefined)
      writer.tag(11, WireType.Varint).int32(message.victimHealthMax);
    /* optional int32 victim_health_new = 12; */
    if (message.victimHealthNew !== undefined)
      writer.tag(12, WireType.Varint).int32(message.victimHealthNew);
    /* optional uint64 flags = 13; */
    if (message.flags !== undefined)
      writer.tag(13, WireType.Varint).uint64(message.flags);
    /* optional uint32 ability_id = 14; */
    if (message.abilityId !== undefined)
      writer.tag(14, WireType.Varint).uint32(message.abilityId);
    /* optional uint32 attacker_class = 15; */
    if (message.attackerClass !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.attackerClass);
    /* optional uint32 victim_class = 16; */
    if (message.victimClass !== undefined)
      writer.tag(16, WireType.Varint).uint32(message.victimClass);
    /* optional int32 victim_shield_max = 17; */
    if (message.victimShieldMax !== undefined)
      writer.tag(17, WireType.Varint).int32(message.victimShieldMax);
    /* optional int32 victim_shield_new = 18; */
    if (message.victimShieldNew !== undefined)
      writer.tag(18, WireType.Varint).int32(message.victimShieldNew);
    /* optional int32 hits = 19; */
    if (message.hits !== undefined)
      writer.tag(19, WireType.Varint).int32(message.hits);
    /* optional int32 health_lost = 20; */
    if (message.healthLost !== undefined)
      writer.tag(20, WireType.Varint).int32(message.healthLost);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_Damage
 */
export const CCitadelUserMessage_Damage = new CCitadelUserMessage_Damage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingCommonData$Type extends MessageType<PingCommonData> {
  constructor() {
    super("PingCommonData", [
      {
        no: 1,
        name: "ping_message_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 2, name: "ping_location", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "entity_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "sender_player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "speech_concept",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 6,
        name: "response_chosen",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: "cooldown_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(value?: PartialMessage<PingCommonData>): PingCommonData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<PingCommonData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PingCommonData,
  ): PingCommonData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 ping_message_id */ 1:
          message.pingMessageId = reader.uint32();
          break;
        case /* optional CMsgVector ping_location */ 2:
          message.pingLocation = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingLocation,
          );
          break;
        case /* optional uint32 entity_index */ 3:
          message.entityIndex = reader.uint32();
          break;
        case /* optional int32 sender_player_slot */ 4:
          message.senderPlayerSlot = reader.int32();
          break;
        case /* optional int32 speech_concept */ 5:
          message.speechConcept = reader.int32();
          break;
        case /* optional string response_chosen */ 6:
          message.responseChosen = reader.string();
          break;
        case /* optional float cooldown_time */ 7:
          message.cooldownTime = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PingCommonData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 ping_message_id = 1; */
    if (message.pingMessageId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.pingMessageId);
    /* optional CMsgVector ping_location = 2; */
    if (message.pingLocation)
      CMsgVector.internalBinaryWrite(
        message.pingLocation,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 entity_index = 3; */
    if (message.entityIndex !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.entityIndex);
    /* optional int32 sender_player_slot = 4; */
    if (message.senderPlayerSlot !== undefined)
      writer.tag(4, WireType.Varint).int32(message.senderPlayerSlot);
    /* optional int32 speech_concept = 5; */
    if (message.speechConcept !== undefined)
      writer.tag(5, WireType.Varint).int32(message.speechConcept);
    /* optional string response_chosen = 6; */
    if (message.responseChosen !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.responseChosen);
    /* optional float cooldown_time = 7; */
    if (message.cooldownTime !== undefined)
      writer.tag(7, WireType.Bit32).float(message.cooldownTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message PingCommonData
 */
export const PingCommonData = new PingCommonData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_MapPing$Type extends MessageType<CCitadelUserMsg_MapPing> {
  constructor() {
    super("CCitadelUserMsg_MapPing", [
      { no: 1, name: "ping_data", kind: "message", T: () => PingCommonData },
      {
        no: 2,
        name: "event_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "ping_marker_and_sound_info",
        kind: "enum",
        opt: true,
        T: () => ["ChatMsgPingMarkerInfo", ChatMsgPingMarkerInfo],
      },
      {
        no: 4,
        name: "pinged_enemy_entity",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "pinged_entity_class",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "is_minimap_ping",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 7,
        name: "pinged_hero_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "is_blind_ping",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_MapPing>,
  ): CCitadelUserMsg_MapPing {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_MapPing>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_MapPing,
  ): CCitadelUserMsg_MapPing {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* PingCommonData ping_data */ 1:
          message.pingData = PingCommonData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        case /* optional uint32 event_type */ 2:
          message.eventType = reader.uint32();
          break;
        case /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info */ 3:
          message.pingMarkerAndSoundInfo = reader.int32();
          break;
        case /* optional bool pinged_enemy_entity */ 4:
          message.pingedEnemyEntity = reader.bool();
          break;
        case /* optional uint32 pinged_entity_class */ 5:
          message.pingedEntityClass = reader.uint32();
          break;
        case /* optional bool is_minimap_ping */ 6:
          message.isMinimapPing = reader.bool();
          break;
        case /* optional string pinged_hero_name */ 7:
          message.pingedHeroName = reader.string();
          break;
        case /* optional bool is_blind_ping */ 8:
          message.isBlindPing = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_MapPing,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* PingCommonData ping_data = 1; */
    if (message.pingData)
      PingCommonData.internalBinaryWrite(
        message.pingData,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 event_type = 2; */
    if (message.eventType !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.eventType);
    /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 3; */
    if (message.pingMarkerAndSoundInfo !== undefined)
      writer.tag(3, WireType.Varint).int32(message.pingMarkerAndSoundInfo);
    /* optional bool pinged_enemy_entity = 4; */
    if (message.pingedEnemyEntity !== undefined)
      writer.tag(4, WireType.Varint).bool(message.pingedEnemyEntity);
    /* optional uint32 pinged_entity_class = 5; */
    if (message.pingedEntityClass !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.pingedEntityClass);
    /* optional bool is_minimap_ping = 6; */
    if (message.isMinimapPing !== undefined)
      writer.tag(6, WireType.Varint).bool(message.isMinimapPing);
    /* optional string pinged_hero_name = 7; */
    if (message.pingedHeroName !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.pingedHeroName);
    /* optional bool is_blind_ping = 8; */
    if (message.isBlindPing !== undefined)
      writer.tag(8, WireType.Varint).bool(message.isBlindPing);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_MapPing
 */
export const CCitadelUserMsg_MapPing = new CCitadelUserMsg_MapPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PingWheel$Type extends MessageType<CCitadelUserMsg_PingWheel> {
  constructor() {
    super("CCitadelUserMsg_PingWheel", [
      { no: 1, name: "ping_data", kind: "message", T: () => PingCommonData },
      {
        no: 2,
        name: "ping_wheel_option_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_PingWheel>,
  ): CCitadelUserMsg_PingWheel {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_PingWheel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_PingWheel,
  ): CCitadelUserMsg_PingWheel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* PingCommonData ping_data */ 1:
          message.pingData = PingCommonData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        case /* optional uint32 ping_wheel_option_id */ 2:
          message.pingWheelOptionId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_PingWheel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* PingCommonData ping_data = 1; */
    if (message.pingData)
      PingCommonData.internalBinaryWrite(
        message.pingData,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 ping_wheel_option_id = 2; */
    if (message.pingWheelOptionId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.pingWheelOptionId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PingWheel
 */
export const CCitadelUserMsg_PingWheel = new CCitadelUserMsg_PingWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityPing$Type extends MessageType<CCitadelUserMsg_AbilityPing> {
  constructor() {
    super("CCitadelUserMsg_AbilityPing", [
      { no: 1, name: "ping_data", kind: "message", T: () => PingCommonData },
      {
        no: 2,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "ability_cooldown",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "ping_marker_and_sound_info",
        kind: "enum",
        opt: true,
        T: () => ["ChatMsgPingMarkerInfo", ChatMsgPingMarkerInfo],
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_AbilityPing>,
  ): CCitadelUserMsg_AbilityPing {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_AbilityPing>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_AbilityPing,
  ): CCitadelUserMsg_AbilityPing {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional PingCommonData ping_data */ 1:
          message.pingData = PingCommonData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        case /* optional uint32 ability_id */ 2:
          message.abilityId = reader.uint32();
          break;
        case /* optional float ability_cooldown */ 3:
          message.abilityCooldown = reader.float();
          break;
        case /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info */ 4:
          message.pingMarkerAndSoundInfo = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_AbilityPing,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional PingCommonData ping_data = 1; */
    if (message.pingData)
      PingCommonData.internalBinaryWrite(
        message.pingData,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 ability_id = 2; */
    if (message.abilityId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.abilityId);
    /* optional float ability_cooldown = 3; */
    if (message.abilityCooldown !== undefined)
      writer.tag(3, WireType.Bit32).float(message.abilityCooldown);
    /* optional ChatMsgPingMarkerInfo ping_marker_and_sound_info = 4; */
    if (message.pingMarkerAndSoundInfo !== undefined)
      writer.tag(4, WireType.Varint).int32(message.pingMarkerAndSoundInfo);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityPing
 */
export const CCitadelUserMsg_AbilityPing =
  new CCitadelUserMsg_AbilityPing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_QuickResponse$Type extends MessageType<CCitadelUserMsg_QuickResponse> {
  constructor() {
    super("CCitadelUserMsg_QuickResponse", [
      { no: 1, name: "ping_data", kind: "message", T: () => PingCommonData },
      {
        no: 2,
        name: "responding_to_ping_message_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "responding_to_player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "lane_color",
        kind: "enum",
        opt: true,
        T: () => ["CMsgLaneColor", CMsgLaneColor],
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_QuickResponse>,
  ): CCitadelUserMsg_QuickResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_QuickResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_QuickResponse,
  ): CCitadelUserMsg_QuickResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* PingCommonData ping_data */ 1:
          message.pingData = PingCommonData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        case /* optional uint32 responding_to_ping_message_id */ 2:
          message.respondingToPingMessageId = reader.uint32();
          break;
        case /* optional int32 responding_to_player_slot */ 3:
          message.respondingToPlayerSlot = reader.int32();
          break;
        case /* optional CMsgLaneColor lane_color */ 4:
          message.laneColor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_QuickResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* PingCommonData ping_data = 1; */
    if (message.pingData)
      PingCommonData.internalBinaryWrite(
        message.pingData,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 responding_to_ping_message_id = 2; */
    if (message.respondingToPingMessageId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.respondingToPingMessageId);
    /* optional int32 responding_to_player_slot = 3; */
    if (message.respondingToPlayerSlot !== undefined)
      writer.tag(3, WireType.Varint).int32(message.respondingToPlayerSlot);
    /* optional CMsgLaneColor lane_color = 4; */
    if (message.laneColor !== undefined)
      writer.tag(4, WireType.Varint).int32(message.laneColor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_QuickResponse
 */
export const CCitadelUserMsg_QuickResponse =
  new CCitadelUserMsg_QuickResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_MapLine$Type extends MessageType<CCitadelUserMsg_MapLine> {
  constructor() {
    super("CCitadelUserMsg_MapLine", [
      {
        no: 1,
        name: "sender_player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "mapline", kind: "message", T: () => CMsgMapLine },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_MapLine>,
  ): CCitadelUserMsg_MapLine {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_MapLine>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_MapLine,
  ): CCitadelUserMsg_MapLine {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 sender_player_slot */ 1:
          message.senderPlayerSlot = reader.int32();
          break;
        case /* optional CMsgMapLine mapline */ 2:
          message.mapline = CMsgMapLine.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.mapline,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_MapLine,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 sender_player_slot = 1; */
    if (message.senderPlayerSlot !== undefined)
      writer.tag(1, WireType.Varint).int32(message.senderPlayerSlot);
    /* optional CMsgMapLine mapline = 2; */
    if (message.mapline)
      CMsgMapLine.internalBinaryWrite(
        message.mapline,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_MapLine
 */
export const CCitadelUserMsg_MapLine = new CCitadelUserMsg_MapLine$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_TeamRewards$Type extends MessageType<CCitadelUserMsg_TeamRewards> {
  constructor() {
    super("CCitadelUserMsg_TeamRewards", [
      {
        no: 1,
        name: "xp",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "gold",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "winner",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_TeamRewards>,
  ): CCitadelUserMsg_TeamRewards {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_TeamRewards>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_TeamRewards,
  ): CCitadelUserMsg_TeamRewards {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 xp */ 1:
          message.xp = reader.uint32();
          break;
        case /* optional uint32 gold */ 2:
          message.gold = reader.uint32();
          break;
        case /* optional bool winner */ 3:
          message.winner = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_TeamRewards,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 xp = 1; */
    if (message.xp !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.xp);
    /* optional uint32 gold = 2; */
    if (message.gold !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.gold);
    /* optional bool winner = 3; */
    if (message.winner !== undefined)
      writer.tag(3, WireType.Varint).bool(message.winner);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_TeamRewards
 */
export const CCitadelUserMsg_TeamRewards =
  new CCitadelUserMsg_TeamRewards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_TriggerDamageFlash$Type extends MessageType<CCitadelUserMsg_TriggerDamageFlash> {
  constructor() {
    super("CCitadelUserMsg_TriggerDamageFlash", [
      {
        no: 1,
        name: "entindex_flash_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_flash_attacker",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "entindex_flash_hitgroup",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "flash_value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "flash_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "flash_flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 7, name: "flash_position", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_TriggerDamageFlash>,
  ): CCitadelUserMsg_TriggerDamageFlash {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_TriggerDamageFlash>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_TriggerDamageFlash,
  ): CCitadelUserMsg_TriggerDamageFlash {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_flash_victim */ 1:
          message.entindexFlashVictim = reader.int32();
          break;
        case /* optional int32 entindex_flash_attacker */ 2:
          message.entindexFlashAttacker = reader.int32();
          break;
        case /* optional int32 entindex_flash_hitgroup */ 3:
          message.entindexFlashHitgroup = reader.int32();
          break;
        case /* optional uint32 flash_value */ 4:
          message.flashValue = reader.uint32();
          break;
        case /* optional uint32 flash_type */ 5:
          message.flashType = reader.uint32();
          break;
        case /* optional uint32 flash_flags */ 6:
          message.flashFlags = reader.uint32();
          break;
        case /* optional CMsgVector flash_position */ 7:
          message.flashPosition = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.flashPosition,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_TriggerDamageFlash,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_flash_victim = 1; */
    if (message.entindexFlashVictim !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexFlashVictim);
    /* optional int32 entindex_flash_attacker = 2; */
    if (message.entindexFlashAttacker !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexFlashAttacker);
    /* optional int32 entindex_flash_hitgroup = 3; */
    if (message.entindexFlashHitgroup !== undefined)
      writer.tag(3, WireType.Varint).int32(message.entindexFlashHitgroup);
    /* optional uint32 flash_value = 4; */
    if (message.flashValue !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.flashValue);
    /* optional uint32 flash_type = 5; */
    if (message.flashType !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.flashType);
    /* optional uint32 flash_flags = 6; */
    if (message.flashFlags !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.flashFlags);
    /* optional CMsgVector flash_position = 7; */
    if (message.flashPosition)
      CMsgVector.internalBinaryWrite(
        message.flashPosition,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_TriggerDamageFlash
 */
export const CCitadelUserMsg_TriggerDamageFlash =
  new CCitadelUserMsg_TriggerDamageFlash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilitiesChanged$Type extends MessageType<CCitadelUserMsg_AbilitiesChanged> {
  constructor() {
    super("CCitadelUserMsg_AbilitiesChanged", [
      {
        no: 1,
        name: "entindex_purchaser",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_ability",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "change",
        kind: "enum",
        opt: true,
        T: () => [
          "CCitadelUserMsg_AbilitiesChanged.Change",
          CCitadelUserMsg_AbilitiesChanged_Change,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_AbilitiesChanged>,
  ): CCitadelUserMsg_AbilitiesChanged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_AbilitiesChanged>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_AbilitiesChanged,
  ): CCitadelUserMsg_AbilitiesChanged {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_purchaser */ 1:
          message.entindexPurchaser = reader.int32();
          break;
        case /* optional int32 entindex_ability */ 2:
          message.entindexAbility = reader.int32();
          break;
        case /* optional uint32 ability_id */ 3:
          message.abilityId = reader.uint32();
          break;
        case /* optional CCitadelUserMsg_AbilitiesChanged.Change change */ 4:
          message.change = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_AbilitiesChanged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_purchaser = 1; */
    if (message.entindexPurchaser !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexPurchaser);
    /* optional int32 entindex_ability = 2; */
    if (message.entindexAbility !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexAbility);
    /* optional uint32 ability_id = 3; */
    if (message.abilityId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.abilityId);
    /* optional CCitadelUserMsg_AbilitiesChanged.Change change = 4; */
    if (message.change !== undefined)
      writer.tag(4, WireType.Varint).int32(message.change);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilitiesChanged
 */
export const CCitadelUserMsg_AbilitiesChanged =
  new CCitadelUserMsg_AbilitiesChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityInterrupted$Type extends MessageType<CCitadelUserMsg_AbilityInterrupted> {
  constructor() {
    super("CCitadelUserMsg_AbilityInterrupted", [
      {
        no: 1,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_interrupter",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "ability_id_interrupted",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "ability_id_interrupter",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "hero_id_interrupter",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_AbilityInterrupted>,
  ): CCitadelUserMsg_AbilityInterrupted {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_AbilityInterrupted>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_AbilityInterrupted,
  ): CCitadelUserMsg_AbilityInterrupted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_victim */ 1:
          message.entindexVictim = reader.int32();
          break;
        case /* optional int32 entindex_interrupter */ 2:
          message.entindexInterrupter = reader.int32();
          break;
        case /* optional uint32 ability_id_interrupted */ 3:
          message.abilityIdInterrupted = reader.uint32();
          break;
        case /* optional uint32 ability_id_interrupter */ 4:
          message.abilityIdInterrupter = reader.uint32();
          break;
        case /* optional uint32 hero_id_interrupter */ 5:
          message.heroIdInterrupter = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_AbilityInterrupted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_victim = 1; */
    if (message.entindexVictim !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexVictim);
    /* optional int32 entindex_interrupter = 2; */
    if (message.entindexInterrupter !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexInterrupter);
    /* optional uint32 ability_id_interrupted = 3; */
    if (message.abilityIdInterrupted !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.abilityIdInterrupted);
    /* optional uint32 ability_id_interrupter = 4; */
    if (message.abilityIdInterrupter !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.abilityIdInterrupter);
    /* optional uint32 hero_id_interrupter = 5; */
    if (message.heroIdInterrupter !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.heroIdInterrupter);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityInterrupted
 */
export const CCitadelUserMsg_AbilityInterrupted =
  new CCitadelUserMsg_AbilityInterrupted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_AbilityLateFailure$Type extends MessageType<CCitadelUserMsg_AbilityLateFailure> {
  constructor() {
    super("CCitadelUserMsg_AbilityLateFailure", [
      {
        no: 1,
        name: "entindex_caster",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_ability",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "failure_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_AbilityLateFailure>,
  ): CCitadelUserMsg_AbilityLateFailure {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_AbilityLateFailure>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_AbilityLateFailure,
  ): CCitadelUserMsg_AbilityLateFailure {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_caster */ 1:
          message.entindexCaster = reader.int32();
          break;
        case /* optional int32 entindex_ability */ 2:
          message.entindexAbility = reader.int32();
          break;
        case /* optional uint32 failure_type */ 3:
          message.failureType = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_AbilityLateFailure,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_caster = 1; */
    if (message.entindexCaster !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexCaster);
    /* optional int32 entindex_ability = 2; */
    if (message.entindexAbility !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexAbility);
    /* optional uint32 failure_type = 3; */
    if (message.failureType !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.failureType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_AbilityLateFailure
 */
export const CCitadelUserMsg_AbilityLateFailure =
  new CCitadelUserMsg_AbilityLateFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary> {
  constructor() {
    super("CCitadelUserMsg_RecentDamageSummary", [
      {
        no: 1,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "damage_records",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCitadelUserMsg_RecentDamageSummary_DamageRecord,
      },
      {
        no: 3,
        name: "start_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "end_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "total_damage",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 6,
        name: "lost_gold",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 7,
        name: "modifier_records",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary>,
  ): CCitadelUserMsg_RecentDamageSummary {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.damageRecords = [];
    message.modifierRecords = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_RecentDamageSummary,
  ): CCitadelUserMsg_RecentDamageSummary {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 player_slot */ 1:
          message.playerSlot = reader.int32();
          break;
        case /* repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records */ 2:
          message.damageRecords.push(
            CCitadelUserMsg_RecentDamageSummary_DamageRecord.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional float start_time */ 3:
          message.startTime = reader.float();
          break;
        case /* optional float end_time */ 4:
          message.endTime = reader.float();
          break;
        case /* optional int32 total_damage */ 5:
          message.totalDamage = reader.int32();
          break;
        case /* optional int32 lost_gold */ 6:
          message.lostGold = reader.int32();
          break;
        case /* repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records */ 7:
          message.modifierRecords.push(
            CCitadelUserMsg_RecentDamageSummary_ModifierRecord.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_RecentDamageSummary,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 player_slot = 1; */
    if (message.playerSlot !== undefined)
      writer.tag(1, WireType.Varint).int32(message.playerSlot);
    /* repeated CCitadelUserMsg_RecentDamageSummary.DamageRecord damage_records = 2; */
    for (let i = 0; i < message.damageRecords.length; i++)
      CCitadelUserMsg_RecentDamageSummary_DamageRecord.internalBinaryWrite(
        message.damageRecords[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float start_time = 3; */
    if (message.startTime !== undefined)
      writer.tag(3, WireType.Bit32).float(message.startTime);
    /* optional float end_time = 4; */
    if (message.endTime !== undefined)
      writer.tag(4, WireType.Bit32).float(message.endTime);
    /* optional int32 total_damage = 5; */
    if (message.totalDamage !== undefined)
      writer.tag(5, WireType.Varint).int32(message.totalDamage);
    /* optional int32 lost_gold = 6; */
    if (message.lostGold !== undefined)
      writer.tag(6, WireType.Varint).int32(message.lostGold);
    /* repeated CCitadelUserMsg_RecentDamageSummary.ModifierRecord modifier_records = 7; */
    for (let i = 0; i < message.modifierRecords.length; i++)
      CCitadelUserMsg_RecentDamageSummary_ModifierRecord.internalBinaryWrite(
        message.modifierRecords[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary
 */
export const CCitadelUserMsg_RecentDamageSummary =
  new CCitadelUserMsg_RecentDamageSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary_DamageRecord$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary_DamageRecord> {
  constructor() {
    super("CCitadelUserMsg_RecentDamageSummary.DamageRecord", [
      {
        no: 1,
        name: "damage",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "hits",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "damage_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "attacker_class",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "damage_absorbed",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: "is_killing_blow",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 9,
        name: "victim_hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary_DamageRecord>,
  ): CCitadelUserMsg_RecentDamageSummary_DamageRecord {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary_DamageRecord>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_RecentDamageSummary_DamageRecord,
  ): CCitadelUserMsg_RecentDamageSummary_DamageRecord {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 damage */ 1:
          message.damage = reader.int32();
          break;
        case /* optional int32 hits */ 2:
          message.hits = reader.int32();
          break;
        case /* optional uint32 damage_type */ 3:
          message.damageType = reader.uint32();
          break;
        case /* optional uint32 hero_id */ 4:
          message.heroId = reader.uint32();
          break;
        case /* optional uint32 ability_id */ 5:
          message.abilityId = reader.uint32();
          break;
        case /* optional uint32 attacker_class */ 6:
          message.attackerClass = reader.uint32();
          break;
        case /* optional int32 damage_absorbed */ 7:
          message.damageAbsorbed = reader.int32();
          break;
        case /* optional bool is_killing_blow */ 8:
          message.isKillingBlow = reader.bool();
          break;
        case /* optional uint32 victim_hero_id */ 9:
          message.victimHeroId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_RecentDamageSummary_DamageRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 damage = 1; */
    if (message.damage !== undefined)
      writer.tag(1, WireType.Varint).int32(message.damage);
    /* optional int32 hits = 2; */
    if (message.hits !== undefined)
      writer.tag(2, WireType.Varint).int32(message.hits);
    /* optional uint32 damage_type = 3; */
    if (message.damageType !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.damageType);
    /* optional uint32 hero_id = 4; */
    if (message.heroId !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.heroId);
    /* optional uint32 ability_id = 5; */
    if (message.abilityId !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.abilityId);
    /* optional uint32 attacker_class = 6; */
    if (message.attackerClass !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.attackerClass);
    /* optional int32 damage_absorbed = 7; */
    if (message.damageAbsorbed !== undefined)
      writer.tag(7, WireType.Varint).int32(message.damageAbsorbed);
    /* optional bool is_killing_blow = 8; */
    if (message.isKillingBlow !== undefined)
      writer.tag(8, WireType.Varint).bool(message.isKillingBlow);
    /* optional uint32 victim_hero_id = 9; */
    if (message.victimHeroId !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.victimHeroId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary.DamageRecord
 */
export const CCitadelUserMsg_RecentDamageSummary_DamageRecord =
  new CCitadelUserMsg_RecentDamageSummary_DamageRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_RecentDamageSummary_ModifierRecord$Type extends MessageType<CCitadelUserMsg_RecentDamageSummary_ModifierRecord> {
  constructor() {
    super("CCitadelUserMsg_RecentDamageSummary.ModifierRecord", [
      {
        no: 1,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "modifier_type_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "entindex_caster",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "start_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "end_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "debuff",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_RecentDamageSummary_ModifierRecord>,
  ): CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_RecentDamageSummary_ModifierRecord>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
  ): CCitadelUserMsg_RecentDamageSummary_ModifierRecord {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 ability_id */ 1:
          message.abilityId = reader.uint32();
          break;
        case /* optional uint32 modifier_type_id */ 2:
          message.modifierTypeId = reader.uint32();
          break;
        case /* optional int32 entindex_caster */ 3:
          message.entindexCaster = reader.int32();
          break;
        case /* optional float start_time */ 4:
          message.startTime = reader.float();
          break;
        case /* optional float end_time */ 5:
          message.endTime = reader.float();
          break;
        case /* optional bool debuff */ 6:
          message.debuff = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_RecentDamageSummary_ModifierRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 ability_id = 1; */
    if (message.abilityId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.abilityId);
    /* optional uint32 modifier_type_id = 2; */
    if (message.modifierTypeId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.modifierTypeId);
    /* optional int32 entindex_caster = 3; */
    if (message.entindexCaster !== undefined)
      writer.tag(3, WireType.Varint).int32(message.entindexCaster);
    /* optional float start_time = 4; */
    if (message.startTime !== undefined)
      writer.tag(4, WireType.Bit32).float(message.startTime);
    /* optional float end_time = 5; */
    if (message.endTime !== undefined)
      writer.tag(5, WireType.Bit32).float(message.endTime);
    /* optional bool debuff = 6; */
    if (message.debuff !== undefined)
      writer.tag(6, WireType.Varint).bool(message.debuff);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_RecentDamageSummary.ModifierRecord
 */
export const CCitadelUserMsg_RecentDamageSummary_ModifierRecord =
  new CCitadelUserMsg_RecentDamageSummary_ModifierRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_SpectatorTeamChanged$Type extends MessageType<CCitadelUserMsg_SpectatorTeamChanged> {
  constructor() {
    super("CCitadelUserMsg_SpectatorTeamChanged", [
      {
        no: 1,
        name: "teamnumber",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_SpectatorTeamChanged>,
  ): CCitadelUserMsg_SpectatorTeamChanged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_SpectatorTeamChanged>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_SpectatorTeamChanged,
  ): CCitadelUserMsg_SpectatorTeamChanged {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 teamnumber */ 1:
          message.teamnumber = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_SpectatorTeamChanged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 teamnumber = 1; */
    if (message.teamnumber !== undefined)
      writer.tag(1, WireType.Varint).int32(message.teamnumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_SpectatorTeamChanged
 */
export const CCitadelUserMsg_SpectatorTeamChanged =
  new CCitadelUserMsg_SpectatorTeamChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatWheel$Type extends MessageType<CCitadelUserMsg_ChatWheel> {
  constructor() {
    super("CCitadelUserMsg_ChatWheel", [
      {
        no: 1,
        name: "chat_message_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "pawn_entindex",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "hero_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "param_1",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: "lane_color",
        kind: "enum",
        opt: true,
        T: () => ["CMsgLaneColor", CMsgLaneColor],
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ChatWheel>,
  ): CCitadelUserMsg_ChatWheel {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ChatWheel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ChatWheel,
  ): CCitadelUserMsg_ChatWheel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 chat_message_id */ 1:
          message.chatMessageId = reader.uint32();
          break;
        case /* optional int32 player_slot */ 2:
          message.playerSlot = reader.int32();
          break;
        case /* optional int32 pawn_entindex */ 3:
          message.pawnEntindex = reader.int32();
          break;
        case /* optional uint32 account_id */ 4:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 hero_id */ 5:
          message.heroId = reader.uint32();
          break;
        case /* optional string param_1 */ 6:
          message.param1 = reader.string();
          break;
        case /* optional CMsgLaneColor lane_color */ 7:
          message.laneColor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ChatWheel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 chat_message_id = 1; */
    if (message.chatMessageId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.chatMessageId);
    /* optional int32 player_slot = 2; */
    if (message.playerSlot !== undefined)
      writer.tag(2, WireType.Varint).int32(message.playerSlot);
    /* optional int32 pawn_entindex = 3; */
    if (message.pawnEntindex !== undefined)
      writer.tag(3, WireType.Varint).int32(message.pawnEntindex);
    /* optional uint32 account_id = 4; */
    if (message.accountId !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.accountId);
    /* optional uint32 hero_id = 5; */
    if (message.heroId !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.heroId);
    /* optional string param_1 = 6; */
    if (message.param1 !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.param1);
    /* optional CMsgLaneColor lane_color = 7; */
    if (message.laneColor !== undefined)
      writer.tag(7, WireType.Varint).int32(message.laneColor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatWheel
 */
export const CCitadelUserMsg_ChatWheel = new CCitadelUserMsg_ChatWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatMsg$Type extends MessageType<CCitadelUserMsg_ChatMsg> {
  constructor() {
    super("CCitadelUserMsg_ChatMsg", [
      {
        no: 1,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "all_chat",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "lane_color",
        kind: "enum",
        opt: true,
        T: () => ["CMsgLaneColor", CMsgLaneColor],
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ChatMsg>,
  ): CCitadelUserMsg_ChatMsg {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ChatMsg>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ChatMsg,
  ): CCitadelUserMsg_ChatMsg {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 player_slot */ 1:
          message.playerSlot = reader.int32();
          break;
        case /* optional string text */ 2:
          message.text = reader.string();
          break;
        case /* optional bool all_chat */ 3:
          message.allChat = reader.bool();
          break;
        case /* optional CMsgLaneColor lane_color */ 4:
          message.laneColor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ChatMsg,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 player_slot = 1; */
    if (message.playerSlot !== undefined)
      writer.tag(1, WireType.Varint).int32(message.playerSlot);
    /* optional string text = 2; */
    if (message.text !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.text);
    /* optional bool all_chat = 3; */
    if (message.allChat !== undefined)
      writer.tag(3, WireType.Varint).bool(message.allChat);
    /* optional CMsgLaneColor lane_color = 4; */
    if (message.laneColor !== undefined)
      writer.tag(4, WireType.Varint).int32(message.laneColor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatMsg
 */
export const CCitadelUserMsg_ChatMsg = new CCitadelUserMsg_ChatMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory$Type extends MessageType<CCitadelUserMsg_GoldHistory> {
  constructor() {
    super("CCitadelUserMsg_GoldHistory", [
      {
        no: 1,
        name: "entindex_player",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "minute_records",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCitadelUserMsg_GoldHistory_MinuteRecord,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_GoldHistory>,
  ): CCitadelUserMsg_GoldHistory {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.minuteRecords = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_GoldHistory>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_GoldHistory,
  ): CCitadelUserMsg_GoldHistory {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_player */ 1:
          message.entindexPlayer = reader.int32();
          break;
        case /* repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records */ 2:
          message.minuteRecords.push(
            CCitadelUserMsg_GoldHistory_MinuteRecord.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_GoldHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_player = 1; */
    if (message.entindexPlayer !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexPlayer);
    /* repeated CCitadelUserMsg_GoldHistory.MinuteRecord minute_records = 2; */
    for (let i = 0; i < message.minuteRecords.length; i++)
      CCitadelUserMsg_GoldHistory_MinuteRecord.internalBinaryWrite(
        message.minuteRecords[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory
 */
export const CCitadelUserMsg_GoldHistory =
  new CCitadelUserMsg_GoldHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory_GoldRecord$Type extends MessageType<CCitadelUserMsg_GoldHistory_GoldRecord> {
  constructor() {
    super("CCitadelUserMsg_GoldHistory.GoldRecord", [
      {
        no: 1,
        name: "currency_source",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "gold",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "events",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_GoldHistory_GoldRecord>,
  ): CCitadelUserMsg_GoldHistory_GoldRecord {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_GoldHistory_GoldRecord>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_GoldHistory_GoldRecord,
  ): CCitadelUserMsg_GoldHistory_GoldRecord {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 currency_source */ 1:
          message.currencySource = reader.int32();
          break;
        case /* optional int32 gold */ 2:
          message.gold = reader.int32();
          break;
        case /* optional int32 events */ 3:
          message.events = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_GoldHistory_GoldRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 currency_source = 1; */
    if (message.currencySource !== undefined)
      writer.tag(1, WireType.Varint).int32(message.currencySource);
    /* optional int32 gold = 2; */
    if (message.gold !== undefined)
      writer.tag(2, WireType.Varint).int32(message.gold);
    /* optional int32 events = 3; */
    if (message.events !== undefined)
      writer.tag(3, WireType.Varint).int32(message.events);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory.GoldRecord
 */
export const CCitadelUserMsg_GoldHistory_GoldRecord =
  new CCitadelUserMsg_GoldHistory_GoldRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GoldHistory_MinuteRecord$Type extends MessageType<CCitadelUserMsg_GoldHistory_MinuteRecord> {
  constructor() {
    super("CCitadelUserMsg_GoldHistory.MinuteRecord", [
      {
        no: 1,
        name: "match_minute",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "gold_records",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCitadelUserMsg_GoldHistory_GoldRecord,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_GoldHistory_MinuteRecord>,
  ): CCitadelUserMsg_GoldHistory_MinuteRecord {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.goldRecords = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_GoldHistory_MinuteRecord>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_GoldHistory_MinuteRecord,
  ): CCitadelUserMsg_GoldHistory_MinuteRecord {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 match_minute */ 1:
          message.matchMinute = reader.int32();
          break;
        case /* repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records */ 2:
          message.goldRecords.push(
            CCitadelUserMsg_GoldHistory_GoldRecord.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_GoldHistory_MinuteRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 match_minute = 1; */
    if (message.matchMinute !== undefined)
      writer.tag(1, WireType.Varint).int32(message.matchMinute);
    /* repeated CCitadelUserMsg_GoldHistory.GoldRecord gold_records = 2; */
    for (let i = 0; i < message.goldRecords.length; i++)
      CCitadelUserMsg_GoldHistory_GoldRecord.internalBinaryWrite(
        message.goldRecords[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GoldHistory.MinuteRecord
 */
export const CCitadelUserMsg_GoldHistory_MinuteRecord =
  new CCitadelUserMsg_GoldHistory_MinuteRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController$Type extends MessageType<CCitadelUserMsg_CameraController> {
  constructor() {
    super("CCitadelUserMsg_CameraController", [
      {
        no: 1,
        name: "action",
        kind: "enum",
        T: () => ["CameraAction", CameraAction],
      },
      {
        no: 2,
        name: "operation",
        kind: "enum",
        opt: true,
        T: () => ["CameraOperation", CameraOperation],
      },
      {
        no: 3,
        name: "param",
        kind: "enum",
        opt: true,
        T: () => ["CameraParam", CameraParam],
      },
      {
        no: 12,
        name: "param_mode",
        kind: "enum",
        opt: true,
        T: () => ["CameraParamMode", CameraParamMode],
      },
      {
        no: 4,
        name: "delay",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 11,
        name: "relative_values",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "context_symbol_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 13,
        name: "priority",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "maintain",
        kind: "message",
        T: () => CCitadelUserMsg_CameraController_Maintain,
      },
      {
        no: 7,
        name: "approach",
        kind: "message",
        T: () => CCitadelUserMsg_CameraController_Approach,
      },
      {
        no: 8,
        name: "spring",
        kind: "message",
        T: () => CCitadelUserMsg_CameraController_Spring,
      },
      {
        no: 9,
        name: "lerp",
        kind: "message",
        T: () => CCitadelUserMsg_CameraController_Lerp,
      },
      {
        no: 10,
        name: "lag",
        kind: "message",
        T: () => CCitadelUserMsg_CameraController_Lag,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController>,
  ): CCitadelUserMsg_CameraController {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.action = 0;
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController,
  ): CCitadelUserMsg_CameraController {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CameraAction action */ 1:
          message.action = reader.int32();
          break;
        case /* optional CameraOperation operation */ 2:
          message.operation = reader.int32();
          break;
        case /* optional CameraParam param */ 3:
          message.param = reader.int32();
          break;
        case /* optional CameraParamMode param_mode */ 12:
          message.paramMode = reader.int32();
          break;
        case /* optional float delay */ 4:
          message.delay = reader.float();
          break;
        case /* optional bool relative_values */ 11:
          message.relativeValues = reader.bool();
          break;
        case /* optional uint32 context_symbol_id */ 5:
          message.contextSymbolId = reader.uint32();
          break;
        case /* optional uint32 priority */ 13:
          message.priority = reader.uint32();
          break;
        case /* optional CCitadelUserMsg_CameraController.Maintain maintain */ 6:
          message.maintain =
            CCitadelUserMsg_CameraController_Maintain.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.maintain,
            );
          break;
        case /* optional CCitadelUserMsg_CameraController.Approach approach */ 7:
          message.approach =
            CCitadelUserMsg_CameraController_Approach.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.approach,
            );
          break;
        case /* optional CCitadelUserMsg_CameraController.Spring spring */ 8:
          message.spring =
            CCitadelUserMsg_CameraController_Spring.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.spring,
            );
          break;
        case /* optional CCitadelUserMsg_CameraController.Lerp lerp */ 9:
          message.lerp =
            CCitadelUserMsg_CameraController_Lerp.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.lerp,
            );
          break;
        case /* optional CCitadelUserMsg_CameraController.Lag lag */ 10:
          message.lag = CCitadelUserMsg_CameraController_Lag.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.lag,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CameraAction action = 1; */
    if (message.action !== 0)
      writer.tag(1, WireType.Varint).int32(message.action);
    /* optional CameraOperation operation = 2; */
    if (message.operation !== undefined)
      writer.tag(2, WireType.Varint).int32(message.operation);
    /* optional CameraParam param = 3; */
    if (message.param !== undefined)
      writer.tag(3, WireType.Varint).int32(message.param);
    /* optional CameraParamMode param_mode = 12; */
    if (message.paramMode !== undefined)
      writer.tag(12, WireType.Varint).int32(message.paramMode);
    /* optional float delay = 4; */
    if (message.delay !== undefined)
      writer.tag(4, WireType.Bit32).float(message.delay);
    /* optional bool relative_values = 11; */
    if (message.relativeValues !== undefined)
      writer.tag(11, WireType.Varint).bool(message.relativeValues);
    /* optional uint32 context_symbol_id = 5; */
    if (message.contextSymbolId !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.contextSymbolId);
    /* optional uint32 priority = 13; */
    if (message.priority !== undefined)
      writer.tag(13, WireType.Varint).uint32(message.priority);
    /* optional CCitadelUserMsg_CameraController.Maintain maintain = 6; */
    if (message.maintain)
      CCitadelUserMsg_CameraController_Maintain.internalBinaryWrite(
        message.maintain,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CCitadelUserMsg_CameraController.Approach approach = 7; */
    if (message.approach)
      CCitadelUserMsg_CameraController_Approach.internalBinaryWrite(
        message.approach,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CCitadelUserMsg_CameraController.Spring spring = 8; */
    if (message.spring)
      CCitadelUserMsg_CameraController_Spring.internalBinaryWrite(
        message.spring,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CCitadelUserMsg_CameraController.Lerp lerp = 9; */
    if (message.lerp)
      CCitadelUserMsg_CameraController_Lerp.internalBinaryWrite(
        message.lerp,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CCitadelUserMsg_CameraController.Lag lag = 10; */
    if (message.lag)
      CCitadelUserMsg_CameraController_Lag.internalBinaryWrite(
        message.lag,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController
 */
export const CCitadelUserMsg_CameraController =
  new CCitadelUserMsg_CameraController$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Maintain$Type extends MessageType<CCitadelUserMsg_CameraController_Maintain> {
  constructor() {
    super("CCitadelUserMsg_CameraController.Maintain", [
      {
        no: 1,
        name: "duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      { no: 2, name: "maintain_vector", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "maintain_float",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "maintain_current",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController_Maintain>,
  ): CCitadelUserMsg_CameraController_Maintain {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController_Maintain>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController_Maintain,
  ): CCitadelUserMsg_CameraController_Maintain {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float duration */ 1:
          message.duration = reader.float();
          break;
        case /* optional CMsgVector maintain_vector */ 2:
          message.maintainVector = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.maintainVector,
          );
          break;
        case /* optional float maintain_float */ 3:
          message.maintainFloat = reader.float();
          break;
        case /* optional bool maintain_current */ 4:
          message.maintainCurrent = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController_Maintain,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float duration = 1; */
    if (message.duration !== undefined)
      writer.tag(1, WireType.Bit32).float(message.duration);
    /* optional CMsgVector maintain_vector = 2; */
    if (message.maintainVector)
      CMsgVector.internalBinaryWrite(
        message.maintainVector,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float maintain_float = 3; */
    if (message.maintainFloat !== undefined)
      writer.tag(3, WireType.Bit32).float(message.maintainFloat);
    /* optional bool maintain_current = 4; */
    if (message.maintainCurrent !== undefined)
      writer.tag(4, WireType.Varint).bool(message.maintainCurrent);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Maintain
 */
export const CCitadelUserMsg_CameraController_Maintain =
  new CCitadelUserMsg_CameraController_Maintain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Approach$Type extends MessageType<CCitadelUserMsg_CameraController_Approach> {
  constructor() {
    super("CCitadelUserMsg_CameraController.Approach", [
      {
        no: 1,
        name: "speed",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: "default_speed",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "acceleration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "min_duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "approach_float",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      { no: 6, name: "approach_vector", kind: "message", T: () => CMsgVector },
      {
        no: 7,
        name: "chase_default",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController_Approach>,
  ): CCitadelUserMsg_CameraController_Approach {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController_Approach>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController_Approach,
  ): CCitadelUserMsg_CameraController_Approach {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float speed */ 1:
          message.speed = reader.float();
          break;
        case /* optional float default_speed */ 2:
          message.defaultSpeed = reader.float();
          break;
        case /* optional float acceleration */ 3:
          message.acceleration = reader.float();
          break;
        case /* optional float min_duration */ 4:
          message.minDuration = reader.float();
          break;
        case /* optional float approach_float */ 5:
          message.approachFloat = reader.float();
          break;
        case /* optional CMsgVector approach_vector */ 6:
          message.approachVector = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.approachVector,
          );
          break;
        case /* optional bool chase_default */ 7:
          message.chaseDefault = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController_Approach,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float speed = 1; */
    if (message.speed !== undefined)
      writer.tag(1, WireType.Bit32).float(message.speed);
    /* optional float default_speed = 2; */
    if (message.defaultSpeed !== undefined)
      writer.tag(2, WireType.Bit32).float(message.defaultSpeed);
    /* optional float acceleration = 3; */
    if (message.acceleration !== undefined)
      writer.tag(3, WireType.Bit32).float(message.acceleration);
    /* optional float min_duration = 4; */
    if (message.minDuration !== undefined)
      writer.tag(4, WireType.Bit32).float(message.minDuration);
    /* optional float approach_float = 5; */
    if (message.approachFloat !== undefined)
      writer.tag(5, WireType.Bit32).float(message.approachFloat);
    /* optional CMsgVector approach_vector = 6; */
    if (message.approachVector)
      CMsgVector.internalBinaryWrite(
        message.approachVector,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional bool chase_default = 7; */
    if (message.chaseDefault !== undefined)
      writer.tag(7, WireType.Varint).bool(message.chaseDefault);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Approach
 */
export const CCitadelUserMsg_CameraController_Approach =
  new CCitadelUserMsg_CameraController_Approach$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Spring$Type extends MessageType<CCitadelUserMsg_CameraController_Spring> {
  constructor() {
    super("CCitadelUserMsg_CameraController.Spring", [
      {
        no: 1,
        name: "spring_strength",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "min_speed",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "max_duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "target_float",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      { no: 7, name: "target_vector", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController_Spring>,
  ): CCitadelUserMsg_CameraController_Spring {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController_Spring>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController_Spring,
  ): CCitadelUserMsg_CameraController_Spring {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float spring_strength */ 1:
          message.springStrength = reader.float();
          break;
        case /* optional float min_speed */ 4:
          message.minSpeed = reader.float();
          break;
        case /* optional float max_duration */ 5:
          message.maxDuration = reader.float();
          break;
        case /* optional float target_float */ 6:
          message.targetFloat = reader.float();
          break;
        case /* optional CMsgVector target_vector */ 7:
          message.targetVector = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.targetVector,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController_Spring,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float spring_strength = 1; */
    if (message.springStrength !== undefined)
      writer.tag(1, WireType.Bit32).float(message.springStrength);
    /* optional float min_speed = 4; */
    if (message.minSpeed !== undefined)
      writer.tag(4, WireType.Bit32).float(message.minSpeed);
    /* optional float max_duration = 5; */
    if (message.maxDuration !== undefined)
      writer.tag(5, WireType.Bit32).float(message.maxDuration);
    /* optional float target_float = 6; */
    if (message.targetFloat !== undefined)
      writer.tag(6, WireType.Bit32).float(message.targetFloat);
    /* optional CMsgVector target_vector = 7; */
    if (message.targetVector)
      CMsgVector.internalBinaryWrite(
        message.targetVector,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Spring
 */
export const CCitadelUserMsg_CameraController_Spring =
  new CCitadelUserMsg_CameraController_Spring$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Lerp$Type extends MessageType<CCitadelUserMsg_CameraController_Lerp> {
  constructor() {
    super("CCitadelUserMsg_CameraController.Lerp", [
      {
        no: 1,
        name: "start_float",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      { no: 2, name: "start_vector", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "end_float",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      { no: 4, name: "end_vector", kind: "message", T: () => CMsgVector },
      {
        no: 5,
        name: "bias",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "gain",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 7,
        name: "duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController_Lerp>,
  ): CCitadelUserMsg_CameraController_Lerp {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController_Lerp>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController_Lerp,
  ): CCitadelUserMsg_CameraController_Lerp {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float start_float */ 1:
          message.startFloat = reader.float();
          break;
        case /* optional CMsgVector start_vector */ 2:
          message.startVector = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startVector,
          );
          break;
        case /* optional float end_float */ 3:
          message.endFloat = reader.float();
          break;
        case /* optional CMsgVector end_vector */ 4:
          message.endVector = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.endVector,
          );
          break;
        case /* optional float bias */ 5:
          message.bias = reader.float();
          break;
        case /* optional float gain */ 6:
          message.gain = reader.float();
          break;
        case /* optional float duration */ 7:
          message.duration = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController_Lerp,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float start_float = 1; */
    if (message.startFloat !== undefined)
      writer.tag(1, WireType.Bit32).float(message.startFloat);
    /* optional CMsgVector start_vector = 2; */
    if (message.startVector)
      CMsgVector.internalBinaryWrite(
        message.startVector,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float end_float = 3; */
    if (message.endFloat !== undefined)
      writer.tag(3, WireType.Bit32).float(message.endFloat);
    /* optional CMsgVector end_vector = 4; */
    if (message.endVector)
      CMsgVector.internalBinaryWrite(
        message.endVector,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float bias = 5; */
    if (message.bias !== undefined)
      writer.tag(5, WireType.Bit32).float(message.bias);
    /* optional float gain = 6; */
    if (message.gain !== undefined)
      writer.tag(6, WireType.Bit32).float(message.gain);
    /* optional float duration = 7; */
    if (message.duration !== undefined)
      writer.tag(7, WireType.Bit32).float(message.duration);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Lerp
 */
export const CCitadelUserMsg_CameraController_Lerp =
  new CCitadelUserMsg_CameraController_Lerp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_CameraController_Lag$Type extends MessageType<CCitadelUserMsg_CameraController_Lag> {
  constructor() {
    super("CCitadelUserMsg_CameraController.Lag", [
      {
        no: 1,
        name: "min_duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: "lag_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "max_speed",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "spring_strength",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_CameraController_Lag>,
  ): CCitadelUserMsg_CameraController_Lag {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_CameraController_Lag>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_CameraController_Lag,
  ): CCitadelUserMsg_CameraController_Lag {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float min_duration */ 1:
          message.minDuration = reader.float();
          break;
        case /* optional float lag_time */ 2:
          message.lagTime = reader.float();
          break;
        case /* optional float max_speed */ 3:
          message.maxSpeed = reader.float();
          break;
        case /* optional float spring_strength */ 4:
          message.springStrength = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_CameraController_Lag,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float min_duration = 1; */
    if (message.minDuration !== undefined)
      writer.tag(1, WireType.Bit32).float(message.minDuration);
    /* optional float lag_time = 2; */
    if (message.lagTime !== undefined)
      writer.tag(2, WireType.Bit32).float(message.lagTime);
    /* optional float max_speed = 3; */
    if (message.maxSpeed !== undefined)
      writer.tag(3, WireType.Bit32).float(message.maxSpeed);
    /* optional float spring_strength = 4; */
    if (message.springStrength !== undefined)
      writer.tag(4, WireType.Bit32).float(message.springStrength);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_CameraController.Lag
 */
export const CCitadelUserMsg_CameraController_Lag =
  new CCitadelUserMsg_CameraController_Lag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PostMatchDetails$Type extends MessageType<CCitadelUserMsg_PostMatchDetails> {
  constructor() {
    super("CCitadelUserMsg_PostMatchDetails", [
      {
        no: 1,
        name: "match_details",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_PostMatchDetails>,
  ): CCitadelUserMsg_PostMatchDetails {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_PostMatchDetails>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_PostMatchDetails,
  ): CCitadelUserMsg_PostMatchDetails {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes match_details */ 1:
          message.matchDetails = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_PostMatchDetails,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bytes match_details = 1; */
    if (message.matchDetails !== undefined)
      writer.tag(1, WireType.LengthDelimited).bytes(message.matchDetails);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PostMatchDetails
 */
export const CCitadelUserMsg_PostMatchDetails =
  new CCitadelUserMsg_PostMatchDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ChatEvent$Type extends MessageType<CCitadelUserMsg_ChatEvent> {
  constructor() {
    super("CCitadelUserMsg_ChatEvent", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        opt: true,
        T: () => ["ECitadelChatMessage", ECitadelChatMessage],
      },
      {
        no: 2,
        name: "values",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ChatEvent>,
  ): CCitadelUserMsg_ChatEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.values = [];
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ChatEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ChatEvent,
  ): CCitadelUserMsg_ChatEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional ECitadelChatMessage type */ 1:
          message.type = reader.int32();
          break;
        case /* repeated uint32 values */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.values.push(reader.uint32());
          else message.values.push(reader.uint32());
          break;
        case /* repeated int32 player_slots */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ChatEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional ECitadelChatMessage type = 1; */
    if (message.type !== undefined)
      writer.tag(1, WireType.Varint).int32(message.type);
    /* repeated uint32 values = 2; */
    for (let i = 0; i < message.values.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.values[i]);
    /* repeated int32 player_slots = 3; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(3, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ChatEvent
 */
export const CCitadelUserMsg_ChatEvent = new CCitadelUserMsg_ChatEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_HeroKilled$Type extends MessageType<CCitadelUserMsg_HeroKilled> {
  constructor() {
    super("CCitadelUserMsg_HeroKilled", [
      {
        no: 1,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_inflictor",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "entindex_attacker",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "entindex_assisters",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "entindex_scorer",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 6,
        name: "respawn_reason",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_HeroKilled>,
  ): CCitadelUserMsg_HeroKilled {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.entindexAssisters = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_HeroKilled>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_HeroKilled,
  ): CCitadelUserMsg_HeroKilled {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_victim */ 1:
          message.entindexVictim = reader.int32();
          break;
        case /* optional int32 entindex_inflictor */ 2:
          message.entindexInflictor = reader.int32();
          break;
        case /* optional int32 entindex_attacker */ 3:
          message.entindexAttacker = reader.int32();
          break;
        case /* repeated int32 entindex_assisters */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.entindexAssisters.push(reader.int32());
          else message.entindexAssisters.push(reader.int32());
          break;
        case /* optional int32 entindex_scorer */ 5:
          message.entindexScorer = reader.int32();
          break;
        case /* optional int32 respawn_reason */ 6:
          message.respawnReason = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_HeroKilled,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_victim = 1; */
    if (message.entindexVictim !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexVictim);
    /* optional int32 entindex_inflictor = 2; */
    if (message.entindexInflictor !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexInflictor);
    /* optional int32 entindex_attacker = 3; */
    if (message.entindexAttacker !== undefined)
      writer.tag(3, WireType.Varint).int32(message.entindexAttacker);
    /* repeated int32 entindex_assisters = 4; */
    for (let i = 0; i < message.entindexAssisters.length; i++)
      writer.tag(4, WireType.Varint).int32(message.entindexAssisters[i]);
    /* optional int32 entindex_scorer = 5; */
    if (message.entindexScorer !== undefined)
      writer.tag(5, WireType.Varint).int32(message.entindexScorer);
    /* optional int32 respawn_reason = 6; */
    if (message.respawnReason !== undefined)
      writer.tag(6, WireType.Varint).int32(message.respawnReason);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_HeroKilled
 */
export const CCitadelUserMsg_HeroKilled = new CCitadelUserMsg_HeroKilled$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelEntityMsg_BreakablePropSpawnDebris$Type extends MessageType<CCitadelEntityMsg_BreakablePropSpawnDebris> {
  constructor() {
    super("CCitadelEntityMsg_BreakablePropSpawnDebris", [
      { no: 1, name: "entity_msg", kind: "message", T: () => CEntityMsg },
      { no: 2, name: "damage_pos", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "damage",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelEntityMsg_BreakablePropSpawnDebris>,
  ): CCitadelEntityMsg_BreakablePropSpawnDebris {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelEntityMsg_BreakablePropSpawnDebris>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelEntityMsg_BreakablePropSpawnDebris,
  ): CCitadelEntityMsg_BreakablePropSpawnDebris {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CEntityMsg entity_msg */ 1:
          message.entityMsg = CEntityMsg.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.entityMsg,
          );
          break;
        case /* optional CMsgVector damage_pos */ 2:
          message.damagePos = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.damagePos,
          );
          break;
        case /* optional float damage */ 3:
          message.damage = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelEntityMsg_BreakablePropSpawnDebris,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CEntityMsg entity_msg = 1; */
    if (message.entityMsg)
      CEntityMsg.internalBinaryWrite(
        message.entityMsg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector damage_pos = 2; */
    if (message.damagePos)
      CMsgVector.internalBinaryWrite(
        message.damagePos,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float damage = 3; */
    if (message.damage !== undefined)
      writer.tag(3, WireType.Bit32).float(message.damage);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelEntityMsg_BreakablePropSpawnDebris
 */
export const CCitadelEntityMsg_BreakablePropSpawnDebris =
  new CCitadelEntityMsg_BreakablePropSpawnDebris$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ReturnIdol$Type extends MessageType<CCitadelUserMsg_ReturnIdol> {
  constructor() {
    super("CCitadelUserMsg_ReturnIdol", [
      {
        no: 1,
        name: "location_index",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "return_location", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "location_enabled",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ReturnIdol>,
  ): CCitadelUserMsg_ReturnIdol {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ReturnIdol>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ReturnIdol,
  ): CCitadelUserMsg_ReturnIdol {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 location_index */ 1:
          message.locationIndex = reader.int32();
          break;
        case /* optional CMsgVector return_location */ 2:
          message.returnLocation = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.returnLocation,
          );
          break;
        case /* optional bool location_enabled */ 3:
          message.locationEnabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ReturnIdol,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 location_index = 1; */
    if (message.locationIndex !== undefined)
      writer.tag(1, WireType.Varint).int32(message.locationIndex);
    /* optional CMsgVector return_location = 2; */
    if (message.returnLocation)
      CMsgVector.internalBinaryWrite(
        message.returnLocation,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional bool location_enabled = 3; */
    if (message.locationEnabled !== undefined)
      writer.tag(3, WireType.Varint).bool(message.locationEnabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ReturnIdol
 */
export const CCitadelUserMsg_ReturnIdol = new CCitadelUserMsg_ReturnIdol$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_SetClientCameraAngles$Type extends MessageType<CCitadelUserMsg_SetClientCameraAngles> {
  constructor() {
    super("CCitadelUserMsg_SetClientCameraAngles", [
      {
        no: 1,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "camera_angles", kind: "message", T: () => CMsgQAngle },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_SetClientCameraAngles>,
  ): CCitadelUserMsg_SetClientCameraAngles {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_SetClientCameraAngles>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_SetClientCameraAngles,
  ): CCitadelUserMsg_SetClientCameraAngles {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 player_slot */ 1:
          message.playerSlot = reader.int32();
          break;
        case /* optional CMsgQAngle camera_angles */ 2:
          message.cameraAngles = CMsgQAngle.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cameraAngles,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_SetClientCameraAngles,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 player_slot = 1; */
    if (message.playerSlot !== undefined)
      writer.tag(1, WireType.Varint).int32(message.playerSlot);
    /* optional CMsgQAngle camera_angles = 2; */
    if (message.cameraAngles)
      CMsgQAngle.internalBinaryWrite(
        message.cameraAngles,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_SetClientCameraAngles
 */
export const CCitadelUserMsg_SetClientCameraAngles =
  new CCitadelUserMsg_SetClientCameraAngles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_BulletHit$Type extends MessageType<CCitadelUserMessage_BulletHit> {
  constructor() {
    super("CCitadelUserMessage_BulletHit", [
      {
        no: 1,
        name: "shotid",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "pellet",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "hit_entindex",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_BulletHit>,
  ): CCitadelUserMessage_BulletHit {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_BulletHit>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_BulletHit,
  ): CCitadelUserMessage_BulletHit {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 shotid */ 1:
          message.shotid = reader.int32();
          break;
        case /* optional int32 pellet */ 2:
          message.pellet = reader.int32();
          break;
        case /* optional int32 hit_entindex */ 3:
          message.hitEntindex = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_BulletHit,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 shotid = 1; */
    if (message.shotid !== undefined)
      writer.tag(1, WireType.Varint).int32(message.shotid);
    /* optional int32 pellet = 2; */
    if (message.pellet !== undefined)
      writer.tag(2, WireType.Varint).int32(message.pellet);
    /* optional int32 hit_entindex = 3; */
    if (message.hitEntindex !== undefined)
      writer.tag(3, WireType.Varint).int32(message.hitEntindex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_BulletHit
 */
export const CCitadelUserMessage_BulletHit =
  new CCitadelUserMessage_BulletHit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_ObjectiveMask$Type extends MessageType<CCitadelUserMessage_ObjectiveMask> {
  constructor() {
    super("CCitadelUserMessage_ObjectiveMask", [
      {
        no: 2,
        name: "objective_mask_team0",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "objective_mask_team1",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_ObjectiveMask>,
  ): CCitadelUserMessage_ObjectiveMask {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_ObjectiveMask>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_ObjectiveMask,
  ): CCitadelUserMessage_ObjectiveMask {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 objective_mask_team0 */ 2:
          message.objectiveMaskTeam0 = reader.uint64().toBigInt();
          break;
        case /* optional uint64 objective_mask_team1 */ 3:
          message.objectiveMaskTeam1 = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_ObjectiveMask,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 objective_mask_team0 = 2; */
    if (message.objectiveMaskTeam0 !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.objectiveMaskTeam0);
    /* optional uint64 objective_mask_team1 = 3; */
    if (message.objectiveMaskTeam1 !== undefined)
      writer.tag(3, WireType.Varint).uint64(message.objectiveMaskTeam1);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_ObjectiveMask
 */
export const CCitadelUserMessage_ObjectiveMask =
  new CCitadelUserMessage_ObjectiveMask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_ModifierApplied$Type extends MessageType<CCitadelUserMessage_ModifierApplied> {
  constructor() {
    super("CCitadelUserMessage_ModifierApplied", [
      {
        no: 1,
        name: "entindex_caster",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_parent",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "serial_number",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_ModifierApplied>,
  ): CCitadelUserMessage_ModifierApplied {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_ModifierApplied>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_ModifierApplied,
  ): CCitadelUserMessage_ModifierApplied {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_caster */ 1:
          message.entindexCaster = reader.int32();
          break;
        case /* optional int32 entindex_parent */ 2:
          message.entindexParent = reader.int32();
          break;
        case /* optional int32 serial_number */ 3:
          message.serialNumber = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_ModifierApplied,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_caster = 1; */
    if (message.entindexCaster !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexCaster);
    /* optional int32 entindex_parent = 2; */
    if (message.entindexParent !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexParent);
    /* optional int32 serial_number = 3; */
    if (message.serialNumber !== undefined)
      writer.tag(3, WireType.Varint).int32(message.serialNumber);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_ModifierApplied
 */
export const CCitadelUserMessage_ModifierApplied =
  new CCitadelUserMessage_ModifierApplied$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_AuraModifierApplied$Type extends MessageType<CCitadelUserMessage_AuraModifierApplied> {
  constructor() {
    super("CCitadelUserMessage_AuraModifierApplied", [
      {
        no: 1,
        name: "entindex_caster",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_target",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "modifier_type_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "modifier_serial_number",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "aura_start_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "aura_end_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_AuraModifierApplied>,
  ): CCitadelUserMessage_AuraModifierApplied {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_AuraModifierApplied>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_AuraModifierApplied,
  ): CCitadelUserMessage_AuraModifierApplied {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_caster */ 1:
          message.entindexCaster = reader.int32();
          break;
        case /* optional int32 entindex_target */ 2:
          message.entindexTarget = reader.int32();
          break;
        case /* optional uint32 modifier_type_id */ 3:
          message.modifierTypeId = reader.uint32();
          break;
        case /* optional int32 modifier_serial_number */ 4:
          message.modifierSerialNumber = reader.int32();
          break;
        case /* optional float aura_start_time */ 5:
          message.auraStartTime = reader.float();
          break;
        case /* optional float aura_end_time */ 6:
          message.auraEndTime = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_AuraModifierApplied,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_caster = 1; */
    if (message.entindexCaster !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexCaster);
    /* optional int32 entindex_target = 2; */
    if (message.entindexTarget !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexTarget);
    /* optional uint32 modifier_type_id = 3; */
    if (message.modifierTypeId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.modifierTypeId);
    /* optional int32 modifier_serial_number = 4; */
    if (message.modifierSerialNumber !== undefined)
      writer.tag(4, WireType.Varint).int32(message.modifierSerialNumber);
    /* optional float aura_start_time = 5; */
    if (message.auraStartTime !== undefined)
      writer.tag(5, WireType.Bit32).float(message.auraStartTime);
    /* optional float aura_end_time = 6; */
    if (message.auraEndTime !== undefined)
      writer.tag(6, WireType.Bit32).float(message.auraEndTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_AuraModifierApplied
 */
export const CCitadelUserMessage_AuraModifierApplied =
  new CCitadelUserMessage_AuraModifierApplied$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ObstructedShotFired$Type extends MessageType<CCitadelUserMsg_ObstructedShotFired> {
  constructor() {
    super("CCitadelUserMsg_ObstructedShotFired", []);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ObstructedShotFired>,
  ): CCitadelUserMsg_ObstructedShotFired {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ObstructedShotFired>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ObstructedShotFired,
  ): CCitadelUserMsg_ObstructedShotFired {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ObstructedShotFired,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ObstructedShotFired
 */
export const CCitadelUserMsg_ObstructedShotFired =
  new CCitadelUserMsg_ObstructedShotFired$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PostProcessingAnim$Type extends MessageType<CCitadelUserMsg_PostProcessingAnim> {
  constructor() {
    super("CCitadelUserMsg_PostProcessingAnim", [
      {
        no: 1,
        name: "entindex_owner",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "clear_all_states",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "state",
        kind: "enum",
        opt: true,
        T: () => ["PostProcessingGameStates", PostProcessingGameStates],
      },
      {
        no: 4,
        name: "start_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "fade_in_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "hold_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 7,
        name: "fade_out_time",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 8,
        name: "scale",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_PostProcessingAnim>,
  ): CCitadelUserMsg_PostProcessingAnim {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_PostProcessingAnim>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_PostProcessingAnim,
  ): CCitadelUserMsg_PostProcessingAnim {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_owner */ 1:
          message.entindexOwner = reader.int32();
          break;
        case /* optional bool clear_all_states */ 2:
          message.clearAllStates = reader.bool();
          break;
        case /* optional PostProcessingGameStates state */ 3:
          message.state = reader.int32();
          break;
        case /* optional float start_time */ 4:
          message.startTime = reader.float();
          break;
        case /* optional float fade_in_time */ 5:
          message.fadeInTime = reader.float();
          break;
        case /* optional float hold_time */ 6:
          message.holdTime = reader.float();
          break;
        case /* optional float fade_out_time */ 7:
          message.fadeOutTime = reader.float();
          break;
        case /* optional float scale */ 8:
          message.scale = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_PostProcessingAnim,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_owner = 1; */
    if (message.entindexOwner !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexOwner);
    /* optional bool clear_all_states = 2; */
    if (message.clearAllStates !== undefined)
      writer.tag(2, WireType.Varint).bool(message.clearAllStates);
    /* optional PostProcessingGameStates state = 3; */
    if (message.state !== undefined)
      writer.tag(3, WireType.Varint).int32(message.state);
    /* optional float start_time = 4; */
    if (message.startTime !== undefined)
      writer.tag(4, WireType.Bit32).float(message.startTime);
    /* optional float fade_in_time = 5; */
    if (message.fadeInTime !== undefined)
      writer.tag(5, WireType.Bit32).float(message.fadeInTime);
    /* optional float hold_time = 6; */
    if (message.holdTime !== undefined)
      writer.tag(6, WireType.Bit32).float(message.holdTime);
    /* optional float fade_out_time = 7; */
    if (message.fadeOutTime !== undefined)
      writer.tag(7, WireType.Bit32).float(message.fadeOutTime);
    /* optional float scale = 8; */
    if (message.scale !== undefined)
      writer.tag(8, WireType.Bit32).float(message.scale);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PostProcessingAnim
 */
export const CCitadelUserMsg_PostProcessingAnim =
  new CCitadelUserMsg_PostProcessingAnim$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_DeathReplayData$Type extends MessageType<CCitadelUserMsg_DeathReplayData> {
  constructor() {
    super("CCitadelUserMsg_DeathReplayData", [
      {
        no: 1,
        name: "killer_scorer",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "killer_inflictor",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "damage_summary",
        kind: "message",
        T: () => CCitadelUserMsg_RecentDamageSummary,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_DeathReplayData>,
  ): CCitadelUserMsg_DeathReplayData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_DeathReplayData>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_DeathReplayData,
  ): CCitadelUserMsg_DeathReplayData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 killer_scorer */ 1:
          message.killerScorer = reader.int32();
          break;
        case /* optional int32 killer_inflictor */ 2:
          message.killerInflictor = reader.int32();
          break;
        case /* optional CCitadelUserMsg_RecentDamageSummary damage_summary */ 3:
          message.damageSummary =
            CCitadelUserMsg_RecentDamageSummary.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.damageSummary,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_DeathReplayData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 killer_scorer = 1; */
    if (message.killerScorer !== undefined)
      writer.tag(1, WireType.Varint).int32(message.killerScorer);
    /* optional int32 killer_inflictor = 2; */
    if (message.killerInflictor !== undefined)
      writer.tag(2, WireType.Varint).int32(message.killerInflictor);
    /* optional CCitadelUserMsg_RecentDamageSummary damage_summary = 3; */
    if (message.damageSummary)
      CCitadelUserMsg_RecentDamageSummary.internalBinaryWrite(
        message.damageSummary,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_DeathReplayData
 */
export const CCitadelUserMsg_DeathReplayData =
  new CCitadelUserMsg_DeathReplayData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ForceShopClosed$Type extends MessageType<CCitadelUserMsg_ForceShopClosed> {
  constructor() {
    super("CCitadelUserMsg_ForceShopClosed", []);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ForceShopClosed>,
  ): CCitadelUserMsg_ForceShopClosed {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ForceShopClosed>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ForceShopClosed,
  ): CCitadelUserMsg_ForceShopClosed {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ForceShopClosed,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ForceShopClosed
 */
export const CCitadelUserMsg_ForceShopClosed =
  new CCitadelUserMsg_ForceShopClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PlayerLifetimeStatInfo$Type extends MessageType<CCitadelUserMsg_PlayerLifetimeStatInfo> {
  constructor() {
    super("CCitadelUserMsg_PlayerLifetimeStatInfo", [
      {
        no: 1,
        name: "stats",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "end_of_match",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "is_official_match",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_PlayerLifetimeStatInfo>,
  ): CCitadelUserMsg_PlayerLifetimeStatInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.stats = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_PlayerLifetimeStatInfo>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_PlayerLifetimeStatInfo,
  ): CCitadelUserMsg_PlayerLifetimeStatInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats */ 1:
          message.stats.push(
            CCitadelUserMsg_PlayerLifetimeStatInfo_Stat.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional uint64 match_id */ 2:
          message.matchId = reader.uint64().toBigInt();
          break;
        case /* optional bool end_of_match */ 3:
          message.endOfMatch = reader.bool();
          break;
        case /* optional bool is_official_match */ 4:
          message.isOfficialMatch = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_PlayerLifetimeStatInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CCitadelUserMsg_PlayerLifetimeStatInfo.Stat stats = 1; */
    for (let i = 0; i < message.stats.length; i++)
      CCitadelUserMsg_PlayerLifetimeStatInfo_Stat.internalBinaryWrite(
        message.stats[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint64 match_id = 2; */
    if (message.matchId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.matchId);
    /* optional bool end_of_match = 3; */
    if (message.endOfMatch !== undefined)
      writer.tag(3, WireType.Varint).bool(message.endOfMatch);
    /* optional bool is_official_match = 4; */
    if (message.isOfficialMatch !== undefined)
      writer.tag(4, WireType.Varint).bool(message.isOfficialMatch);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo
 */
export const CCitadelUserMsg_PlayerLifetimeStatInfo =
  new CCitadelUserMsg_PlayerLifetimeStatInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_PlayerLifetimeStatInfo_Stat$Type extends MessageType<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat> {
  constructor() {
    super("CCitadelUserMsg_PlayerLifetimeStatInfo.Stat", [
      {
        no: 1,
        name: "stat_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "match_total",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "lifetime_value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "priority",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "prev_lifetime_max",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "stat_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "stat_type_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat>,
  ): CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_PlayerLifetimeStatInfo_Stat>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
  ): CCitadelUserMsg_PlayerLifetimeStatInfo_Stat {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string stat_name */ 1:
          message.statName = reader.string();
          break;
        case /* optional uint32 match_total */ 2:
          message.matchTotal = reader.uint32();
          break;
        case /* optional uint32 lifetime_value */ 3:
          message.lifetimeValue = reader.uint32();
          break;
        case /* optional uint32 priority */ 4:
          message.priority = reader.uint32();
          break;
        case /* optional uint32 prev_lifetime_max */ 5:
          message.prevLifetimeMax = reader.uint32();
          break;
        case /* optional uint32 stat_type */ 6:
          message.statType = reader.uint32();
          break;
        case /* optional uint32 stat_type_id */ 7:
          message.statTypeId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_PlayerLifetimeStatInfo_Stat,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string stat_name = 1; */
    if (message.statName !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.statName);
    /* optional uint32 match_total = 2; */
    if (message.matchTotal !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.matchTotal);
    /* optional uint32 lifetime_value = 3; */
    if (message.lifetimeValue !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.lifetimeValue);
    /* optional uint32 priority = 4; */
    if (message.priority !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.priority);
    /* optional uint32 prev_lifetime_max = 5; */
    if (message.prevLifetimeMax !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.prevLifetimeMax);
    /* optional uint32 stat_type = 6; */
    if (message.statType !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.statType);
    /* optional uint32 stat_type_id = 7; */
    if (message.statTypeId !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.statTypeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_PlayerLifetimeStatInfo.Stat
 */
export const CCitadelUserMsg_PlayerLifetimeStatInfo_Stat =
  new CCitadelUserMsg_PlayerLifetimeStatInfo_Stat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_StaminaDrained$Type extends MessageType<CCitadelUserMsg_StaminaDrained> {
  constructor() {
    super("CCitadelUserMsg_StaminaDrained", [
      {
        no: 1,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "stamina_drained",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_StaminaDrained>,
  ): CCitadelUserMsg_StaminaDrained {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_StaminaDrained>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_StaminaDrained,
  ): CCitadelUserMsg_StaminaDrained {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_victim */ 1:
          message.entindexVictim = reader.int32();
          break;
        case /* optional int32 stamina_drained */ 2:
          message.staminaDrained = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_StaminaDrained,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_victim = 1; */
    if (message.entindexVictim !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexVictim);
    /* optional int32 stamina_drained = 2; */
    if (message.staminaDrained !== undefined)
      writer.tag(2, WireType.Varint).int32(message.staminaDrained);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_StaminaDrained
 */
export const CCitadelUserMsg_StaminaDrained =
  new CCitadelUserMsg_StaminaDrained$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_AbilityNotify$Type extends MessageType<CCitadelUserMessage_AbilityNotify> {
  constructor() {
    super("CCitadelUserMessage_AbilityNotify", [
      {
        no: 1,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entindex_attacker",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_AbilityNotify>,
  ): CCitadelUserMessage_AbilityNotify {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_AbilityNotify>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_AbilityNotify,
  ): CCitadelUserMessage_AbilityNotify {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_victim */ 1:
          message.entindexVictim = reader.int32();
          break;
        case /* optional int32 entindex_attacker */ 2:
          message.entindexAttacker = reader.int32();
          break;
        case /* optional uint32 ability_id */ 3:
          message.abilityId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_AbilityNotify,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_victim = 1; */
    if (message.entindexVictim !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexVictim);
    /* optional int32 entindex_attacker = 2; */
    if (message.entindexAttacker !== undefined)
      writer.tag(2, WireType.Varint).int32(message.entindexAttacker);
    /* optional uint32 ability_id = 3; */
    if (message.abilityId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.abilityId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_AbilityNotify
 */
export const CCitadelUserMessage_AbilityNotify =
  new CCitadelUserMessage_AbilityNotify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_CurrencyChanged$Type extends MessageType<CCitadelUserMessage_CurrencyChanged> {
  constructor() {
    super("CCitadelUserMessage_CurrencyChanged", [
      {
        no: 1,
        name: "entindex_hero_pawn",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "currency_type",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "currency_source",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "delta",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "notification",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "entindex_victim",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 7, name: "victim_pos", kind: "message", T: () => CMsgVector },
      {
        no: 8,
        name: "playsound",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "ability_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_CurrencyChanged>,
  ): CCitadelUserMessage_CurrencyChanged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_CurrencyChanged>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_CurrencyChanged,
  ): CCitadelUserMessage_CurrencyChanged {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 entindex_hero_pawn */ 1:
          message.entindexHeroPawn = reader.int32();
          break;
        case /* optional int32 currency_type */ 2:
          message.currencyType = reader.int32();
          break;
        case /* optional int32 currency_source */ 3:
          message.currencySource = reader.int32();
          break;
        case /* optional int32 delta */ 4:
          message.delta = reader.int32();
          break;
        case /* optional bool notification */ 5:
          message.notification = reader.bool();
          break;
        case /* optional int32 entindex_victim */ 6:
          message.entindexVictim = reader.int32();
          break;
        case /* optional CMsgVector victim_pos */ 7:
          message.victimPos = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.victimPos,
          );
          break;
        case /* optional int32 playsound */ 8:
          message.playsound = reader.int32();
          break;
        case /* optional uint32 ability_id */ 9:
          message.abilityId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_CurrencyChanged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 entindex_hero_pawn = 1; */
    if (message.entindexHeroPawn !== undefined)
      writer.tag(1, WireType.Varint).int32(message.entindexHeroPawn);
    /* optional int32 currency_type = 2; */
    if (message.currencyType !== undefined)
      writer.tag(2, WireType.Varint).int32(message.currencyType);
    /* optional int32 currency_source = 3; */
    if (message.currencySource !== undefined)
      writer.tag(3, WireType.Varint).int32(message.currencySource);
    /* optional int32 delta = 4; */
    if (message.delta !== undefined)
      writer.tag(4, WireType.Varint).int32(message.delta);
    /* optional bool notification = 5; */
    if (message.notification !== undefined)
      writer.tag(5, WireType.Varint).bool(message.notification);
    /* optional int32 entindex_victim = 6; */
    if (message.entindexVictim !== undefined)
      writer.tag(6, WireType.Varint).int32(message.entindexVictim);
    /* optional CMsgVector victim_pos = 7; */
    if (message.victimPos)
      CMsgVector.internalBinaryWrite(
        message.victimPos,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional int32 playsound = 8; */
    if (message.playsound !== undefined)
      writer.tag(8, WireType.Varint).int32(message.playsound);
    /* optional uint32 ability_id = 9; */
    if (message.abilityId !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.abilityId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_CurrencyChanged
 */
export const CCitadelUserMessage_CurrencyChanged =
  new CCitadelUserMessage_CurrencyChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMessage_GameOver$Type extends MessageType<CCitadelUserMessage_GameOver> {
  constructor() {
    super("CCitadelUserMessage_GameOver", [
      {
        no: 1,
        name: "winning_team",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "just_a_test",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMessage_GameOver>,
  ): CCitadelUserMessage_GameOver {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMessage_GameOver>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMessage_GameOver,
  ): CCitadelUserMessage_GameOver {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 winning_team */ 1:
          message.winningTeam = reader.int32();
          break;
        case /* optional bool just_a_test */ 2:
          message.justATest = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMessage_GameOver,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 winning_team = 1; */
    if (message.winningTeam !== undefined)
      writer.tag(1, WireType.Varint).int32(message.winningTeam);
    /* optional bool just_a_test = 2; */
    if (message.justATest !== undefined)
      writer.tag(2, WireType.Varint).bool(message.justATest);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMessage_GameOver
 */
export const CCitadelUserMessage_GameOver =
  new CCitadelUserMessage_GameOver$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GetDamageStatsResponse$Type extends MessageType<CCitadelUserMsg_GetDamageStatsResponse> {
  constructor() {
    super("CCitadelUserMsg_GetDamageStatsResponse", [
      {
        no: 1,
        name: "player_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "ability_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "damage",
        kind: "message",
        T: () => CCitadelUserMsg_GetDamageStatsResponse_StatType,
      },
      {
        no: 4,
        name: "healing",
        kind: "message",
        T: () => CCitadelUserMsg_GetDamageStatsResponse_StatType,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_GetDamageStatsResponse>,
  ): CCitadelUserMsg_GetDamageStatsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_GetDamageStatsResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_GetDamageStatsResponse,
  ): CCitadelUserMsg_GetDamageStatsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 player_slot */ 1:
          message.playerSlot = reader.uint32();
          break;
        case /* optional string ability_name */ 2:
          message.abilityName = reader.string();
          break;
        case /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage */ 3:
          message.damage =
            CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.damage,
            );
          break;
        case /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing */ 4:
          message.healing =
            CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.healing,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_GetDamageStatsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 player_slot = 1; */
    if (message.playerSlot !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.playerSlot);
    /* optional string ability_name = 2; */
    if (message.abilityName !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.abilityName);
    /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType damage = 3; */
    if (message.damage)
      CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryWrite(
        message.damage,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CCitadelUserMsg_GetDamageStatsResponse.StatType healing = 4; */
    if (message.healing)
      CCitadelUserMsg_GetDamageStatsResponse_StatType.internalBinaryWrite(
        message.healing,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GetDamageStatsResponse
 */
export const CCitadelUserMsg_GetDamageStatsResponse =
  new CCitadelUserMsg_GetDamageStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_GetDamageStatsResponse_StatType$Type extends MessageType<CCitadelUserMsg_GetDamageStatsResponse_StatType> {
  constructor() {
    super("CCitadelUserMsg_GetDamageStatsResponse.StatType", [
      {
        no: 1,
        name: "target_player_slot",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_GetDamageStatsResponse_StatType>,
  ): CCitadelUserMsg_GetDamageStatsResponse_StatType {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.targetPlayerSlot = [];
    message.value = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_GetDamageStatsResponse_StatType>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_GetDamageStatsResponse_StatType,
  ): CCitadelUserMsg_GetDamageStatsResponse_StatType {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated uint32 target_player_slot = 1 [packed = true];*/ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.targetPlayerSlot.push(reader.uint32());
          else message.targetPlayerSlot.push(reader.uint32());
          break;
        case /* repeated uint32 value = 2 [packed = true];*/ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.value.push(reader.uint32());
          else message.value.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_GetDamageStatsResponse_StatType,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated uint32 target_player_slot = 1 [packed = true]; */
    if (message.targetPlayerSlot.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.targetPlayerSlot.length; i++)
        writer.uint32(message.targetPlayerSlot[i]);
      writer.join();
    }
    /* repeated uint32 value = 2 [packed = true]; */
    if (message.value.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.value.length; i++)
        writer.uint32(message.value[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_GetDamageStatsResponse.StatType
 */
export const CCitadelUserMsg_GetDamageStatsResponse_StatType =
  new CCitadelUserMsg_GetDamageStatsResponse_StatType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStartSoundEvent$Type extends MessageType<CCitadelUserMsg_ParticipantStartSoundEvent> {
  constructor() {
    super("CCitadelUserMsg_ParticipantStartSoundEvent", [
      {
        no: 1,
        name: "event",
        kind: "message",
        T: () => CMsgSosStartSoundEvent,
      },
      {
        no: 2,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ParticipantStartSoundEvent>,
  ): CCitadelUserMsg_ParticipantStartSoundEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ParticipantStartSoundEvent>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ParticipantStartSoundEvent,
  ): CCitadelUserMsg_ParticipantStartSoundEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CMsgSosStartSoundEvent event */ 1:
          message.event = CMsgSosStartSoundEvent.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* repeated int32 player_slots */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ParticipantStartSoundEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CMsgSosStartSoundEvent event = 1; */
    if (message.event)
      CMsgSosStartSoundEvent.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 player_slots = 2; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(2, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStartSoundEvent
 */
export const CCitadelUserMsg_ParticipantStartSoundEvent =
  new CCitadelUserMsg_ParticipantStartSoundEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStopSoundEvent$Type extends MessageType<CCitadelUserMsg_ParticipantStopSoundEvent> {
  constructor() {
    super("CCitadelUserMsg_ParticipantStopSoundEvent", [
      { no: 1, name: "event", kind: "message", T: () => CMsgSosStopSoundEvent },
      {
        no: 2,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ParticipantStopSoundEvent>,
  ): CCitadelUserMsg_ParticipantStopSoundEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ParticipantStopSoundEvent>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ParticipantStopSoundEvent,
  ): CCitadelUserMsg_ParticipantStopSoundEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CMsgSosStopSoundEvent event */ 1:
          message.event = CMsgSosStopSoundEvent.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* repeated int32 player_slots */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ParticipantStopSoundEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CMsgSosStopSoundEvent event = 1; */
    if (message.event)
      CMsgSosStopSoundEvent.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 player_slots = 2; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(2, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStopSoundEvent
 */
export const CCitadelUserMsg_ParticipantStopSoundEvent =
  new CCitadelUserMsg_ParticipantStopSoundEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantStopSoundEventHash$Type extends MessageType<CCitadelUserMsg_ParticipantStopSoundEventHash> {
  constructor() {
    super("CCitadelUserMsg_ParticipantStopSoundEventHash", [
      {
        no: 1,
        name: "event",
        kind: "message",
        T: () => CMsgSosStopSoundEventHash,
      },
      {
        no: 2,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ParticipantStopSoundEventHash>,
  ): CCitadelUserMsg_ParticipantStopSoundEventHash {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ParticipantStopSoundEventHash>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ParticipantStopSoundEventHash,
  ): CCitadelUserMsg_ParticipantStopSoundEventHash {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CMsgSosStopSoundEventHash event */ 1:
          message.event = CMsgSosStopSoundEventHash.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* repeated int32 player_slots */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ParticipantStopSoundEventHash,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CMsgSosStopSoundEventHash event = 1; */
    if (message.event)
      CMsgSosStopSoundEventHash.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 player_slots = 2; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(2, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantStopSoundEventHash
 */
export const CCitadelUserMsg_ParticipantStopSoundEventHash =
  new CCitadelUserMsg_ParticipantStopSoundEventHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantSetSoundEventParams$Type extends MessageType<CCitadelUserMsg_ParticipantSetSoundEventParams> {
  constructor() {
    super("CCitadelUserMsg_ParticipantSetSoundEventParams", [
      {
        no: 1,
        name: "event",
        kind: "message",
        T: () => CMsgSosSetSoundEventParams,
      },
      {
        no: 2,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ParticipantSetSoundEventParams>,
  ): CCitadelUserMsg_ParticipantSetSoundEventParams {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ParticipantSetSoundEventParams>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ParticipantSetSoundEventParams,
  ): CCitadelUserMsg_ParticipantSetSoundEventParams {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CMsgSosSetSoundEventParams event */ 1:
          message.event = CMsgSosSetSoundEventParams.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* repeated int32 player_slots */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ParticipantSetSoundEventParams,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CMsgSosSetSoundEventParams event = 1; */
    if (message.event)
      CMsgSosSetSoundEventParams.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 player_slots = 2; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(2, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantSetSoundEventParams
 */
export const CCitadelUserMsg_ParticipantSetSoundEventParams =
  new CCitadelUserMsg_ParticipantSetSoundEventParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_ParticipantSetLibraryStackFields$Type extends MessageType<CCitadelUserMsg_ParticipantSetLibraryStackFields> {
  constructor() {
    super("CCitadelUserMsg_ParticipantSetLibraryStackFields", [
      {
        no: 1,
        name: "event",
        kind: "message",
        T: () => CMsgSosSetLibraryStackFields,
      },
      {
        no: 2,
        name: "player_slots",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_ParticipantSetLibraryStackFields>,
  ): CCitadelUserMsg_ParticipantSetLibraryStackFields {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.playerSlots = [];
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_ParticipantSetLibraryStackFields>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_ParticipantSetLibraryStackFields,
  ): CCitadelUserMsg_ParticipantSetLibraryStackFields {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* CMsgSosSetLibraryStackFields event */ 1:
          message.event = CMsgSosSetLibraryStackFields.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* repeated int32 player_slots */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.playerSlots.push(reader.int32());
          else message.playerSlots.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_ParticipantSetLibraryStackFields,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* CMsgSosSetLibraryStackFields event = 1; */
    if (message.event)
      CMsgSosSetLibraryStackFields.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 player_slots = 2; */
    for (let i = 0; i < message.playerSlots.length; i++)
      writer.tag(2, WireType.Varint).int32(message.playerSlots[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_ParticipantSetLibraryStackFields
 */
export const CCitadelUserMsg_ParticipantSetLibraryStackFields =
  new CCitadelUserMsg_ParticipantSetLibraryStackFields$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCitadelUserMsg_BossKilled$Type extends MessageType<CCitadelUserMsg_BossKilled> {
  constructor() {
    super("CCitadelUserMsg_BossKilled", [
      {
        no: 1,
        name: "objective_team",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "objective_mask_change",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "entity_killed",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "entity_killed_class",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "entity_killer",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 6, name: "gametime", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
    ]);
  }
  create(
    value?: PartialMessage<CCitadelUserMsg_BossKilled>,
  ): CCitadelUserMsg_BossKilled {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.entityKilled = 0;
    message.entityKilledClass = 0;
    message.entityKiller = 0;
    message.gametime = 0;
    if (value !== undefined)
      reflectionMergePartial<CCitadelUserMsg_BossKilled>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CCitadelUserMsg_BossKilled,
  ): CCitadelUserMsg_BossKilled {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 objective_team */ 1:
          message.objectiveTeam = reader.int32();
          break;
        case /* optional int32 objective_mask_change */ 2:
          message.objectiveMaskChange = reader.int32();
          break;
        case /* uint32 entity_killed */ 3:
          message.entityKilled = reader.uint32();
          break;
        case /* int32 entity_killed_class */ 4:
          message.entityKilledClass = reader.int32();
          break;
        case /* uint32 entity_killer */ 5:
          message.entityKiller = reader.uint32();
          break;
        case /* float gametime */ 6:
          message.gametime = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CCitadelUserMsg_BossKilled,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 objective_team = 1; */
    if (message.objectiveTeam !== undefined)
      writer.tag(1, WireType.Varint).int32(message.objectiveTeam);
    /* optional int32 objective_mask_change = 2; */
    if (message.objectiveMaskChange !== undefined)
      writer.tag(2, WireType.Varint).int32(message.objectiveMaskChange);
    /* uint32 entity_killed = 3; */
    if (message.entityKilled !== 0)
      writer.tag(3, WireType.Varint).uint32(message.entityKilled);
    /* int32 entity_killed_class = 4; */
    if (message.entityKilledClass !== 0)
      writer.tag(4, WireType.Varint).int32(message.entityKilledClass);
    /* uint32 entity_killer = 5; */
    if (message.entityKiller !== 0)
      writer.tag(5, WireType.Varint).uint32(message.entityKiller);
    /* float gametime = 6; */
    if (message.gametime !== 0)
      writer.tag(6, WireType.Bit32).float(message.gametime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CCitadelUserMsg_BossKilled
 */
export const CCitadelUserMsg_BossKilled = new CCitadelUserMsg_BossKilled$Type();

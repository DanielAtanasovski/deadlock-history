// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steamnetworkingsockets_messages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgSteamDatagramCertificateSigned } from "./steamnetworkingsockets_messages_certs";
/**
 * @generated from protobuf message CMsgSteamDatagramSessionCryptInfo
 */
export interface CMsgSteamDatagramSessionCryptInfo {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;
     */
    keyType?: CMsgSteamDatagramSessionCryptInfo_EKeyType;
    /**
     * @generated from protobuf field: optional bytes key_data = 2;
     */
    keyData?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 nonce = 3;
     */
    nonce?: bigint;
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 4;
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: repeated ESteamNetworkingSocketsCipher ciphers = 5;
     */
    ciphers: ESteamNetworkingSocketsCipher[];
}
/**
 * @generated from protobuf enum CMsgSteamDatagramSessionCryptInfo.EKeyType
 */
export enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
    /**
     * @generated from protobuf enum value: INVALID = 0;
     */
    INVALID = 0,
    /**
     * @generated from protobuf enum value: CURVE25519 = 1;
     */
    CURVE25519 = 1
}
/**
 * @generated from protobuf message CMsgSteamDatagramSessionCryptInfoSigned
 */
export interface CMsgSteamDatagramSessionCryptInfoSigned {
    /**
     * @generated from protobuf field: optional bytes info = 1;
     */
    info?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes signature = 2;
     */
    signature?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramDiagnostic
 */
export interface CMsgSteamDatagramDiagnostic {
    /**
     * @generated from protobuf field: optional uint32 severity = 1;
     */
    severity?: number;
    /**
     * @generated from protobuf field: optional string text = 2;
     */
    text?: string;
}
/**
 * @generated from protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export interface CMsgSteamDatagramLinkInstantaneousStats {
    /**
     * @generated from protobuf field: optional uint32 out_packets_per_sec_x10 = 1;
     */
    outPacketsPerSecX10?: number;
    /**
     * @generated from protobuf field: optional uint32 out_bytes_per_sec = 2;
     */
    outBytesPerSec?: number;
    /**
     * @generated from protobuf field: optional uint32 in_packets_per_sec_x10 = 3;
     */
    inPacketsPerSecX10?: number;
    /**
     * @generated from protobuf field: optional uint32 in_bytes_per_sec = 4;
     */
    inBytesPerSec?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ms = 5;
     */
    pingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 packets_dropped_pct = 6;
     */
    packetsDroppedPct?: number;
    /**
     * @generated from protobuf field: optional uint32 packets_weird_sequence_pct = 7;
     */
    packetsWeirdSequencePct?: number;
    /**
     * @generated from protobuf field: optional uint32 peak_jitter_usec = 8;
     */
    peakJitterUsec?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export interface CMsgSteamDatagramLinkLifetimeStats {
    /**
     * @generated from protobuf field: optional uint32 connected_seconds = 2;
     */
    connectedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint64 packets_sent = 3;
     */
    packetsSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 kb_sent = 4;
     */
    kbSent?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv = 5;
     */
    packetsRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 kb_recv = 6;
     */
    kbRecv?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_sequenced = 7;
     */
    packetsRecvSequenced?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_dropped = 8;
     */
    packetsRecvDropped?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_out_of_order = 9;
     */
    packetsRecvOutOfOrder?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_out_of_order_corrected = 15;
     */
    packetsRecvOutOfOrderCorrected?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_duplicate = 10;
     */
    packetsRecvDuplicate?: bigint;
    /**
     * @generated from protobuf field: optional uint64 packets_recv_lurch = 11;
     */
    packetsRecvLurch?: bigint;
    /**
     * @generated from protobuf field: repeated uint64 multipath_packets_recv_sequenced = 12;
     */
    multipathPacketsRecvSequenced: bigint[];
    /**
     * @generated from protobuf field: repeated uint64 multipath_packets_recv_later = 13;
     */
    multipathPacketsRecvLater: bigint[];
    /**
     * @generated from protobuf field: optional uint32 multipath_send_enabled = 14;
     */
    multipathSendEnabled?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_100 = 21;
     */
    qualityHistogram100?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_99 = 22;
     */
    qualityHistogram99?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_97 = 23;
     */
    qualityHistogram97?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_95 = 24;
     */
    qualityHistogram95?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_90 = 25;
     */
    qualityHistogram90?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_75 = 26;
     */
    qualityHistogram75?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_50 = 27;
     */
    qualityHistogram50?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_1 = 28;
     */
    qualityHistogram1?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_histogram_dead = 29;
     */
    qualityHistogramDead?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"];
     */
    qualityNtile2Nd?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"];
     */
    qualityNtile5Th?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"];
     */
    qualityNtile25Th?: number;
    /**
     * @generated from protobuf field: optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"];
     */
    qualityNtile50Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_25 = 41;
     */
    pingHistogram25?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_50 = 42;
     */
    pingHistogram50?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_75 = 43;
     */
    pingHistogram75?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_100 = 44;
     */
    pingHistogram100?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_125 = 45;
     */
    pingHistogram125?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_150 = 46;
     */
    pingHistogram150?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_200 = 47;
     */
    pingHistogram200?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_300 = 48;
     */
    pingHistogram300?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_histogram_max = 49;
     */
    pingHistogramMax?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"];
     */
    pingNtile5Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"];
     */
    pingNtile50Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"];
     */
    pingNtile75Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"];
     */
    pingNtile95Th?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"];
     */
    pingNtile98Th?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_negligible = 61;
     */
    jitterHistogramNegligible?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_1 = 62;
     */
    jitterHistogram1?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_2 = 63;
     */
    jitterHistogram2?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_5 = 64;
     */
    jitterHistogram5?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_10 = 65;
     */
    jitterHistogram10?: number;
    /**
     * @generated from protobuf field: optional uint32 jitter_histogram_20 = 66;
     */
    jitterHistogram20?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionQuality
 */
export interface CMsgSteamDatagramConnectionQuality {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1;
     */
    instantaneous?: CMsgSteamDatagramLinkInstantaneousStats;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2;
     */
    lifetime?: CMsgSteamDatagramLinkLifetimeStats;
}
/**
 * @generated from protobuf message CMsgICECandidate
 */
export interface CMsgICECandidate {
    /**
     * @generated from protobuf field: optional string candidate = 3;
     */
    candidate?: string;
}
/**
 * @generated from protobuf message CMsgICERendezvous
 */
export interface CMsgICERendezvous {
    /**
     * @generated from protobuf field: optional CMsgICERendezvous.Auth auth = 2;
     */
    auth?: CMsgICERendezvous_Auth;
    /**
     * @generated from protobuf field: optional CMsgICECandidate add_candidate = 1;
     */
    addCandidate?: CMsgICECandidate;
}
/**
 * @generated from protobuf message CMsgICERendezvous.Auth
 */
export interface CMsgICERendezvous_Auth {
    /**
     * @generated from protobuf field: optional string pwd_frag = 1;
     */
    pwdFrag?: string;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous
 */
export interface CMsgSteamNetworkingP2PRendezvous {
    /**
     * @generated from protobuf field: optional string from_identity = 8;
     */
    fromIdentity?: string;
    /**
     * @generated from protobuf field: optional fixed32 from_connection_id = 9;
     */
    fromConnectionId?: number;
    /**
     * @generated from protobuf field: optional string to_identity = 10;
     */
    toIdentity?: string;
    /**
     * @generated from protobuf field: optional fixed32 to_connection_id = 1;
     */
    toConnectionId?: number;
    /**
     * @generated from protobuf field: optional bytes sdr_routes = 2;
     */
    sdrRoutes?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ack_peer_routes_revision = 3;
     */
    ackPeerRoutesRevision?: number;
    /**
     * @generated from protobuf field: optional bool ice_enabled = 7;
     */
    iceEnabled?: boolean;
    /**
     * @generated from protobuf field: optional bytes hosted_server_ticket = 14;
     */
    hostedServerTicket?: Uint8Array;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request = 4;
     */
    connectRequest?: CMsgSteamNetworkingP2PRendezvous_ConnectRequest;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok = 5;
     */
    connectOk?: CMsgSteamNetworkingP2PRendezvous_ConnectOK;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed = 6;
     */
    connectionClosed?: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed;
    /**
     * @generated from protobuf field: optional uint32 ack_reliable_msg = 11;
     */
    ackReliableMsg?: number;
    /**
     * @generated from protobuf field: optional uint32 first_reliable_msg = 12;
     */
    firstReliableMsg?: number;
    /**
     * @generated from protobuf field: repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages = 13;
     */
    reliableMessages: CMsgSteamNetworkingP2PRendezvous_ReliableMessage[];
    /**
     * @generated from protobuf field: repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages = 15;
     */
    applicationMessages: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage[];
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectRequest
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
     */
    crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 7;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
    /**
     * @generated from protobuf field: optional uint32 to_virtual_port = 9;
     */
    toVirtualPort?: number;
    /**
     * @generated from protobuf field: optional uint32 from_virtual_port = 10;
     */
    fromVirtualPort?: number;
    /**
     * @generated from protobuf field: optional string from_fakeip = 11;
     */
    fromFakeip?: string;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectOK
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectOK {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
     */
    crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 6;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectionClosed
 */
export interface CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
    /**
     * @generated from protobuf field: optional string debug = 5;
     */
    debug?: string;
    /**
     * @generated from protobuf field: optional uint32 reason_code = 6;
     */
    reasonCode?: number;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ReliableMessage
 */
export interface CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
    /**
     * @generated from protobuf field: optional CMsgICERendezvous ice = 1;
     */
    ice?: CMsgICERendezvous;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PRendezvous.ApplicationMessage
 */
export interface CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 msg_num = 2;
     */
    msgNum?: bigint;
    /**
     * @generated from protobuf field: optional uint32 flags = 3;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 lane_idx = 4;
     */
    laneIdx?: number;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingICESessionSummary
 */
export interface CMsgSteamNetworkingICESessionSummary {
    /**
     * @generated from protobuf field: optional uint32 failure_reason_code = 7;
     */
    failureReasonCode?: number;
    /**
     * @generated from protobuf field: optional uint32 local_candidate_types = 1;
     */
    localCandidateTypes?: number;
    /**
     * @generated from protobuf field: optional uint32 remote_candidate_types = 2;
     */
    remoteCandidateTypes?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_route_kind = 3;
     */
    initialRouteKind?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping = 4;
     */
    initialPing?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_score = 6;
     */
    initialScore?: number;
    /**
     * @generated from protobuf field: optional uint32 negotiation_ms = 5;
     */
    negotiationMs?: number;
    /**
     * @generated from protobuf field: optional uint32 best_route_kind = 16;
     */
    bestRouteKind?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping = 17;
     */
    bestPing?: number;
    /**
     * @generated from protobuf field: optional uint32 best_score = 18;
     */
    bestScore?: number;
    /**
     * @generated from protobuf field: optional uint32 best_time = 19;
     */
    bestTime?: number;
    /**
     * @generated from protobuf field: optional uint32 selected_seconds = 12;
     */
    selectedSeconds?: number;
    /**
     * @generated from protobuf field: optional uint32 user_settings = 13;
     */
    userSettings?: number;
    /**
     * @generated from protobuf field: optional uint32 ice_enable_var = 14;
     */
    iceEnableVar?: number;
    /**
     * @generated from protobuf field: optional uint32 local_candidate_types_allowed = 15;
     */
    localCandidateTypesAllowed?: number;
}
/**
 * @generated from protobuf enum ESteamNetworkingSocketsCipher
 */
export enum ESteamNetworkingSocketsCipher {
    /**
     * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_INVALID = 0;
     */
    k_ESteamNetworkingSocketsCipher_INVALID = 0,
    /**
     * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_NULL = 1;
     */
    k_ESteamNetworkingSocketsCipher_NULL = 1,
    /**
     * @generated from protobuf enum value: k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2;
     */
    k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSessionCryptInfo$Type extends MessageType<CMsgSteamDatagramSessionCryptInfo> {
    constructor() {
        super("CMsgSteamDatagramSessionCryptInfo", [
            { no: 1, name: "key_type", kind: "enum", opt: true, T: () => ["CMsgSteamDatagramSessionCryptInfo.EKeyType", CMsgSteamDatagramSessionCryptInfo_EKeyType] },
            { no: 2, name: "key_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "nonce", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "ciphers", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["ESteamNetworkingSocketsCipher", ESteamNetworkingSocketsCipher] }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramSessionCryptInfo>): CMsgSteamDatagramSessionCryptInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ciphers = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramSessionCryptInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramSessionCryptInfo): CMsgSteamDatagramSessionCryptInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type */ 1:
                    message.keyType = reader.int32();
                    break;
                case /* optional bytes key_data */ 2:
                    message.keyData = reader.bytes();
                    break;
                case /* optional fixed64 nonce */ 3:
                    message.nonce = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 protocol_version */ 4:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* repeated ESteamNetworkingSocketsCipher ciphers */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ciphers.push(reader.int32());
                    else
                        message.ciphers.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramSessionCryptInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1; */
        if (message.keyType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.keyType);
        /* optional bytes key_data = 2; */
        if (message.keyData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.keyData);
        /* optional fixed64 nonce = 3; */
        if (message.nonce !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.nonce);
        /* optional uint32 protocol_version = 4; */
        if (message.protocolVersion !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.protocolVersion);
        /* repeated ESteamNetworkingSocketsCipher ciphers = 5; */
        for (let i = 0; i < message.ciphers.length; i++)
            writer.tag(5, WireType.Varint).int32(message.ciphers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSessionCryptInfo
 */
export const CMsgSteamDatagramSessionCryptInfo = new CMsgSteamDatagramSessionCryptInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSessionCryptInfoSigned$Type extends MessageType<CMsgSteamDatagramSessionCryptInfoSigned> {
    constructor() {
        super("CMsgSteamDatagramSessionCryptInfoSigned", [
            { no: 1, name: "info", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramSessionCryptInfoSigned>): CMsgSteamDatagramSessionCryptInfoSigned {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramSessionCryptInfoSigned>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramSessionCryptInfoSigned): CMsgSteamDatagramSessionCryptInfoSigned {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes info */ 1:
                    message.info = reader.bytes();
                    break;
                case /* optional bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramSessionCryptInfoSigned, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes info = 1; */
        if (message.info !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.info);
        /* optional bytes signature = 2; */
        if (message.signature !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSessionCryptInfoSigned
 */
export const CMsgSteamDatagramSessionCryptInfoSigned = new CMsgSteamDatagramSessionCryptInfoSigned$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramDiagnostic$Type extends MessageType<CMsgSteamDatagramDiagnostic> {
    constructor() {
        super("CMsgSteamDatagramDiagnostic", [
            { no: 1, name: "severity", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramDiagnostic>): CMsgSteamDatagramDiagnostic {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramDiagnostic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramDiagnostic): CMsgSteamDatagramDiagnostic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 severity */ 1:
                    message.severity = reader.uint32();
                    break;
                case /* optional string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramDiagnostic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 severity = 1; */
        if (message.severity !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.severity);
        /* optional string text = 2; */
        if (message.text !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramDiagnostic
 */
export const CMsgSteamDatagramDiagnostic = new CMsgSteamDatagramDiagnostic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkInstantaneousStats$Type extends MessageType<CMsgSteamDatagramLinkInstantaneousStats> {
    constructor() {
        super("CMsgSteamDatagramLinkInstantaneousStats", [
            { no: 1, name: "out_packets_per_sec_x10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "out_bytes_per_sec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "in_packets_per_sec_x10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "in_bytes_per_sec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "packets_dropped_pct", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "packets_weird_sequence_pct", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "peak_jitter_usec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramLinkInstantaneousStats>): CMsgSteamDatagramLinkInstantaneousStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramLinkInstantaneousStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramLinkInstantaneousStats): CMsgSteamDatagramLinkInstantaneousStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 out_packets_per_sec_x10 */ 1:
                    message.outPacketsPerSecX10 = reader.uint32();
                    break;
                case /* optional uint32 out_bytes_per_sec */ 2:
                    message.outBytesPerSec = reader.uint32();
                    break;
                case /* optional uint32 in_packets_per_sec_x10 */ 3:
                    message.inPacketsPerSecX10 = reader.uint32();
                    break;
                case /* optional uint32 in_bytes_per_sec */ 4:
                    message.inBytesPerSec = reader.uint32();
                    break;
                case /* optional uint32 ping_ms */ 5:
                    message.pingMs = reader.uint32();
                    break;
                case /* optional uint32 packets_dropped_pct */ 6:
                    message.packetsDroppedPct = reader.uint32();
                    break;
                case /* optional uint32 packets_weird_sequence_pct */ 7:
                    message.packetsWeirdSequencePct = reader.uint32();
                    break;
                case /* optional uint32 peak_jitter_usec */ 8:
                    message.peakJitterUsec = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramLinkInstantaneousStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 out_packets_per_sec_x10 = 1; */
        if (message.outPacketsPerSecX10 !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.outPacketsPerSecX10);
        /* optional uint32 out_bytes_per_sec = 2; */
        if (message.outBytesPerSec !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.outBytesPerSec);
        /* optional uint32 in_packets_per_sec_x10 = 3; */
        if (message.inPacketsPerSecX10 !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.inPacketsPerSecX10);
        /* optional uint32 in_bytes_per_sec = 4; */
        if (message.inBytesPerSec !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.inBytesPerSec);
        /* optional uint32 ping_ms = 5; */
        if (message.pingMs !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.pingMs);
        /* optional uint32 packets_dropped_pct = 6; */
        if (message.packetsDroppedPct !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.packetsDroppedPct);
        /* optional uint32 packets_weird_sequence_pct = 7; */
        if (message.packetsWeirdSequencePct !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.packetsWeirdSequencePct);
        /* optional uint32 peak_jitter_usec = 8; */
        if (message.peakJitterUsec !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.peakJitterUsec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkInstantaneousStats
 */
export const CMsgSteamDatagramLinkInstantaneousStats = new CMsgSteamDatagramLinkInstantaneousStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramLinkLifetimeStats$Type extends MessageType<CMsgSteamDatagramLinkLifetimeStats> {
    constructor() {
        super("CMsgSteamDatagramLinkLifetimeStats", [
            { no: 2, name: "connected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "packets_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "kb_sent", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "packets_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "kb_recv", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "packets_recv_sequenced", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "packets_recv_dropped", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "packets_recv_out_of_order", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "packets_recv_out_of_order_corrected", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "packets_recv_duplicate", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "packets_recv_lurch", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "multipath_packets_recv_sequenced", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "multipath_packets_recv_later", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "multipath_send_enabled", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "quality_histogram_100", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "quality_histogram_99", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "quality_histogram_97", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "quality_histogram_95", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "quality_histogram_90", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "quality_histogram_75", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "quality_histogram_50", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "quality_histogram_1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "quality_histogram_dead", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "quality_ntile_2nd", kind: "scalar", jsonName: "qualityNtile2nd", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "quality_ntile_5th", kind: "scalar", jsonName: "qualityNtile5th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "quality_ntile_25th", kind: "scalar", jsonName: "qualityNtile25th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "quality_ntile_50th", kind: "scalar", jsonName: "qualityNtile50th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "ping_histogram_25", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 42, name: "ping_histogram_50", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 43, name: "ping_histogram_75", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 44, name: "ping_histogram_100", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 45, name: "ping_histogram_125", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 46, name: "ping_histogram_150", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 47, name: "ping_histogram_200", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 48, name: "ping_histogram_300", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 49, name: "ping_histogram_max", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 50, name: "ping_ntile_5th", kind: "scalar", jsonName: "pingNtile5th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 51, name: "ping_ntile_50th", kind: "scalar", jsonName: "pingNtile50th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 52, name: "ping_ntile_75th", kind: "scalar", jsonName: "pingNtile75th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 53, name: "ping_ntile_95th", kind: "scalar", jsonName: "pingNtile95th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 54, name: "ping_ntile_98th", kind: "scalar", jsonName: "pingNtile98th", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 61, name: "jitter_histogram_negligible", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 62, name: "jitter_histogram_1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 63, name: "jitter_histogram_2", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 64, name: "jitter_histogram_5", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 65, name: "jitter_histogram_10", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 66, name: "jitter_histogram_20", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramLinkLifetimeStats>): CMsgSteamDatagramLinkLifetimeStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.multipathPacketsRecvSequenced = [];
        message.multipathPacketsRecvLater = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramLinkLifetimeStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramLinkLifetimeStats): CMsgSteamDatagramLinkLifetimeStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 connected_seconds */ 2:
                    message.connectedSeconds = reader.uint32();
                    break;
                case /* optional uint64 packets_sent */ 3:
                    message.packetsSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 kb_sent */ 4:
                    message.kbSent = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv */ 5:
                    message.packetsRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 kb_recv */ 6:
                    message.kbRecv = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_sequenced */ 7:
                    message.packetsRecvSequenced = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_dropped */ 8:
                    message.packetsRecvDropped = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_out_of_order */ 9:
                    message.packetsRecvOutOfOrder = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_out_of_order_corrected */ 15:
                    message.packetsRecvOutOfOrderCorrected = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_duplicate */ 10:
                    message.packetsRecvDuplicate = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 packets_recv_lurch */ 11:
                    message.packetsRecvLurch = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 multipath_packets_recv_sequenced */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.multipathPacketsRecvSequenced.push(reader.uint64().toBigInt());
                    else
                        message.multipathPacketsRecvSequenced.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 multipath_packets_recv_later */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.multipathPacketsRecvLater.push(reader.uint64().toBigInt());
                    else
                        message.multipathPacketsRecvLater.push(reader.uint64().toBigInt());
                    break;
                case /* optional uint32 multipath_send_enabled */ 14:
                    message.multipathSendEnabled = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_100 */ 21:
                    message.qualityHistogram100 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_99 */ 22:
                    message.qualityHistogram99 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_97 */ 23:
                    message.qualityHistogram97 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_95 */ 24:
                    message.qualityHistogram95 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_90 */ 25:
                    message.qualityHistogram90 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_75 */ 26:
                    message.qualityHistogram75 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_50 */ 27:
                    message.qualityHistogram50 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_1 */ 28:
                    message.qualityHistogram1 = reader.uint32();
                    break;
                case /* optional uint32 quality_histogram_dead */ 29:
                    message.qualityHistogramDead = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"];*/ 30:
                    message.qualityNtile2Nd = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"];*/ 31:
                    message.qualityNtile5Th = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"];*/ 32:
                    message.qualityNtile25Th = reader.uint32();
                    break;
                case /* optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"];*/ 33:
                    message.qualityNtile50Th = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_25 */ 41:
                    message.pingHistogram25 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_50 */ 42:
                    message.pingHistogram50 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_75 */ 43:
                    message.pingHistogram75 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_100 */ 44:
                    message.pingHistogram100 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_125 */ 45:
                    message.pingHistogram125 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_150 */ 46:
                    message.pingHistogram150 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_200 */ 47:
                    message.pingHistogram200 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_300 */ 48:
                    message.pingHistogram300 = reader.uint32();
                    break;
                case /* optional uint32 ping_histogram_max */ 49:
                    message.pingHistogramMax = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"];*/ 50:
                    message.pingNtile5Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"];*/ 51:
                    message.pingNtile50Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"];*/ 52:
                    message.pingNtile75Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"];*/ 53:
                    message.pingNtile95Th = reader.uint32();
                    break;
                case /* optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"];*/ 54:
                    message.pingNtile98Th = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_negligible */ 61:
                    message.jitterHistogramNegligible = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_1 */ 62:
                    message.jitterHistogram1 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_2 */ 63:
                    message.jitterHistogram2 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_5 */ 64:
                    message.jitterHistogram5 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_10 */ 65:
                    message.jitterHistogram10 = reader.uint32();
                    break;
                case /* optional uint32 jitter_histogram_20 */ 66:
                    message.jitterHistogram20 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramLinkLifetimeStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 connected_seconds = 2; */
        if (message.connectedSeconds !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.connectedSeconds);
        /* optional uint64 packets_sent = 3; */
        if (message.packetsSent !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.packetsSent);
        /* optional uint64 kb_sent = 4; */
        if (message.kbSent !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.kbSent);
        /* optional uint64 packets_recv = 5; */
        if (message.packetsRecv !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.packetsRecv);
        /* optional uint64 kb_recv = 6; */
        if (message.kbRecv !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.kbRecv);
        /* optional uint64 packets_recv_sequenced = 7; */
        if (message.packetsRecvSequenced !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.packetsRecvSequenced);
        /* optional uint64 packets_recv_dropped = 8; */
        if (message.packetsRecvDropped !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.packetsRecvDropped);
        /* optional uint64 packets_recv_out_of_order = 9; */
        if (message.packetsRecvOutOfOrder !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.packetsRecvOutOfOrder);
        /* optional uint64 packets_recv_out_of_order_corrected = 15; */
        if (message.packetsRecvOutOfOrderCorrected !== undefined)
            writer.tag(15, WireType.Varint).uint64(message.packetsRecvOutOfOrderCorrected);
        /* optional uint64 packets_recv_duplicate = 10; */
        if (message.packetsRecvDuplicate !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.packetsRecvDuplicate);
        /* optional uint64 packets_recv_lurch = 11; */
        if (message.packetsRecvLurch !== undefined)
            writer.tag(11, WireType.Varint).uint64(message.packetsRecvLurch);
        /* repeated uint64 multipath_packets_recv_sequenced = 12; */
        for (let i = 0; i < message.multipathPacketsRecvSequenced.length; i++)
            writer.tag(12, WireType.Varint).uint64(message.multipathPacketsRecvSequenced[i]);
        /* repeated uint64 multipath_packets_recv_later = 13; */
        for (let i = 0; i < message.multipathPacketsRecvLater.length; i++)
            writer.tag(13, WireType.Varint).uint64(message.multipathPacketsRecvLater[i]);
        /* optional uint32 multipath_send_enabled = 14; */
        if (message.multipathSendEnabled !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.multipathSendEnabled);
        /* optional uint32 quality_histogram_100 = 21; */
        if (message.qualityHistogram100 !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.qualityHistogram100);
        /* optional uint32 quality_histogram_99 = 22; */
        if (message.qualityHistogram99 !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.qualityHistogram99);
        /* optional uint32 quality_histogram_97 = 23; */
        if (message.qualityHistogram97 !== undefined)
            writer.tag(23, WireType.Varint).uint32(message.qualityHistogram97);
        /* optional uint32 quality_histogram_95 = 24; */
        if (message.qualityHistogram95 !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.qualityHistogram95);
        /* optional uint32 quality_histogram_90 = 25; */
        if (message.qualityHistogram90 !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.qualityHistogram90);
        /* optional uint32 quality_histogram_75 = 26; */
        if (message.qualityHistogram75 !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.qualityHistogram75);
        /* optional uint32 quality_histogram_50 = 27; */
        if (message.qualityHistogram50 !== undefined)
            writer.tag(27, WireType.Varint).uint32(message.qualityHistogram50);
        /* optional uint32 quality_histogram_1 = 28; */
        if (message.qualityHistogram1 !== undefined)
            writer.tag(28, WireType.Varint).uint32(message.qualityHistogram1);
        /* optional uint32 quality_histogram_dead = 29; */
        if (message.qualityHistogramDead !== undefined)
            writer.tag(29, WireType.Varint).uint32(message.qualityHistogramDead);
        /* optional uint32 quality_ntile_2nd = 30 [json_name = "qualityNtile2nd"]; */
        if (message.qualityNtile2Nd !== undefined)
            writer.tag(30, WireType.Varint).uint32(message.qualityNtile2Nd);
        /* optional uint32 quality_ntile_5th = 31 [json_name = "qualityNtile5th"]; */
        if (message.qualityNtile5Th !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.qualityNtile5Th);
        /* optional uint32 quality_ntile_25th = 32 [json_name = "qualityNtile25th"]; */
        if (message.qualityNtile25Th !== undefined)
            writer.tag(32, WireType.Varint).uint32(message.qualityNtile25Th);
        /* optional uint32 quality_ntile_50th = 33 [json_name = "qualityNtile50th"]; */
        if (message.qualityNtile50Th !== undefined)
            writer.tag(33, WireType.Varint).uint32(message.qualityNtile50Th);
        /* optional uint32 ping_histogram_25 = 41; */
        if (message.pingHistogram25 !== undefined)
            writer.tag(41, WireType.Varint).uint32(message.pingHistogram25);
        /* optional uint32 ping_histogram_50 = 42; */
        if (message.pingHistogram50 !== undefined)
            writer.tag(42, WireType.Varint).uint32(message.pingHistogram50);
        /* optional uint32 ping_histogram_75 = 43; */
        if (message.pingHistogram75 !== undefined)
            writer.tag(43, WireType.Varint).uint32(message.pingHistogram75);
        /* optional uint32 ping_histogram_100 = 44; */
        if (message.pingHistogram100 !== undefined)
            writer.tag(44, WireType.Varint).uint32(message.pingHistogram100);
        /* optional uint32 ping_histogram_125 = 45; */
        if (message.pingHistogram125 !== undefined)
            writer.tag(45, WireType.Varint).uint32(message.pingHistogram125);
        /* optional uint32 ping_histogram_150 = 46; */
        if (message.pingHistogram150 !== undefined)
            writer.tag(46, WireType.Varint).uint32(message.pingHistogram150);
        /* optional uint32 ping_histogram_200 = 47; */
        if (message.pingHistogram200 !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.pingHistogram200);
        /* optional uint32 ping_histogram_300 = 48; */
        if (message.pingHistogram300 !== undefined)
            writer.tag(48, WireType.Varint).uint32(message.pingHistogram300);
        /* optional uint32 ping_histogram_max = 49; */
        if (message.pingHistogramMax !== undefined)
            writer.tag(49, WireType.Varint).uint32(message.pingHistogramMax);
        /* optional uint32 ping_ntile_5th = 50 [json_name = "pingNtile5th"]; */
        if (message.pingNtile5Th !== undefined)
            writer.tag(50, WireType.Varint).uint32(message.pingNtile5Th);
        /* optional uint32 ping_ntile_50th = 51 [json_name = "pingNtile50th"]; */
        if (message.pingNtile50Th !== undefined)
            writer.tag(51, WireType.Varint).uint32(message.pingNtile50Th);
        /* optional uint32 ping_ntile_75th = 52 [json_name = "pingNtile75th"]; */
        if (message.pingNtile75Th !== undefined)
            writer.tag(52, WireType.Varint).uint32(message.pingNtile75Th);
        /* optional uint32 ping_ntile_95th = 53 [json_name = "pingNtile95th"]; */
        if (message.pingNtile95Th !== undefined)
            writer.tag(53, WireType.Varint).uint32(message.pingNtile95Th);
        /* optional uint32 ping_ntile_98th = 54 [json_name = "pingNtile98th"]; */
        if (message.pingNtile98Th !== undefined)
            writer.tag(54, WireType.Varint).uint32(message.pingNtile98Th);
        /* optional uint32 jitter_histogram_negligible = 61; */
        if (message.jitterHistogramNegligible !== undefined)
            writer.tag(61, WireType.Varint).uint32(message.jitterHistogramNegligible);
        /* optional uint32 jitter_histogram_1 = 62; */
        if (message.jitterHistogram1 !== undefined)
            writer.tag(62, WireType.Varint).uint32(message.jitterHistogram1);
        /* optional uint32 jitter_histogram_2 = 63; */
        if (message.jitterHistogram2 !== undefined)
            writer.tag(63, WireType.Varint).uint32(message.jitterHistogram2);
        /* optional uint32 jitter_histogram_5 = 64; */
        if (message.jitterHistogram5 !== undefined)
            writer.tag(64, WireType.Varint).uint32(message.jitterHistogram5);
        /* optional uint32 jitter_histogram_10 = 65; */
        if (message.jitterHistogram10 !== undefined)
            writer.tag(65, WireType.Varint).uint32(message.jitterHistogram10);
        /* optional uint32 jitter_histogram_20 = 66; */
        if (message.jitterHistogram20 !== undefined)
            writer.tag(66, WireType.Varint).uint32(message.jitterHistogram20);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramLinkLifetimeStats
 */
export const CMsgSteamDatagramLinkLifetimeStats = new CMsgSteamDatagramLinkLifetimeStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionQuality$Type extends MessageType<CMsgSteamDatagramConnectionQuality> {
    constructor() {
        super("CMsgSteamDatagramConnectionQuality", [
            { no: 1, name: "instantaneous", kind: "message", T: () => CMsgSteamDatagramLinkInstantaneousStats },
            { no: 2, name: "lifetime", kind: "message", T: () => CMsgSteamDatagramLinkLifetimeStats }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionQuality>): CMsgSteamDatagramConnectionQuality {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionQuality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionQuality): CMsgSteamDatagramConnectionQuality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous */ 1:
                    message.instantaneous = CMsgSteamDatagramLinkInstantaneousStats.internalBinaryRead(reader, reader.uint32(), options, message.instantaneous);
                    break;
                case /* optional CMsgSteamDatagramLinkLifetimeStats lifetime */ 2:
                    message.lifetime = CMsgSteamDatagramLinkLifetimeStats.internalBinaryRead(reader, reader.uint32(), options, message.lifetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionQuality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramLinkInstantaneousStats instantaneous = 1; */
        if (message.instantaneous)
            CMsgSteamDatagramLinkInstantaneousStats.internalBinaryWrite(message.instantaneous, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramLinkLifetimeStats lifetime = 2; */
        if (message.lifetime)
            CMsgSteamDatagramLinkLifetimeStats.internalBinaryWrite(message.lifetime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionQuality
 */
export const CMsgSteamDatagramConnectionQuality = new CMsgSteamDatagramConnectionQuality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICECandidate$Type extends MessageType<CMsgICECandidate> {
    constructor() {
        super("CMsgICECandidate", [
            { no: 3, name: "candidate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgICECandidate>): CMsgICECandidate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgICECandidate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgICECandidate): CMsgICECandidate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string candidate */ 3:
                    message.candidate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgICECandidate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string candidate = 3; */
        if (message.candidate !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.candidate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgICECandidate
 */
export const CMsgICECandidate = new CMsgICECandidate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICERendezvous$Type extends MessageType<CMsgICERendezvous> {
    constructor() {
        super("CMsgICERendezvous", [
            { no: 2, name: "auth", kind: "message", T: () => CMsgICERendezvous_Auth },
            { no: 1, name: "add_candidate", kind: "message", T: () => CMsgICECandidate }
        ]);
    }
    create(value?: PartialMessage<CMsgICERendezvous>): CMsgICERendezvous {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgICERendezvous>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgICERendezvous): CMsgICERendezvous {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgICERendezvous.Auth auth */ 2:
                    message.auth = CMsgICERendezvous_Auth.internalBinaryRead(reader, reader.uint32(), options, message.auth);
                    break;
                case /* optional CMsgICECandidate add_candidate */ 1:
                    message.addCandidate = CMsgICECandidate.internalBinaryRead(reader, reader.uint32(), options, message.addCandidate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgICERendezvous, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgICERendezvous.Auth auth = 2; */
        if (message.auth)
            CMsgICERendezvous_Auth.internalBinaryWrite(message.auth, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgICECandidate add_candidate = 1; */
        if (message.addCandidate)
            CMsgICECandidate.internalBinaryWrite(message.addCandidate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgICERendezvous
 */
export const CMsgICERendezvous = new CMsgICERendezvous$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgICERendezvous_Auth$Type extends MessageType<CMsgICERendezvous_Auth> {
    constructor() {
        super("CMsgICERendezvous.Auth", [
            { no: 1, name: "pwd_frag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgICERendezvous_Auth>): CMsgICERendezvous_Auth {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgICERendezvous_Auth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgICERendezvous_Auth): CMsgICERendezvous_Auth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string pwd_frag */ 1:
                    message.pwdFrag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgICERendezvous_Auth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string pwd_frag = 1; */
        if (message.pwdFrag !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.pwdFrag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgICERendezvous.Auth
 */
export const CMsgICERendezvous_Auth = new CMsgICERendezvous_Auth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous", [
            { no: 8, name: "from_identity", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "from_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "to_identity", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "to_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "sdr_routes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "ack_peer_routes_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ice_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "hosted_server_ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "connect_request", kind: "message", T: () => CMsgSteamNetworkingP2PRendezvous_ConnectRequest },
            { no: 5, name: "connect_ok", kind: "message", T: () => CMsgSteamNetworkingP2PRendezvous_ConnectOK },
            { no: 6, name: "connection_closed", kind: "message", T: () => CMsgSteamNetworkingP2PRendezvous_ConnectionClosed },
            { no: 11, name: "ack_reliable_msg", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "first_reliable_msg", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "reliable_messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamNetworkingP2PRendezvous_ReliableMessage },
            { no: 15, name: "application_messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamNetworkingP2PRendezvous_ApplicationMessage }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous>): CMsgSteamNetworkingP2PRendezvous {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reliableMessages = [];
        message.applicationMessages = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous): CMsgSteamNetworkingP2PRendezvous {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string from_identity */ 8:
                    message.fromIdentity = reader.string();
                    break;
                case /* optional fixed32 from_connection_id */ 9:
                    message.fromConnectionId = reader.fixed32();
                    break;
                case /* optional string to_identity */ 10:
                    message.toIdentity = reader.string();
                    break;
                case /* optional fixed32 to_connection_id */ 1:
                    message.toConnectionId = reader.fixed32();
                    break;
                case /* optional bytes sdr_routes */ 2:
                    message.sdrRoutes = reader.bytes();
                    break;
                case /* optional uint32 ack_peer_routes_revision */ 3:
                    message.ackPeerRoutesRevision = reader.uint32();
                    break;
                case /* optional bool ice_enabled */ 7:
                    message.iceEnabled = reader.bool();
                    break;
                case /* optional bytes hosted_server_ticket */ 14:
                    message.hostedServerTicket = reader.bytes();
                    break;
                case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request */ 4:
                    message.connectRequest = CMsgSteamNetworkingP2PRendezvous_ConnectRequest.internalBinaryRead(reader, reader.uint32(), options, message.connectRequest);
                    break;
                case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok */ 5:
                    message.connectOk = CMsgSteamNetworkingP2PRendezvous_ConnectOK.internalBinaryRead(reader, reader.uint32(), options, message.connectOk);
                    break;
                case /* optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed */ 6:
                    message.connectionClosed = CMsgSteamNetworkingP2PRendezvous_ConnectionClosed.internalBinaryRead(reader, reader.uint32(), options, message.connectionClosed);
                    break;
                case /* optional uint32 ack_reliable_msg */ 11:
                    message.ackReliableMsg = reader.uint32();
                    break;
                case /* optional uint32 first_reliable_msg */ 12:
                    message.firstReliableMsg = reader.uint32();
                    break;
                case /* repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages */ 13:
                    message.reliableMessages.push(CMsgSteamNetworkingP2PRendezvous_ReliableMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages */ 15:
                    message.applicationMessages.push(CMsgSteamNetworkingP2PRendezvous_ApplicationMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string from_identity = 8; */
        if (message.fromIdentity !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.fromIdentity);
        /* optional fixed32 from_connection_id = 9; */
        if (message.fromConnectionId !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.fromConnectionId);
        /* optional string to_identity = 10; */
        if (message.toIdentity !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.toIdentity);
        /* optional fixed32 to_connection_id = 1; */
        if (message.toConnectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.toConnectionId);
        /* optional bytes sdr_routes = 2; */
        if (message.sdrRoutes !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sdrRoutes);
        /* optional uint32 ack_peer_routes_revision = 3; */
        if (message.ackPeerRoutesRevision !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.ackPeerRoutesRevision);
        /* optional bool ice_enabled = 7; */
        if (message.iceEnabled !== undefined)
            writer.tag(7, WireType.Varint).bool(message.iceEnabled);
        /* optional bytes hosted_server_ticket = 14; */
        if (message.hostedServerTicket !== undefined)
            writer.tag(14, WireType.LengthDelimited).bytes(message.hostedServerTicket);
        /* optional CMsgSteamNetworkingP2PRendezvous.ConnectRequest connect_request = 4; */
        if (message.connectRequest)
            CMsgSteamNetworkingP2PRendezvous_ConnectRequest.internalBinaryWrite(message.connectRequest, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamNetworkingP2PRendezvous.ConnectOK connect_ok = 5; */
        if (message.connectOk)
            CMsgSteamNetworkingP2PRendezvous_ConnectOK.internalBinaryWrite(message.connectOk, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamNetworkingP2PRendezvous.ConnectionClosed connection_closed = 6; */
        if (message.connectionClosed)
            CMsgSteamNetworkingP2PRendezvous_ConnectionClosed.internalBinaryWrite(message.connectionClosed, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 ack_reliable_msg = 11; */
        if (message.ackReliableMsg !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.ackReliableMsg);
        /* optional uint32 first_reliable_msg = 12; */
        if (message.firstReliableMsg !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.firstReliableMsg);
        /* repeated CMsgSteamNetworkingP2PRendezvous.ReliableMessage reliable_messages = 13; */
        for (let i = 0; i < message.reliableMessages.length; i++)
            CMsgSteamNetworkingP2PRendezvous_ReliableMessage.internalBinaryWrite(message.reliableMessages[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamNetworkingP2PRendezvous.ApplicationMessage application_messages = 15; */
        for (let i = 0; i < message.applicationMessages.length; i++)
            CMsgSteamNetworkingP2PRendezvous_ApplicationMessage.internalBinaryWrite(message.applicationMessages[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous
 */
export const CMsgSteamNetworkingP2PRendezvous = new CMsgSteamNetworkingP2PRendezvous$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectRequest$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectRequest> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous.ConnectRequest", [
            { no: 6, name: "crypt", kind: "message", T: () => CMsgSteamDatagramSessionCryptInfoSigned },
            { no: 7, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned },
            { no: 9, name: "to_virtual_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "from_virtual_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "from_fakeip", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>): CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous_ConnectRequest): CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 6:
                    message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(reader, reader.uint32(), options, message.crypt);
                    break;
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 7:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                case /* optional uint32 to_virtual_port */ 9:
                    message.toVirtualPort = reader.uint32();
                    break;
                case /* optional uint32 from_virtual_port */ 10:
                    message.fromVirtualPort = reader.uint32();
                    break;
                case /* optional string from_fakeip */ 11:
                    message.fromFakeip = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous_ConnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6; */
        if (message.crypt)
            CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(message.crypt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramCertificateSigned cert = 7; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 to_virtual_port = 9; */
        if (message.toVirtualPort !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.toVirtualPort);
        /* optional uint32 from_virtual_port = 10; */
        if (message.fromVirtualPort !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.fromVirtualPort);
        /* optional string from_fakeip = 11; */
        if (message.fromFakeip !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.fromFakeip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectRequest
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectRequest = new CMsgSteamNetworkingP2PRendezvous_ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectOK$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectOK> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous.ConnectOK", [
            { no: 5, name: "crypt", kind: "message", T: () => CMsgSteamDatagramSessionCryptInfoSigned },
            { no: 6, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectOK>): CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectOK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous_ConnectOK): CMsgSteamNetworkingP2PRendezvous_ConnectOK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 5:
                    message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(reader, reader.uint32(), options, message.crypt);
                    break;
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 6:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous_ConnectOK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5; */
        if (message.crypt)
            CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(message.crypt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramCertificateSigned cert = 6; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectOK
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectOK = new CMsgSteamNetworkingP2PRendezvous_ConnectOK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ConnectionClosed$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous.ConnectionClosed", [
            { no: 5, name: "debug", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "reason_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>): CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ConnectionClosed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed): CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string debug */ 5:
                    message.debug = reader.string();
                    break;
                case /* optional uint32 reason_code */ 6:
                    message.reasonCode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous_ConnectionClosed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string debug = 5; */
        if (message.debug !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.debug);
        /* optional uint32 reason_code = 6; */
        if (message.reasonCode !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.reasonCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ConnectionClosed
 */
export const CMsgSteamNetworkingP2PRendezvous_ConnectionClosed = new CMsgSteamNetworkingP2PRendezvous_ConnectionClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ReliableMessage$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ReliableMessage> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous.ReliableMessage", [
            { no: 1, name: "ice", kind: "message", T: () => CMsgICERendezvous }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>): CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ReliableMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous_ReliableMessage): CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgICERendezvous ice */ 1:
                    message.ice = CMsgICERendezvous.internalBinaryRead(reader, reader.uint32(), options, message.ice);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous_ReliableMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgICERendezvous ice = 1; */
        if (message.ice)
            CMsgICERendezvous.internalBinaryWrite(message.ice, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ReliableMessage
 */
export const CMsgSteamNetworkingP2PRendezvous_ReliableMessage = new CMsgSteamNetworkingP2PRendezvous_ReliableMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PRendezvous_ApplicationMessage$Type extends MessageType<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage> {
    constructor() {
        super("CMsgSteamNetworkingP2PRendezvous.ApplicationMessage", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "msg_num", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "lane_idx", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage>): CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PRendezvous_ApplicationMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage): CMsgSteamNetworkingP2PRendezvous_ApplicationMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* optional uint64 msg_num */ 2:
                    message.msgNum = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 flags */ 3:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 lane_idx */ 4:
                    message.laneIdx = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PRendezvous_ApplicationMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* optional uint64 msg_num = 2; */
        if (message.msgNum !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.msgNum);
        /* optional uint32 flags = 3; */
        if (message.flags !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.flags);
        /* optional uint32 lane_idx = 4; */
        if (message.laneIdx !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.laneIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PRendezvous.ApplicationMessage
 */
export const CMsgSteamNetworkingP2PRendezvous_ApplicationMessage = new CMsgSteamNetworkingP2PRendezvous_ApplicationMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingICESessionSummary$Type extends MessageType<CMsgSteamNetworkingICESessionSummary> {
    constructor() {
        super("CMsgSteamNetworkingICESessionSummary", [
            { no: 7, name: "failure_reason_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 1, name: "local_candidate_types", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "remote_candidate_types", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "initial_route_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "initial_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "initial_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "negotiation_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "best_route_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "best_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "best_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "best_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "selected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "user_settings", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "ice_enable_var", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "local_candidate_types_allowed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingICESessionSummary>): CMsgSteamNetworkingICESessionSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingICESessionSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingICESessionSummary): CMsgSteamNetworkingICESessionSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 failure_reason_code */ 7:
                    message.failureReasonCode = reader.uint32();
                    break;
                case /* optional uint32 local_candidate_types */ 1:
                    message.localCandidateTypes = reader.uint32();
                    break;
                case /* optional uint32 remote_candidate_types */ 2:
                    message.remoteCandidateTypes = reader.uint32();
                    break;
                case /* optional uint32 initial_route_kind */ 3:
                    message.initialRouteKind = reader.uint32();
                    break;
                case /* optional uint32 initial_ping */ 4:
                    message.initialPing = reader.uint32();
                    break;
                case /* optional uint32 initial_score */ 6:
                    message.initialScore = reader.uint32();
                    break;
                case /* optional uint32 negotiation_ms */ 5:
                    message.negotiationMs = reader.uint32();
                    break;
                case /* optional uint32 best_route_kind */ 16:
                    message.bestRouteKind = reader.uint32();
                    break;
                case /* optional uint32 best_ping */ 17:
                    message.bestPing = reader.uint32();
                    break;
                case /* optional uint32 best_score */ 18:
                    message.bestScore = reader.uint32();
                    break;
                case /* optional uint32 best_time */ 19:
                    message.bestTime = reader.uint32();
                    break;
                case /* optional uint32 selected_seconds */ 12:
                    message.selectedSeconds = reader.uint32();
                    break;
                case /* optional uint32 user_settings */ 13:
                    message.userSettings = reader.uint32();
                    break;
                case /* optional uint32 ice_enable_var */ 14:
                    message.iceEnableVar = reader.uint32();
                    break;
                case /* optional uint32 local_candidate_types_allowed */ 15:
                    message.localCandidateTypesAllowed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingICESessionSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 failure_reason_code = 7; */
        if (message.failureReasonCode !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.failureReasonCode);
        /* optional uint32 local_candidate_types = 1; */
        if (message.localCandidateTypes !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.localCandidateTypes);
        /* optional uint32 remote_candidate_types = 2; */
        if (message.remoteCandidateTypes !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.remoteCandidateTypes);
        /* optional uint32 initial_route_kind = 3; */
        if (message.initialRouteKind !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.initialRouteKind);
        /* optional uint32 initial_ping = 4; */
        if (message.initialPing !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.initialPing);
        /* optional uint32 initial_score = 6; */
        if (message.initialScore !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.initialScore);
        /* optional uint32 negotiation_ms = 5; */
        if (message.negotiationMs !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.negotiationMs);
        /* optional uint32 best_route_kind = 16; */
        if (message.bestRouteKind !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.bestRouteKind);
        /* optional uint32 best_ping = 17; */
        if (message.bestPing !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.bestPing);
        /* optional uint32 best_score = 18; */
        if (message.bestScore !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.bestScore);
        /* optional uint32 best_time = 19; */
        if (message.bestTime !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.bestTime);
        /* optional uint32 selected_seconds = 12; */
        if (message.selectedSeconds !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.selectedSeconds);
        /* optional uint32 user_settings = 13; */
        if (message.userSettings !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.userSettings);
        /* optional uint32 ice_enable_var = 14; */
        if (message.iceEnableVar !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.iceEnableVar);
        /* optional uint32 local_candidate_types_allowed = 15; */
        if (message.localCandidateTypesAllowed !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.localCandidateTypesAllowed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingICESessionSummary
 */
export const CMsgSteamNetworkingICESessionSummary = new CMsgSteamNetworkingICESessionSummary$Type();

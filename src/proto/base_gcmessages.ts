// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "base_gcmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EGCPlatform } from "./steammessages";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";
/**
 * @generated from protobuf message CGCStorePurchaseInit_LineItem
 */
export interface CGCStorePurchaseInit_LineItem {
  /**
   * @generated from protobuf field: optional uint32 item_def_id = 1;
   */
  itemDefId?: number;
  /**
   * @generated from protobuf field: optional uint32 quantity = 2;
   */
  quantity?: number;
  /**
   * @generated from protobuf field: optional uint32 cost_in_local_currency = 3;
   */
  costInLocalCurrency?: number;
  /**
   * @generated from protobuf field: optional uint32 purchase_type = 4;
   */
  purchaseType?: number;
  /**
   * @generated from protobuf field: optional uint64 source_reference_id = 5;
   */
  sourceReferenceId?: bigint;
  /**
   * @generated from protobuf field: optional int32 price_index = 6;
   */
  priceIndex?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseInit
 */
export interface CMsgGCStorePurchaseInit {
  /**
   * @generated from protobuf field: optional string country = 1;
   */
  country?: string;
  /**
   * @generated from protobuf field: optional int32 language = 2;
   */
  language?: number;
  /**
   * @generated from protobuf field: optional int32 currency = 3;
   */
  currency?: number;
  /**
   * @generated from protobuf field: repeated CGCStorePurchaseInit_LineItem line_items = 4;
   */
  lineItems: CGCStorePurchaseInit_LineItem[];
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseInitResponse
 */
export interface CMsgGCStorePurchaseInitResponse {
  /**
   * @generated from protobuf field: optional int32 result = 1;
   */
  result?: number;
  /**
   * @generated from protobuf field: optional uint64 txn_id = 2;
   */
  txnId?: bigint;
}
/**
 * @generated from protobuf message CMsgClientPingData
 */
export interface CMsgClientPingData {
  /**
   * @generated from protobuf field: repeated fixed32 relay_codes = 4 [packed = true];
   */
  relayCodes: number[];
  /**
   * @generated from protobuf field: repeated uint32 relay_pings = 5 [packed = true];
   */
  relayPings: number[];
  /**
   * @generated from protobuf field: repeated uint32 region_codes = 8 [packed = true];
   */
  regionCodes: number[];
  /**
   * @generated from protobuf field: repeated uint32 region_pings = 9 [packed = true];
   */
  regionPings: number[];
  /**
   * @generated from protobuf field: optional uint32 region_ping_failed_bitmask = 10;
   */
  regionPingFailedBitmask?: number;
}
/**
 * @generated from protobuf message CMsgInviteToParty
 */
export interface CMsgInviteToParty {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steamId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  clientVersion?: number;
  /**
   * @generated from protobuf field: optional uint32 team_id = 3;
   */
  teamId?: number;
  /**
   * @generated from protobuf field: optional bool as_coach = 4;
   */
  asCoach?: boolean;
  /**
   * @generated from protobuf field: optional CMsgClientPingData ping_data = 5;
   */
  pingData?: CMsgClientPingData;
}
/**
 * @generated from protobuf message CMsgInviteToLobby
 */
export interface CMsgInviteToLobby {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steamId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  clientVersion?: number;
}
/**
 * @generated from protobuf message CMsgInvitationCreated
 */
export interface CMsgInvitationCreated {
  /**
   * @generated from protobuf field: optional uint64 group_id = 1;
   */
  groupId?: bigint;
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 2;
   */
  steamId?: bigint;
  /**
   * @generated from protobuf field: optional bool user_offline = 3;
   */
  userOffline?: boolean;
}
/**
 * @generated from protobuf message CMsgPartyInviteResponse
 */
export interface CMsgPartyInviteResponse {
  /**
   * @generated from protobuf field: optional uint64 party_id = 1;
   */
  partyId?: bigint;
  /**
   * @generated from protobuf field: optional bool accept = 2;
   */
  accept?: boolean;
  /**
   * @generated from protobuf field: optional uint32 client_version = 3;
   */
  clientVersion?: number;
  /**
   * @generated from protobuf field: optional CMsgClientPingData ping_data = 8;
   */
  pingData?: CMsgClientPingData;
}
/**
 * @generated from protobuf message CMsgLobbyInviteResponse
 */
export interface CMsgLobbyInviteResponse {
  /**
   * @generated from protobuf field: optional fixed64 lobby_id = 1;
   */
  lobbyId?: bigint;
  /**
   * @generated from protobuf field: optional bool accept = 2;
   */
  accept?: boolean;
  /**
   * @generated from protobuf field: optional uint32 client_version = 3;
   */
  clientVersion?: number;
  /**
   * @generated from protobuf field: optional fixed64 custom_game_crc = 6;
   */
  customGameCrc?: bigint;
  /**
   * @generated from protobuf field: optional fixed32 custom_game_timestamp = 7;
   */
  customGameTimestamp?: number;
}
/**
 * @generated from protobuf message CMsgKickFromParty
 */
export interface CMsgKickFromParty {
  /**
   * @generated from protobuf field: optional fixed64 steam_id = 1;
   */
  steamId?: bigint;
}
/**
 * @generated from protobuf message CMsgLeaveParty
 */
export interface CMsgLeaveParty {}
/**
 * @generated from protobuf message CMsgCustomGameInstallStatus
 */
export interface CMsgCustomGameInstallStatus {
  /**
   * @generated from protobuf field: optional ECustomGameInstallStatus status = 1;
   */
  status?: ECustomGameInstallStatus;
  /**
   * @generated from protobuf field: optional string message = 2;
   */
  message?: string;
  /**
   * @generated from protobuf field: optional fixed32 latest_timestamp_from_steam = 3;
   */
  latestTimestampFromSteam?: number;
}
/**
 * @generated from protobuf message CMsgServerAvailable
 */
export interface CMsgServerAvailable {
  /**
   * @generated from protobuf field: optional CMsgCustomGameInstallStatus custom_game_install_status = 1;
   */
  customGameInstallStatus?: CMsgCustomGameInstallStatus;
}
/**
 * @generated from protobuf message CMsgLANServerAvailable
 */
export interface CMsgLANServerAvailable {
  /**
   * @generated from protobuf field: optional fixed64 lobby_id = 1;
   */
  lobbyId?: bigint;
}
/**
 * @generated from protobuf message CSOEconGameAccountClient
 */
export interface CSOEconGameAccountClient {
  /**
   * @generated from protobuf field: optional uint32 additional_backpack_slots = 1;
   */
  additionalBackpackSlots?: number;
  /**
   * @generated from protobuf field: optional bool trial_account = 2;
   */
  trialAccount?: boolean;
  /**
   * @generated from protobuf field: optional bool eligible_for_online_play = 3;
   */
  eligibleForOnlinePlay?: boolean;
  /**
   * @generated from protobuf field: optional bool need_to_choose_most_helpful_friend = 4;
   */
  needToChooseMostHelpfulFriend?: boolean;
  /**
   * @generated from protobuf field: optional bool in_coaches_list = 5;
   */
  inCoachesList?: boolean;
  /**
   * @generated from protobuf field: optional fixed32 trade_ban_expiration = 6;
   */
  tradeBanExpiration?: number;
  /**
   * @generated from protobuf field: optional fixed32 duel_ban_expiration = 7;
   */
  duelBanExpiration?: number;
  /**
   * @generated from protobuf field: optional bool made_first_purchase = 9;
   */
  madeFirstPurchase?: boolean;
}
/**
 * @generated from protobuf message CMsgApplyStrangePart
 */
export interface CMsgApplyStrangePart {
  /**
   * @generated from protobuf field: optional uint64 strange_part_item_id = 1;
   */
  strangePartItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  itemItemId?: bigint;
}
/**
 * @generated from protobuf message CMsgApplyPennantUpgrade
 */
export interface CMsgApplyPennantUpgrade {
  /**
   * @generated from protobuf field: optional uint64 upgrade_item_id = 1;
   */
  upgradeItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 pennant_item_id = 2;
   */
  pennantItemId?: bigint;
}
/**
 * @generated from protobuf message CMsgApplyEggEssence
 */
export interface CMsgApplyEggEssence {
  /**
   * @generated from protobuf field: optional uint64 essence_item_id = 1;
   */
  essenceItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 egg_item_id = 2;
   */
  eggItemId?: bigint;
}
/**
 * @generated from protobuf message CSOEconItemAttribute
 */
export interface CSOEconItemAttribute {
  /**
   * @generated from protobuf field: optional uint32 def_index = 1;
   */
  defIndex?: number;
  /**
   * @generated from protobuf field: optional uint32 value = 2;
   */
  value?: number;
  /**
   * @generated from protobuf field: optional bytes value_bytes = 3;
   */
  valueBytes?: Uint8Array;
}
/**
 * @generated from protobuf message CSOEconItemEquipped
 */
export interface CSOEconItemEquipped {
  /**
   * @generated from protobuf field: optional uint32 new_class = 1;
   */
  newClass?: number;
  /**
   * @generated from protobuf field: optional uint32 new_slot = 2;
   */
  newSlot?: number;
}
/**
 * @generated from protobuf message CSOEconItem
 */
export interface CSOEconItem {
  /**
   * @generated from protobuf field: optional uint64 id = 1;
   */
  id?: bigint;
  /**
   * @generated from protobuf field: optional uint32 account_id = 2;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 inventory = 3;
   */
  inventory?: number;
  /**
   * @generated from protobuf field: optional uint32 def_index = 4;
   */
  defIndex?: number;
  /**
   * @generated from protobuf field: optional uint32 quantity = 5;
   */
  quantity?: number;
  /**
   * @generated from protobuf field: optional uint32 level = 6;
   */
  level?: number;
  /**
   * @generated from protobuf field: optional uint32 quality = 7;
   */
  quality?: number;
  /**
   * @generated from protobuf field: optional uint32 flags = 8;
   */
  flags?: number;
  /**
   * @generated from protobuf field: optional uint32 origin = 9;
   */
  origin?: number;
  /**
   * @generated from protobuf field: repeated CSOEconItemAttribute attribute = 12;
   */
  attribute: CSOEconItemAttribute[];
  /**
   * @generated from protobuf field: optional CSOEconItem interior_item = 13;
   */
  interiorItem?: CSOEconItem;
  /**
   * @generated from protobuf field: optional uint32 style = 15;
   */
  style?: number;
  /**
   * @generated from protobuf field: optional uint64 original_id = 16;
   */
  originalId?: bigint;
  /**
   * @generated from protobuf field: repeated CSOEconItemEquipped equipped_state = 18;
   */
  equippedState: CSOEconItemEquipped[];
}
/**
 * @generated from protobuf message CMsgSortItems
 */
export interface CMsgSortItems {
  /**
   * @generated from protobuf field: optional uint32 sort_type = 1;
   */
  sortType?: number;
}
/**
 * @generated from protobuf message CMsgItemAcknowledged
 */
export interface CMsgItemAcknowledged {
  /**
   * @generated from protobuf field: optional uint32 account_id = 1;
   */
  accountId?: number;
  /**
   * @generated from protobuf field: optional uint32 inventory = 2;
   */
  inventory?: number;
  /**
   * @generated from protobuf field: optional uint32 def_index = 3;
   */
  defIndex?: number;
  /**
   * @generated from protobuf field: optional uint32 quality = 4;
   */
  quality?: number;
  /**
   * @generated from protobuf field: optional uint32 rarity = 5;
   */
  rarity?: number;
  /**
   * @generated from protobuf field: optional uint32 origin = 6;
   */
  origin?: number;
}
/**
 * @generated from protobuf message CMsgSetItemPositions
 */
export interface CMsgSetItemPositions {
  /**
   * @generated from protobuf field: repeated CMsgSetItemPositions.ItemPosition item_positions = 1;
   */
  itemPositions: CMsgSetItemPositions_ItemPosition[];
}
/**
 * @generated from protobuf message CMsgSetItemPositions.ItemPosition
 */
export interface CMsgSetItemPositions_ItemPosition {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  itemId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 position = 2;
   */
  position?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseCancel
 */
export interface CMsgGCStorePurchaseCancel {
  /**
   * @generated from protobuf field: optional uint64 txn_id = 1;
   */
  txnId?: bigint;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseCancelResponse
 */
export interface CMsgGCStorePurchaseCancelResponse {
  /**
   * @generated from protobuf field: optional uint32 result = 1;
   */
  result?: number;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseFinalize
 */
export interface CMsgGCStorePurchaseFinalize {
  /**
   * @generated from protobuf field: optional uint64 txn_id = 1;
   */
  txnId?: bigint;
}
/**
 * @generated from protobuf message CMsgGCStorePurchaseFinalizeResponse
 */
export interface CMsgGCStorePurchaseFinalizeResponse {
  /**
   * @generated from protobuf field: optional uint32 result = 1;
   */
  result?: number;
  /**
   * @generated from protobuf field: repeated uint64 item_ids = 2;
   */
  itemIds: bigint[];
}
/**
 * @generated from protobuf message CMsgGCToGCBannedWordListUpdated
 */
export interface CMsgGCToGCBannedWordListUpdated {
  /**
   * @generated from protobuf field: optional uint32 group_id = 1;
   */
  groupId?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCDirtySDOCache
 */
export interface CMsgGCToGCDirtySDOCache {
  /**
   * @generated from protobuf field: optional uint32 sdo_type = 1;
   */
  sdoType?: number;
  /**
   * @generated from protobuf field: optional uint64 key_uint64 = 2;
   */
  keyUint64?: bigint;
}
/**
 * @generated from protobuf message CMsgSDONoMemcached
 */
export interface CMsgSDONoMemcached {}
/**
 * @generated from protobuf message CMsgGCToGCUpdateSQLKeyValue
 */
export interface CMsgGCToGCUpdateSQLKeyValue {
  /**
   * @generated from protobuf field: optional string key_name = 1;
   */
  keyName?: string;
}
/**
 * @generated from protobuf message CMsgGCServerVersionUpdated
 */
export interface CMsgGCServerVersionUpdated {
  /**
   * @generated from protobuf field: optional uint32 server_version = 1;
   */
  serverVersion?: number;
}
/**
 * @generated from protobuf message CMsgGCClientVersionUpdated
 */
export interface CMsgGCClientVersionUpdated {
  /**
   * @generated from protobuf field: optional uint32 client_version = 1;
   */
  clientVersion?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCWebAPIAccountChanged
 */
export interface CMsgGCToGCWebAPIAccountChanged {}
/**
 * @generated from protobuf message CMsgExtractGems
 */
export interface CMsgExtractGems {
  /**
   * @generated from protobuf field: optional uint64 tool_item_id = 1;
   */
  toolItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  itemItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 item_socket_id = 3;
   */
  itemSocketId?: number;
}
/**
 * @generated from protobuf message CMsgExtractGemsResponse
 */
export interface CMsgExtractGemsResponse {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  itemId?: bigint;
  /**
   * @generated from protobuf field: optional CMsgExtractGemsResponse.EExtractGems response = 2;
   */
  response?: CMsgExtractGemsResponse_EExtractGems;
}
/**
 * @generated from protobuf enum CMsgExtractGemsResponse.EExtractGems
 */
export enum CMsgExtractGemsResponse_EExtractGems {
  /**
   * @generated from protobuf enum value: k_ExtractGems_Succeeded = 0;
   */
  k_ExtractGems_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ToolIsInvalid = 1;
   */
  k_ExtractGems_Failed_ToolIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ItemIsInvalid = 2;
   */
  k_ExtractGems_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_ToolCannotRemoveGem = 3;
   */
  k_ExtractGems_Failed_ToolCannotRemoveGem = 3,
  /**
   * @generated from protobuf enum value: k_ExtractGems_Failed_FailedToRemoveGem = 4;
   */
  k_ExtractGems_Failed_FailedToRemoveGem = 4,
}
/**
 * @generated from protobuf message CMsgAddSocket
 */
export interface CMsgAddSocket {
  /**
   * @generated from protobuf field: optional uint64 tool_item_id = 1;
   */
  toolItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 2;
   */
  itemItemId?: bigint;
  /**
   * @generated from protobuf field: optional bool unusual = 3;
   */
  unusual?: boolean;
}
/**
 * @generated from protobuf message CMsgAddSocketResponse
 */
export interface CMsgAddSocketResponse {
  /**
   * @generated from protobuf field: optional uint64 item_id = 1;
   */
  itemId?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 updated_socket_index = 2;
   */
  updatedSocketIndex: number[];
  /**
   * @generated from protobuf field: optional CMsgAddSocketResponse.EAddSocket response = 3;
   */
  response?: CMsgAddSocketResponse_EAddSocket;
}
/**
 * @generated from protobuf enum CMsgAddSocketResponse.EAddSocket
 */
export enum CMsgAddSocketResponse_EAddSocket {
  /**
   * @generated from protobuf enum value: k_AddSocket_Succeeded = 0;
   */
  k_AddSocket_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_ToolIsInvalid = 1;
   */
  k_AddSocket_Failed_ToolIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_ItemCannotBeSocketed = 2;
   */
  k_AddSocket_Failed_ItemCannotBeSocketed = 2,
  /**
   * @generated from protobuf enum value: k_AddSocket_Failed_FailedToAddSocket = 3;
   */
  k_AddSocket_Failed_FailedToAddSocket = 3,
}
/**
 * @generated from protobuf message CMsgAddItemToSocketData
 */
export interface CMsgAddItemToSocketData {
  /**
   * @generated from protobuf field: optional uint64 gem_item_id = 1;
   */
  gemItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 socket_index = 2;
   */
  socketIndex?: number;
}
/**
 * @generated from protobuf message CMsgAddItemToSocket
 */
export interface CMsgAddItemToSocket {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  itemItemId?: bigint;
  /**
   * @generated from protobuf field: repeated CMsgAddItemToSocketData gems_to_socket = 2;
   */
  gemsToSocket: CMsgAddItemToSocketData[];
}
/**
 * @generated from protobuf message CMsgAddItemToSocketResponse
 */
export interface CMsgAddItemToSocketResponse {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  itemItemId?: bigint;
  /**
   * @generated from protobuf field: repeated uint32 updated_socket_index = 2;
   */
  updatedSocketIndex: number[];
  /**
   * @generated from protobuf field: optional CMsgAddItemToSocketResponse.EAddGem response = 3;
   */
  response?: CMsgAddItemToSocketResponse_EAddGem;
}
/**
 * @generated from protobuf enum CMsgAddItemToSocketResponse.EAddGem
 */
export enum CMsgAddItemToSocketResponse_EAddGem {
  /**
   * @generated from protobuf enum value: k_AddGem_Succeeded = 0;
   */
  k_AddGem_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_GemIsInvalid = 1;
   */
  k_AddGem_Failed_GemIsInvalid = 1,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_ItemIsInvalid = 2;
   */
  k_AddGem_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_FailedToAddGem = 3;
   */
  k_AddGem_Failed_FailedToAddGem = 3,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForSocket = 4;
   */
  k_AddGem_Failed_InvalidGemTypeForSocket = 4,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForHero = 5;
   */
  k_AddGem_Failed_InvalidGemTypeForHero = 5,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_InvalidGemTypeForSlot = 6;
   */
  k_AddGem_Failed_InvalidGemTypeForSlot = 6,
  /**
   * @generated from protobuf enum value: k_AddGem_Failed_SocketContainsUnremovableGem = 7;
   */
  k_AddGem_Failed_SocketContainsUnremovableGem = 7,
}
/**
 * @generated from protobuf message CMsgResetStrangeGemCount
 */
export interface CMsgResetStrangeGemCount {
  /**
   * @generated from protobuf field: optional uint64 item_item_id = 1;
   */
  itemItemId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 socket_index = 2;
   */
  socketIndex?: number;
}
/**
 * @generated from protobuf message CMsgResetStrangeGemCountResponse
 */
export interface CMsgResetStrangeGemCountResponse {
  /**
   * @generated from protobuf field: optional CMsgResetStrangeGemCountResponse.EResetGem response = 1;
   */
  response?: CMsgResetStrangeGemCountResponse_EResetGem;
}
/**
 * @generated from protobuf enum CMsgResetStrangeGemCountResponse.EResetGem
 */
export enum CMsgResetStrangeGemCountResponse_EResetGem {
  /**
   * @generated from protobuf enum value: k_ResetGem_Succeeded = 0;
   */
  k_ResetGem_Succeeded = 0,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_FailedToResetGem = 1;
   */
  k_ResetGem_Failed_FailedToResetGem = 1,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_ItemIsInvalid = 2;
   */
  k_ResetGem_Failed_ItemIsInvalid = 2,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_InvalidSocketId = 3;
   */
  k_ResetGem_Failed_InvalidSocketId = 3,
  /**
   * @generated from protobuf enum value: k_ResetGem_Failed_SocketCannotBeReset = 4;
   */
  k_ResetGem_Failed_SocketCannotBeReset = 4,
}
/**
 * @generated from protobuf message CMsgGCToClientPollFileRequest
 */
export interface CMsgGCToClientPollFileRequest {
  /**
   * @generated from protobuf field: optional string file_name = 1;
   */
  fileName?: string;
  /**
   * @generated from protobuf field: optional uint32 client_version = 2;
   */
  clientVersion?: number;
  /**
   * @generated from protobuf field: optional uint32 poll_id = 3;
   */
  pollId?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientPollFileResponse
 */
export interface CMsgGCToClientPollFileResponse {
  /**
   * @generated from protobuf field: optional uint32 poll_id = 1;
   */
  pollId?: number;
  /**
   * @generated from protobuf field: optional uint32 file_size = 2;
   */
  fileSize?: number;
  /**
   * @generated from protobuf field: optional uint32 file_crc = 3;
   */
  fileCrc?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCPerformManualOp
 */
export interface CMsgGCToGCPerformManualOp {
  /**
   * @generated from protobuf field: optional uint64 op_id = 1;
   */
  opId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 group_code = 2;
   */
  groupCode?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCPerformManualOpCompleted
 */
export interface CMsgGCToGCPerformManualOpCompleted {
  /**
   * @generated from protobuf field: optional bool success = 1;
   */
  success?: boolean;
  /**
   * @generated from protobuf field: optional int32 source_gc = 2;
   */
  sourceGc?: number;
}
/**
 * @generated from protobuf message CMsgGCToGCReloadServerRegionSettings
 */
export interface CMsgGCToGCReloadServerRegionSettings {}
/**
 * @generated from protobuf message CMsgGCAdditionalWelcomeMsgList
 */
export interface CMsgGCAdditionalWelcomeMsgList {
  /**
   * @generated from protobuf field: repeated CExtraMsgBlock welcome_messages = 1;
   */
  welcomeMessages: CExtraMsgBlock[];
}
/**
 * @generated from protobuf message CMsgApplyRemoteConVars
 */
export interface CMsgApplyRemoteConVars {
  /**
   * @generated from protobuf field: repeated CMsgApplyRemoteConVars.ConVar con_vars = 1;
   */
  conVars: CMsgApplyRemoteConVars_ConVar[];
}
/**
 * @generated from protobuf message CMsgApplyRemoteConVars.ConVar
 */
export interface CMsgApplyRemoteConVars_ConVar {
  /**
   * @generated from protobuf field: optional string name = 1;
   */
  name?: string;
  /**
   * @generated from protobuf field: optional string value = 2;
   */
  value?: string;
  /**
   * @generated from protobuf field: optional uint32 version_min = 3;
   */
  versionMin?: number;
  /**
   * @generated from protobuf field: optional uint32 version_max = 4;
   */
  versionMax?: number;
  /**
   * @generated from protobuf field: optional EGCPlatform platform = 5;
   */
  platform?: EGCPlatform;
}
/**
 * @generated from protobuf message CMsgGCToClientApplyRemoteConVars
 */
export interface CMsgGCToClientApplyRemoteConVars {
  /**
   * @generated from protobuf field: optional CMsgApplyRemoteConVars msg = 1;
   */
  msg?: CMsgApplyRemoteConVars;
}
/**
 * @generated from protobuf message CMsgGCToServerApplyRemoteConVars
 */
export interface CMsgGCToServerApplyRemoteConVars {
  /**
   * @generated from protobuf field: optional CMsgApplyRemoteConVars msg = 1;
   */
  msg?: CMsgApplyRemoteConVars;
}
/**
 * @generated from protobuf message CMsgClientToGCIntegrityStatus
 */
export interface CMsgClientToGCIntegrityStatus {
  /**
   * @generated from protobuf field: optional string report = 1;
   */
  report?: string;
  /**
   * @generated from protobuf field: optional bool secure_allowed = 2;
   */
  secureAllowed?: boolean;
  /**
   * @generated from protobuf field: repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics = 3;
   */
  diagnostics: CMsgClientToGCIntegrityStatus_keyvalue[];
}
/**
 * @generated from protobuf message CMsgClientToGCIntegrityStatus.keyvalue
 */
export interface CMsgClientToGCIntegrityStatus_keyvalue {
  /**
   * @generated from protobuf field: optional uint32 id = 1;
   */
  id?: number;
  /**
   * @generated from protobuf field: optional uint32 extended = 2;
   */
  extended?: number;
  /**
   * @generated from protobuf field: optional uint64 value = 3;
   */
  value?: bigint;
  /**
   * @generated from protobuf field: optional string string_value = 4;
   */
  stringValue?: string;
}
/**
 * @generated from protobuf message CMsgClientToGCAggregateMetrics
 */
export interface CMsgClientToGCAggregateMetrics {
  /**
   * @generated from protobuf field: repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics = 1;
   */
  metrics: CMsgClientToGCAggregateMetrics_SingleMetric[];
}
/**
 * @generated from protobuf message CMsgClientToGCAggregateMetrics.SingleMetric
 */
export interface CMsgClientToGCAggregateMetrics_SingleMetric {
  /**
   * @generated from protobuf field: optional string metric_name = 1;
   */
  metricName?: string;
  /**
   * @generated from protobuf field: optional uint32 metric_count = 2;
   */
  metricCount?: number;
}
/**
 * @generated from protobuf message CMsgGCToClientAggregateMetricsBackoff
 */
export interface CMsgGCToClientAggregateMetricsBackoff {
  /**
   * @generated from protobuf field: optional float upload_rate_modifier = 1;
   */
  uploadRateModifier?: number;
}
/**
 * @generated from protobuf enum EGCBaseMsg
 */
export enum EGCBaseMsg {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: k_EMsgGCInviteToParty = 4501;
   */
  k_EMsgGCInviteToParty = 4501,
  /**
   * @generated from protobuf enum value: k_EMsgGCInvitationCreated = 4502;
   */
  k_EMsgGCInvitationCreated = 4502,
  /**
   * @generated from protobuf enum value: k_EMsgGCPartyInviteResponse = 4503;
   */
  k_EMsgGCPartyInviteResponse = 4503,
  /**
   * @generated from protobuf enum value: k_EMsgGCKickFromParty = 4504;
   */
  k_EMsgGCKickFromParty = 4504,
  /**
   * @generated from protobuf enum value: k_EMsgGCLeaveParty = 4505;
   */
  k_EMsgGCLeaveParty = 4505,
  /**
   * @generated from protobuf enum value: k_EMsgGCServerAvailable = 4506;
   */
  k_EMsgGCServerAvailable = 4506,
  /**
   * @generated from protobuf enum value: k_EMsgGCClientConnectToServer = 4507;
   */
  k_EMsgGCClientConnectToServer = 4507,
  /**
   * @generated from protobuf enum value: k_EMsgGCGameServerInfo = 4508;
   */
  k_EMsgGCGameServerInfo = 4508,
  /**
   * @generated from protobuf enum value: k_EMsgGCLANServerAvailable = 4511;
   */
  k_EMsgGCLANServerAvailable = 4511,
  /**
   * @generated from protobuf enum value: k_EMsgGCInviteToLobby = 4512;
   */
  k_EMsgGCInviteToLobby = 4512,
  /**
   * @generated from protobuf enum value: k_EMsgGCLobbyInviteResponse = 4513;
   */
  k_EMsgGCLobbyInviteResponse = 4513,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientPollFileRequest = 4514;
   */
  k_EMsgGCToClientPollFileRequest = 4514,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientPollFileResponse = 4515;
   */
  k_EMsgGCToClientPollFileResponse = 4515,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCPerformManualOp = 4516;
   */
  k_EMsgGCToGCPerformManualOp = 4516,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCPerformManualOpCompleted = 4517;
   */
  k_EMsgGCToGCPerformManualOpCompleted = 4517,
  /**
   * @generated from protobuf enum value: k_EMsgGCToGCReloadServerRegionSettings = 4518;
   */
  k_EMsgGCToGCReloadServerRegionSettings = 4518,
  /**
   * @generated from protobuf enum value: k_EMsgGCAdditionalWelcomeMsgList = 4519;
   */
  k_EMsgGCAdditionalWelcomeMsgList = 4519,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientApplyRemoteConVars = 4520;
   */
  k_EMsgGCToClientApplyRemoteConVars = 4520,
  /**
   * @generated from protobuf enum value: k_EMsgGCToServerApplyRemoteConVars = 4521;
   */
  k_EMsgGCToServerApplyRemoteConVars = 4521,
  /**
   * @generated from protobuf enum value: k_EMsgClientToGCIntegrityStatus = 4522;
   */
  k_EMsgClientToGCIntegrityStatus = 4522,
  /**
   * @generated from protobuf enum value: k_EMsgClientToGCAggregateMetrics = 4523;
   */
  k_EMsgClientToGCAggregateMetrics = 4523,
  /**
   * @generated from protobuf enum value: k_EMsgGCToClientAggregateMetricsBackoff = 4524;
   */
  k_EMsgGCToClientAggregateMetricsBackoff = 4524,
}
/**
 * @generated from protobuf enum ECustomGameInstallStatus
 */
export enum ECustomGameInstallStatus {
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Unknown = 0;
   */
  k_ECustomGameInstallStatus_Unknown = 0,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Ready = 1;
   */
  k_ECustomGameInstallStatus_Ready = 1,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_Busy = 2;
   */
  k_ECustomGameInstallStatus_Busy = 2,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedGeneric = 101;
   */
  k_ECustomGameInstallStatus_FailedGeneric = 101,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedInternalError = 102;
   */
  k_ECustomGameInstallStatus_FailedInternalError = 102,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103;
   */
  k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104;
   */
  k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_CRCMismatch = 105;
   */
  k_ECustomGameInstallStatus_CRCMismatch = 105,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedSteam = 106;
   */
  k_ECustomGameInstallStatus_FailedSteam = 106,
  /**
   * @generated from protobuf enum value: k_ECustomGameInstallStatus_FailedCanceled = 107;
   */
  k_ECustomGameInstallStatus_FailedCanceled = 107,
}
// @generated message type with reflection information, may provide speed optimized methods
class CGCStorePurchaseInit_LineItem$Type extends MessageType<CGCStorePurchaseInit_LineItem> {
  constructor() {
    super("CGCStorePurchaseInit_LineItem", [
      {
        no: 1,
        name: "item_def_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "quantity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "cost_in_local_currency",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "purchase_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "source_reference_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 6,
        name: "price_index",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CGCStorePurchaseInit_LineItem>,
  ): CGCStorePurchaseInit_LineItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CGCStorePurchaseInit_LineItem>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CGCStorePurchaseInit_LineItem,
  ): CGCStorePurchaseInit_LineItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 item_def_id */ 1:
          message.itemDefId = reader.uint32();
          break;
        case /* optional uint32 quantity */ 2:
          message.quantity = reader.uint32();
          break;
        case /* optional uint32 cost_in_local_currency */ 3:
          message.costInLocalCurrency = reader.uint32();
          break;
        case /* optional uint32 purchase_type */ 4:
          message.purchaseType = reader.uint32();
          break;
        case /* optional uint64 source_reference_id */ 5:
          message.sourceReferenceId = reader.uint64().toBigInt();
          break;
        case /* optional int32 price_index */ 6:
          message.priceIndex = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CGCStorePurchaseInit_LineItem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 item_def_id = 1; */
    if (message.itemDefId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.itemDefId);
    /* optional uint32 quantity = 2; */
    if (message.quantity !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.quantity);
    /* optional uint32 cost_in_local_currency = 3; */
    if (message.costInLocalCurrency !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.costInLocalCurrency);
    /* optional uint32 purchase_type = 4; */
    if (message.purchaseType !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.purchaseType);
    /* optional uint64 source_reference_id = 5; */
    if (message.sourceReferenceId !== undefined)
      writer.tag(5, WireType.Varint).uint64(message.sourceReferenceId);
    /* optional int32 price_index = 6; */
    if (message.priceIndex !== undefined)
      writer.tag(6, WireType.Varint).int32(message.priceIndex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CGCStorePurchaseInit_LineItem
 */
export const CGCStorePurchaseInit_LineItem =
  new CGCStorePurchaseInit_LineItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseInit$Type extends MessageType<CMsgGCStorePurchaseInit> {
  constructor() {
    super("CMsgGCStorePurchaseInit", [
      {
        no: 1,
        name: "country",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "language",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "currency",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "line_items",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CGCStorePurchaseInit_LineItem,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseInit>,
  ): CMsgGCStorePurchaseInit {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.lineItems = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseInit>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseInit,
  ): CMsgGCStorePurchaseInit {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string country */ 1:
          message.country = reader.string();
          break;
        case /* optional int32 language */ 2:
          message.language = reader.int32();
          break;
        case /* optional int32 currency */ 3:
          message.currency = reader.int32();
          break;
        case /* repeated CGCStorePurchaseInit_LineItem line_items */ 4:
          message.lineItems.push(
            CGCStorePurchaseInit_LineItem.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseInit,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string country = 1; */
    if (message.country !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.country);
    /* optional int32 language = 2; */
    if (message.language !== undefined)
      writer.tag(2, WireType.Varint).int32(message.language);
    /* optional int32 currency = 3; */
    if (message.currency !== undefined)
      writer.tag(3, WireType.Varint).int32(message.currency);
    /* repeated CGCStorePurchaseInit_LineItem line_items = 4; */
    for (let i = 0; i < message.lineItems.length; i++)
      CGCStorePurchaseInit_LineItem.internalBinaryWrite(
        message.lineItems[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseInit
 */
export const CMsgGCStorePurchaseInit = new CMsgGCStorePurchaseInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseInitResponse$Type extends MessageType<CMsgGCStorePurchaseInitResponse> {
  constructor() {
    super("CMsgGCStorePurchaseInitResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "txn_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseInitResponse>,
  ): CMsgGCStorePurchaseInitResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseInitResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseInitResponse,
  ): CMsgGCStorePurchaseInitResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 result */ 1:
          message.result = reader.int32();
          break;
        case /* optional uint64 txn_id */ 2:
          message.txnId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseInitResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 result = 1; */
    if (message.result !== undefined)
      writer.tag(1, WireType.Varint).int32(message.result);
    /* optional uint64 txn_id = 2; */
    if (message.txnId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.txnId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseInitResponse
 */
export const CMsgGCStorePurchaseInitResponse =
  new CMsgGCStorePurchaseInitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientPingData$Type extends MessageType<CMsgClientPingData> {
  constructor() {
    super("CMsgClientPingData", [
      {
        no: 4,
        name: "relay_codes",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 5,
        name: "relay_pings",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "region_codes",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "region_pings",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "region_ping_failed_bitmask",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgClientPingData>): CMsgClientPingData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.relayCodes = [];
    message.relayPings = [];
    message.regionCodes = [];
    message.regionPings = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgClientPingData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientPingData,
  ): CMsgClientPingData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated fixed32 relay_codes = 4 [packed = true];*/ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.relayCodes.push(reader.fixed32());
          else message.relayCodes.push(reader.fixed32());
          break;
        case /* repeated uint32 relay_pings = 5 [packed = true];*/ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.relayPings.push(reader.uint32());
          else message.relayPings.push(reader.uint32());
          break;
        case /* repeated uint32 region_codes = 8 [packed = true];*/ 8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.regionCodes.push(reader.uint32());
          else message.regionCodes.push(reader.uint32());
          break;
        case /* repeated uint32 region_pings = 9 [packed = true];*/ 9:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.regionPings.push(reader.uint32());
          else message.regionPings.push(reader.uint32());
          break;
        case /* optional uint32 region_ping_failed_bitmask */ 10:
          message.regionPingFailedBitmask = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientPingData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated fixed32 relay_codes = 4 [packed = true]; */
    if (message.relayCodes.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.relayCodes.length; i++)
        writer.fixed32(message.relayCodes[i]);
      writer.join();
    }
    /* repeated uint32 relay_pings = 5 [packed = true]; */
    if (message.relayPings.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.relayPings.length; i++)
        writer.uint32(message.relayPings[i]);
      writer.join();
    }
    /* repeated uint32 region_codes = 8 [packed = true]; */
    if (message.regionCodes.length) {
      writer.tag(8, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.regionCodes.length; i++)
        writer.uint32(message.regionCodes[i]);
      writer.join();
    }
    /* repeated uint32 region_pings = 9 [packed = true]; */
    if (message.regionPings.length) {
      writer.tag(9, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.regionPings.length; i++)
        writer.uint32(message.regionPings[i]);
      writer.join();
    }
    /* optional uint32 region_ping_failed_bitmask = 10; */
    if (message.regionPingFailedBitmask !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.regionPingFailedBitmask);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientPingData
 */
export const CMsgClientPingData = new CMsgClientPingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInviteToParty$Type extends MessageType<CMsgInviteToParty> {
  constructor() {
    super("CMsgInviteToParty", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "team_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "as_coach",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "ping_data",
        kind: "message",
        T: () => CMsgClientPingData,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInviteToParty>): CMsgInviteToParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgInviteToParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInviteToParty,
  ): CMsgInviteToParty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steamId = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 client_version */ 2:
          message.clientVersion = reader.uint32();
          break;
        case /* optional uint32 team_id */ 3:
          message.teamId = reader.uint32();
          break;
        case /* optional bool as_coach */ 4:
          message.asCoach = reader.bool();
          break;
        case /* optional CMsgClientPingData ping_data */ 5:
          message.pingData = CMsgClientPingData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgInviteToParty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steamId !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.steamId);
    /* optional uint32 client_version = 2; */
    if (message.clientVersion !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.clientVersion);
    /* optional uint32 team_id = 3; */
    if (message.teamId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.teamId);
    /* optional bool as_coach = 4; */
    if (message.asCoach !== undefined)
      writer.tag(4, WireType.Varint).bool(message.asCoach);
    /* optional CMsgClientPingData ping_data = 5; */
    if (message.pingData)
      CMsgClientPingData.internalBinaryWrite(
        message.pingData,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInviteToParty
 */
export const CMsgInviteToParty = new CMsgInviteToParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInviteToLobby$Type extends MessageType<CMsgInviteToLobby> {
  constructor() {
    super("CMsgInviteToLobby", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInviteToLobby>): CMsgInviteToLobby {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgInviteToLobby>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInviteToLobby,
  ): CMsgInviteToLobby {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steamId = reader.fixed64().toBigInt();
          break;
        case /* optional uint32 client_version */ 2:
          message.clientVersion = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgInviteToLobby,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steamId !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.steamId);
    /* optional uint32 client_version = 2; */
    if (message.clientVersion !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.clientVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInviteToLobby
 */
export const CMsgInviteToLobby = new CMsgInviteToLobby$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgInvitationCreated$Type extends MessageType<CMsgInvitationCreated> {
  constructor() {
    super("CMsgInvitationCreated", [
      {
        no: 1,
        name: "group_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "steam_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "user_offline",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgInvitationCreated>): CMsgInvitationCreated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgInvitationCreated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgInvitationCreated,
  ): CMsgInvitationCreated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 group_id */ 1:
          message.groupId = reader.uint64().toBigInt();
          break;
        case /* optional fixed64 steam_id */ 2:
          message.steamId = reader.fixed64().toBigInt();
          break;
        case /* optional bool user_offline */ 3:
          message.userOffline = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgInvitationCreated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 group_id = 1; */
    if (message.groupId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.groupId);
    /* optional fixed64 steam_id = 2; */
    if (message.steamId !== undefined)
      writer.tag(2, WireType.Bit64).fixed64(message.steamId);
    /* optional bool user_offline = 3; */
    if (message.userOffline !== undefined)
      writer.tag(3, WireType.Varint).bool(message.userOffline);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgInvitationCreated
 */
export const CMsgInvitationCreated = new CMsgInvitationCreated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPartyInviteResponse$Type extends MessageType<CMsgPartyInviteResponse> {
  constructor() {
    super("CMsgPartyInviteResponse", [
      {
        no: 1,
        name: "party_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "accept",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "ping_data",
        kind: "message",
        T: () => CMsgClientPingData,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgPartyInviteResponse>,
  ): CMsgPartyInviteResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgPartyInviteResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgPartyInviteResponse,
  ): CMsgPartyInviteResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 party_id */ 1:
          message.partyId = reader.uint64().toBigInt();
          break;
        case /* optional bool accept */ 2:
          message.accept = reader.bool();
          break;
        case /* optional uint32 client_version */ 3:
          message.clientVersion = reader.uint32();
          break;
        case /* optional CMsgClientPingData ping_data */ 8:
          message.pingData = CMsgClientPingData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pingData,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgPartyInviteResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 party_id = 1; */
    if (message.partyId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.partyId);
    /* optional bool accept = 2; */
    if (message.accept !== undefined)
      writer.tag(2, WireType.Varint).bool(message.accept);
    /* optional uint32 client_version = 3; */
    if (message.clientVersion !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.clientVersion);
    /* optional CMsgClientPingData ping_data = 8; */
    if (message.pingData)
      CMsgClientPingData.internalBinaryWrite(
        message.pingData,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgPartyInviteResponse
 */
export const CMsgPartyInviteResponse = new CMsgPartyInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLobbyInviteResponse$Type extends MessageType<CMsgLobbyInviteResponse> {
  constructor() {
    super("CMsgLobbyInviteResponse", [
      {
        no: 1,
        name: "lobby_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "accept",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "custom_game_crc",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 7,
        name: "custom_game_timestamp",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgLobbyInviteResponse>,
  ): CMsgLobbyInviteResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgLobbyInviteResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLobbyInviteResponse,
  ): CMsgLobbyInviteResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 lobby_id */ 1:
          message.lobbyId = reader.fixed64().toBigInt();
          break;
        case /* optional bool accept */ 2:
          message.accept = reader.bool();
          break;
        case /* optional uint32 client_version */ 3:
          message.clientVersion = reader.uint32();
          break;
        case /* optional fixed64 custom_game_crc */ 6:
          message.customGameCrc = reader.fixed64().toBigInt();
          break;
        case /* optional fixed32 custom_game_timestamp */ 7:
          message.customGameTimestamp = reader.fixed32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgLobbyInviteResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 lobby_id = 1; */
    if (message.lobbyId !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.lobbyId);
    /* optional bool accept = 2; */
    if (message.accept !== undefined)
      writer.tag(2, WireType.Varint).bool(message.accept);
    /* optional uint32 client_version = 3; */
    if (message.clientVersion !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.clientVersion);
    /* optional fixed64 custom_game_crc = 6; */
    if (message.customGameCrc !== undefined)
      writer.tag(6, WireType.Bit64).fixed64(message.customGameCrc);
    /* optional fixed32 custom_game_timestamp = 7; */
    if (message.customGameTimestamp !== undefined)
      writer.tag(7, WireType.Bit32).fixed32(message.customGameTimestamp);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLobbyInviteResponse
 */
export const CMsgLobbyInviteResponse = new CMsgLobbyInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgKickFromParty$Type extends MessageType<CMsgKickFromParty> {
  constructor() {
    super("CMsgKickFromParty", [
      {
        no: 1,
        name: "steam_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgKickFromParty>): CMsgKickFromParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgKickFromParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgKickFromParty,
  ): CMsgKickFromParty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 steam_id */ 1:
          message.steamId = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgKickFromParty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 steam_id = 1; */
    if (message.steamId !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.steamId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgKickFromParty
 */
export const CMsgKickFromParty = new CMsgKickFromParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLeaveParty$Type extends MessageType<CMsgLeaveParty> {
  constructor() {
    super("CMsgLeaveParty", []);
  }
  create(value?: PartialMessage<CMsgLeaveParty>): CMsgLeaveParty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgLeaveParty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLeaveParty,
  ): CMsgLeaveParty {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgLeaveParty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLeaveParty
 */
export const CMsgLeaveParty = new CMsgLeaveParty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgCustomGameInstallStatus$Type extends MessageType<CMsgCustomGameInstallStatus> {
  constructor() {
    super("CMsgCustomGameInstallStatus", [
      {
        no: 1,
        name: "status",
        kind: "enum",
        opt: true,
        T: () => ["ECustomGameInstallStatus", ECustomGameInstallStatus],
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "latest_timestamp_from_steam",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgCustomGameInstallStatus>,
  ): CMsgCustomGameInstallStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgCustomGameInstallStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgCustomGameInstallStatus,
  ): CMsgCustomGameInstallStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional ECustomGameInstallStatus status */ 1:
          message.status = reader.int32();
          break;
        case /* optional string message */ 2:
          message.message = reader.string();
          break;
        case /* optional fixed32 latest_timestamp_from_steam */ 3:
          message.latestTimestampFromSteam = reader.fixed32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgCustomGameInstallStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional ECustomGameInstallStatus status = 1; */
    if (message.status !== undefined)
      writer.tag(1, WireType.Varint).int32(message.status);
    /* optional string message = 2; */
    if (message.message !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* optional fixed32 latest_timestamp_from_steam = 3; */
    if (message.latestTimestampFromSteam !== undefined)
      writer.tag(3, WireType.Bit32).fixed32(message.latestTimestampFromSteam);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgCustomGameInstallStatus
 */
export const CMsgCustomGameInstallStatus =
  new CMsgCustomGameInstallStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerAvailable$Type extends MessageType<CMsgServerAvailable> {
  constructor() {
    super("CMsgServerAvailable", [
      {
        no: 1,
        name: "custom_game_install_status",
        kind: "message",
        T: () => CMsgCustomGameInstallStatus,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgServerAvailable>): CMsgServerAvailable {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgServerAvailable>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgServerAvailable,
  ): CMsgServerAvailable {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgCustomGameInstallStatus custom_game_install_status */ 1:
          message.customGameInstallStatus =
            CMsgCustomGameInstallStatus.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.customGameInstallStatus,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgServerAvailable,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgCustomGameInstallStatus custom_game_install_status = 1; */
    if (message.customGameInstallStatus)
      CMsgCustomGameInstallStatus.internalBinaryWrite(
        message.customGameInstallStatus,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgServerAvailable
 */
export const CMsgServerAvailable = new CMsgServerAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgLANServerAvailable$Type extends MessageType<CMsgLANServerAvailable> {
  constructor() {
    super("CMsgLANServerAvailable", [
      {
        no: 1,
        name: "lobby_id",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgLANServerAvailable>,
  ): CMsgLANServerAvailable {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgLANServerAvailable>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgLANServerAvailable,
  ): CMsgLANServerAvailable {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 lobby_id */ 1:
          message.lobbyId = reader.fixed64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgLANServerAvailable,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 lobby_id = 1; */
    if (message.lobbyId !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.lobbyId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgLANServerAvailable
 */
export const CMsgLANServerAvailable = new CMsgLANServerAvailable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconGameAccountClient$Type extends MessageType<CSOEconGameAccountClient> {
  constructor() {
    super("CSOEconGameAccountClient", [
      {
        no: 1,
        name: "additional_backpack_slots",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "trial_account",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "eligible_for_online_play",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "need_to_choose_most_helpful_friend",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "in_coaches_list",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "trade_ban_expiration",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 7,
        name: "duel_ban_expiration",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 9,
        name: "made_first_purchase",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CSOEconGameAccountClient>,
  ): CSOEconGameAccountClient {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOEconGameAccountClient>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconGameAccountClient,
  ): CSOEconGameAccountClient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 additional_backpack_slots */ 1:
          message.additionalBackpackSlots = reader.uint32();
          break;
        case /* optional bool trial_account */ 2:
          message.trialAccount = reader.bool();
          break;
        case /* optional bool eligible_for_online_play */ 3:
          message.eligibleForOnlinePlay = reader.bool();
          break;
        case /* optional bool need_to_choose_most_helpful_friend */ 4:
          message.needToChooseMostHelpfulFriend = reader.bool();
          break;
        case /* optional bool in_coaches_list */ 5:
          message.inCoachesList = reader.bool();
          break;
        case /* optional fixed32 trade_ban_expiration */ 6:
          message.tradeBanExpiration = reader.fixed32();
          break;
        case /* optional fixed32 duel_ban_expiration */ 7:
          message.duelBanExpiration = reader.fixed32();
          break;
        case /* optional bool made_first_purchase */ 9:
          message.madeFirstPurchase = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconGameAccountClient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 additional_backpack_slots = 1; */
    if (message.additionalBackpackSlots !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.additionalBackpackSlots);
    /* optional bool trial_account = 2; */
    if (message.trialAccount !== undefined)
      writer.tag(2, WireType.Varint).bool(message.trialAccount);
    /* optional bool eligible_for_online_play = 3; */
    if (message.eligibleForOnlinePlay !== undefined)
      writer.tag(3, WireType.Varint).bool(message.eligibleForOnlinePlay);
    /* optional bool need_to_choose_most_helpful_friend = 4; */
    if (message.needToChooseMostHelpfulFriend !== undefined)
      writer
        .tag(4, WireType.Varint)
        .bool(message.needToChooseMostHelpfulFriend);
    /* optional bool in_coaches_list = 5; */
    if (message.inCoachesList !== undefined)
      writer.tag(5, WireType.Varint).bool(message.inCoachesList);
    /* optional fixed32 trade_ban_expiration = 6; */
    if (message.tradeBanExpiration !== undefined)
      writer.tag(6, WireType.Bit32).fixed32(message.tradeBanExpiration);
    /* optional fixed32 duel_ban_expiration = 7; */
    if (message.duelBanExpiration !== undefined)
      writer.tag(7, WireType.Bit32).fixed32(message.duelBanExpiration);
    /* optional bool made_first_purchase = 9; */
    if (message.madeFirstPurchase !== undefined)
      writer.tag(9, WireType.Varint).bool(message.madeFirstPurchase);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconGameAccountClient
 */
export const CSOEconGameAccountClient = new CSOEconGameAccountClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyStrangePart$Type extends MessageType<CMsgApplyStrangePart> {
  constructor() {
    super("CMsgApplyStrangePart", [
      {
        no: 1,
        name: "strange_part_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyStrangePart>): CMsgApplyStrangePart {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgApplyStrangePart>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyStrangePart,
  ): CMsgApplyStrangePart {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 strange_part_item_id */ 1:
          message.strangePartItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyStrangePart,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 strange_part_item_id = 1; */
    if (message.strangePartItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.strangePartItemId);
    /* optional uint64 item_item_id = 2; */
    if (message.itemItemId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.itemItemId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyStrangePart
 */
export const CMsgApplyStrangePart = new CMsgApplyStrangePart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyPennantUpgrade$Type extends MessageType<CMsgApplyPennantUpgrade> {
  constructor() {
    super("CMsgApplyPennantUpgrade", [
      {
        no: 1,
        name: "upgrade_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "pennant_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgApplyPennantUpgrade>,
  ): CMsgApplyPennantUpgrade {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgApplyPennantUpgrade>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyPennantUpgrade,
  ): CMsgApplyPennantUpgrade {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 upgrade_item_id */ 1:
          message.upgradeItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 pennant_item_id */ 2:
          message.pennantItemId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyPennantUpgrade,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 upgrade_item_id = 1; */
    if (message.upgradeItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.upgradeItemId);
    /* optional uint64 pennant_item_id = 2; */
    if (message.pennantItemId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.pennantItemId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyPennantUpgrade
 */
export const CMsgApplyPennantUpgrade = new CMsgApplyPennantUpgrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyEggEssence$Type extends MessageType<CMsgApplyEggEssence> {
  constructor() {
    super("CMsgApplyEggEssence", [
      {
        no: 1,
        name: "essence_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "egg_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgApplyEggEssence>): CMsgApplyEggEssence {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgApplyEggEssence>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyEggEssence,
  ): CMsgApplyEggEssence {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 essence_item_id */ 1:
          message.essenceItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 egg_item_id */ 2:
          message.eggItemId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyEggEssence,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 essence_item_id = 1; */
    if (message.essenceItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.essenceItemId);
    /* optional uint64 egg_item_id = 2; */
    if (message.eggItemId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.eggItemId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyEggEssence
 */
export const CMsgApplyEggEssence = new CMsgApplyEggEssence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItemAttribute$Type extends MessageType<CSOEconItemAttribute> {
  constructor() {
    super("CSOEconItemAttribute", [
      {
        no: 1,
        name: "def_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "value_bytes",
        kind: "scalar",
        opt: true,
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItemAttribute>): CSOEconItemAttribute {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOEconItemAttribute>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItemAttribute,
  ): CSOEconItemAttribute {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 def_index */ 1:
          message.defIndex = reader.uint32();
          break;
        case /* optional uint32 value */ 2:
          message.value = reader.uint32();
          break;
        case /* optional bytes value_bytes */ 3:
          message.valueBytes = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconItemAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 def_index = 1; */
    if (message.defIndex !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.defIndex);
    /* optional uint32 value = 2; */
    if (message.value !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.value);
    /* optional bytes value_bytes = 3; */
    if (message.valueBytes !== undefined)
      writer.tag(3, WireType.LengthDelimited).bytes(message.valueBytes);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItemAttribute
 */
export const CSOEconItemAttribute = new CSOEconItemAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItemEquipped$Type extends MessageType<CSOEconItemEquipped> {
  constructor() {
    super("CSOEconItemEquipped", [
      {
        no: 1,
        name: "new_class",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "new_slot",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItemEquipped>): CSOEconItemEquipped {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CSOEconItemEquipped>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItemEquipped,
  ): CSOEconItemEquipped {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 new_class */ 1:
          message.newClass = reader.uint32();
          break;
        case /* optional uint32 new_slot */ 2:
          message.newSlot = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconItemEquipped,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 new_class = 1; */
    if (message.newClass !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.newClass);
    /* optional uint32 new_slot = 2; */
    if (message.newSlot !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.newSlot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItemEquipped
 */
export const CSOEconItemEquipped = new CSOEconItemEquipped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSOEconItem$Type extends MessageType<CSOEconItem> {
  constructor() {
    super("CSOEconItem", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "inventory",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "def_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "level",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "quality",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "flags",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "origin",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "attribute",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOEconItemAttribute,
      },
      { no: 13, name: "interior_item", kind: "message", T: () => CSOEconItem },
      {
        no: 15,
        name: "style",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "original_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 18,
        name: "equipped_state",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CSOEconItemEquipped,
      },
    ]);
  }
  create(value?: PartialMessage<CSOEconItem>): CSOEconItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.attribute = [];
    message.equippedState = [];
    if (value !== undefined)
      reflectionMergePartial<CSOEconItem>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CSOEconItem,
  ): CSOEconItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 id */ 1:
          message.id = reader.uint64().toBigInt();
          break;
        case /* optional uint32 account_id */ 2:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 inventory */ 3:
          message.inventory = reader.uint32();
          break;
        case /* optional uint32 def_index */ 4:
          message.defIndex = reader.uint32();
          break;
        case /* optional uint32 quantity */ 5:
          message.quantity = reader.uint32();
          break;
        case /* optional uint32 level */ 6:
          message.level = reader.uint32();
          break;
        case /* optional uint32 quality */ 7:
          message.quality = reader.uint32();
          break;
        case /* optional uint32 flags */ 8:
          message.flags = reader.uint32();
          break;
        case /* optional uint32 origin */ 9:
          message.origin = reader.uint32();
          break;
        case /* repeated CSOEconItemAttribute attribute */ 12:
          message.attribute.push(
            CSOEconItemAttribute.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional CSOEconItem interior_item */ 13:
          message.interiorItem = CSOEconItem.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.interiorItem,
          );
          break;
        case /* optional uint32 style */ 15:
          message.style = reader.uint32();
          break;
        case /* optional uint64 original_id */ 16:
          message.originalId = reader.uint64().toBigInt();
          break;
        case /* repeated CSOEconItemEquipped equipped_state */ 18:
          message.equippedState.push(
            CSOEconItemEquipped.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CSOEconItem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 id = 1; */
    if (message.id !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.id);
    /* optional uint32 account_id = 2; */
    if (message.accountId !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.accountId);
    /* optional uint32 inventory = 3; */
    if (message.inventory !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.inventory);
    /* optional uint32 def_index = 4; */
    if (message.defIndex !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.defIndex);
    /* optional uint32 quantity = 5; */
    if (message.quantity !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.quantity);
    /* optional uint32 level = 6; */
    if (message.level !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.level);
    /* optional uint32 quality = 7; */
    if (message.quality !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.quality);
    /* optional uint32 flags = 8; */
    if (message.flags !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.flags);
    /* optional uint32 origin = 9; */
    if (message.origin !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.origin);
    /* repeated CSOEconItemAttribute attribute = 12; */
    for (let i = 0; i < message.attribute.length; i++)
      CSOEconItemAttribute.internalBinaryWrite(
        message.attribute[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CSOEconItem interior_item = 13; */
    if (message.interiorItem)
      CSOEconItem.internalBinaryWrite(
        message.interiorItem,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 style = 15; */
    if (message.style !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.style);
    /* optional uint64 original_id = 16; */
    if (message.originalId !== undefined)
      writer.tag(16, WireType.Varint).uint64(message.originalId);
    /* repeated CSOEconItemEquipped equipped_state = 18; */
    for (let i = 0; i < message.equippedState.length; i++)
      CSOEconItemEquipped.internalBinaryWrite(
        message.equippedState[i],
        writer.tag(18, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CSOEconItem
 */
export const CSOEconItem = new CSOEconItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSortItems$Type extends MessageType<CMsgSortItems> {
  constructor() {
    super("CMsgSortItems", [
      {
        no: 1,
        name: "sort_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSortItems>): CMsgSortItems {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSortItems>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSortItems,
  ): CMsgSortItems {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 sort_type */ 1:
          message.sortType = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSortItems,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 sort_type = 1; */
    if (message.sortType !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.sortType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSortItems
 */
export const CMsgSortItems = new CMsgSortItems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgItemAcknowledged$Type extends MessageType<CMsgItemAcknowledged> {
  constructor() {
    super("CMsgItemAcknowledged", [
      {
        no: 1,
        name: "account_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "inventory",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "def_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "quality",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "rarity",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "origin",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgItemAcknowledged>): CMsgItemAcknowledged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgItemAcknowledged>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgItemAcknowledged,
  ): CMsgItemAcknowledged {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 account_id */ 1:
          message.accountId = reader.uint32();
          break;
        case /* optional uint32 inventory */ 2:
          message.inventory = reader.uint32();
          break;
        case /* optional uint32 def_index */ 3:
          message.defIndex = reader.uint32();
          break;
        case /* optional uint32 quality */ 4:
          message.quality = reader.uint32();
          break;
        case /* optional uint32 rarity */ 5:
          message.rarity = reader.uint32();
          break;
        case /* optional uint32 origin */ 6:
          message.origin = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgItemAcknowledged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 account_id = 1; */
    if (message.accountId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.accountId);
    /* optional uint32 inventory = 2; */
    if (message.inventory !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.inventory);
    /* optional uint32 def_index = 3; */
    if (message.defIndex !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.defIndex);
    /* optional uint32 quality = 4; */
    if (message.quality !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.quality);
    /* optional uint32 rarity = 5; */
    if (message.rarity !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.rarity);
    /* optional uint32 origin = 6; */
    if (message.origin !== undefined)
      writer.tag(6, WireType.Varint).uint32(message.origin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgItemAcknowledged
 */
export const CMsgItemAcknowledged = new CMsgItemAcknowledged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetItemPositions$Type extends MessageType<CMsgSetItemPositions> {
  constructor() {
    super("CMsgSetItemPositions", [
      {
        no: 1,
        name: "item_positions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgSetItemPositions_ItemPosition,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgSetItemPositions>): CMsgSetItemPositions {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.itemPositions = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgSetItemPositions>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSetItemPositions,
  ): CMsgSetItemPositions {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgSetItemPositions.ItemPosition item_positions */ 1:
          message.itemPositions.push(
            CMsgSetItemPositions_ItemPosition.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSetItemPositions,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgSetItemPositions.ItemPosition item_positions = 1; */
    for (let i = 0; i < message.itemPositions.length; i++)
      CMsgSetItemPositions_ItemPosition.internalBinaryWrite(
        message.itemPositions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSetItemPositions
 */
export const CMsgSetItemPositions = new CMsgSetItemPositions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSetItemPositions_ItemPosition$Type extends MessageType<CMsgSetItemPositions_ItemPosition> {
  constructor() {
    super("CMsgSetItemPositions.ItemPosition", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "position",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgSetItemPositions_ItemPosition>,
  ): CMsgSetItemPositions_ItemPosition {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSetItemPositions_ItemPosition>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSetItemPositions_ItemPosition,
  ): CMsgSetItemPositions_ItemPosition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.itemId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 position */ 2:
          message.position = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgSetItemPositions_ItemPosition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.itemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemId);
    /* optional uint32 position = 2; */
    if (message.position !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.position);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSetItemPositions.ItemPosition
 */
export const CMsgSetItemPositions_ItemPosition =
  new CMsgSetItemPositions_ItemPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseCancel$Type extends MessageType<CMsgGCStorePurchaseCancel> {
  constructor() {
    super("CMsgGCStorePurchaseCancel", [
      {
        no: 1,
        name: "txn_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseCancel>,
  ): CMsgGCStorePurchaseCancel {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseCancel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseCancel,
  ): CMsgGCStorePurchaseCancel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 txn_id */ 1:
          message.txnId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseCancel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 txn_id = 1; */
    if (message.txnId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.txnId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseCancel
 */
export const CMsgGCStorePurchaseCancel = new CMsgGCStorePurchaseCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseCancelResponse$Type extends MessageType<CMsgGCStorePurchaseCancelResponse> {
  constructor() {
    super("CMsgGCStorePurchaseCancelResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseCancelResponse>,
  ): CMsgGCStorePurchaseCancelResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseCancelResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseCancelResponse,
  ): CMsgGCStorePurchaseCancelResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 result */ 1:
          message.result = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseCancelResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 result = 1; */
    if (message.result !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.result);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseCancelResponse
 */
export const CMsgGCStorePurchaseCancelResponse =
  new CMsgGCStorePurchaseCancelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseFinalize$Type extends MessageType<CMsgGCStorePurchaseFinalize> {
  constructor() {
    super("CMsgGCStorePurchaseFinalize", [
      {
        no: 1,
        name: "txn_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseFinalize>,
  ): CMsgGCStorePurchaseFinalize {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseFinalize>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseFinalize,
  ): CMsgGCStorePurchaseFinalize {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 txn_id */ 1:
          message.txnId = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseFinalize,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 txn_id = 1; */
    if (message.txnId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.txnId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseFinalize
 */
export const CMsgGCStorePurchaseFinalize =
  new CMsgGCStorePurchaseFinalize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCStorePurchaseFinalizeResponse$Type extends MessageType<CMsgGCStorePurchaseFinalizeResponse> {
  constructor() {
    super("CMsgGCStorePurchaseFinalizeResponse", [
      {
        no: 1,
        name: "result",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "item_ids",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCStorePurchaseFinalizeResponse>,
  ): CMsgGCStorePurchaseFinalizeResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.itemIds = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgGCStorePurchaseFinalizeResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCStorePurchaseFinalizeResponse,
  ): CMsgGCStorePurchaseFinalizeResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 result */ 1:
          message.result = reader.uint32();
          break;
        case /* repeated uint64 item_ids */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.itemIds.push(reader.uint64().toBigInt());
          else message.itemIds.push(reader.uint64().toBigInt());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCStorePurchaseFinalizeResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 result = 1; */
    if (message.result !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.result);
    /* repeated uint64 item_ids = 2; */
    for (let i = 0; i < message.itemIds.length; i++)
      writer.tag(2, WireType.Varint).uint64(message.itemIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCStorePurchaseFinalizeResponse
 */
export const CMsgGCStorePurchaseFinalizeResponse =
  new CMsgGCStorePurchaseFinalizeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCBannedWordListUpdated$Type extends MessageType<CMsgGCToGCBannedWordListUpdated> {
  constructor() {
    super("CMsgGCToGCBannedWordListUpdated", [
      {
        no: 1,
        name: "group_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCBannedWordListUpdated>,
  ): CMsgGCToGCBannedWordListUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCBannedWordListUpdated>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCBannedWordListUpdated,
  ): CMsgGCToGCBannedWordListUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 group_id */ 1:
          message.groupId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCBannedWordListUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 group_id = 1; */
    if (message.groupId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.groupId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCBannedWordListUpdated
 */
export const CMsgGCToGCBannedWordListUpdated =
  new CMsgGCToGCBannedWordListUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCDirtySDOCache$Type extends MessageType<CMsgGCToGCDirtySDOCache> {
  constructor() {
    super("CMsgGCToGCDirtySDOCache", [
      {
        no: 1,
        name: "sdo_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "key_uint64",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCDirtySDOCache>,
  ): CMsgGCToGCDirtySDOCache {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCDirtySDOCache>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCDirtySDOCache,
  ): CMsgGCToGCDirtySDOCache {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 sdo_type */ 1:
          message.sdoType = reader.uint32();
          break;
        case /* optional uint64 key_uint64 */ 2:
          message.keyUint64 = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCDirtySDOCache,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 sdo_type = 1; */
    if (message.sdoType !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.sdoType);
    /* optional uint64 key_uint64 = 2; */
    if (message.keyUint64 !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.keyUint64);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCDirtySDOCache
 */
export const CMsgGCToGCDirtySDOCache = new CMsgGCToGCDirtySDOCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSDONoMemcached$Type extends MessageType<CMsgSDONoMemcached> {
  constructor() {
    super("CMsgSDONoMemcached", []);
  }
  create(value?: PartialMessage<CMsgSDONoMemcached>): CMsgSDONoMemcached {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgSDONoMemcached>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgSDONoMemcached,
  ): CMsgSDONoMemcached {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgSDONoMemcached,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgSDONoMemcached
 */
export const CMsgSDONoMemcached = new CMsgSDONoMemcached$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCUpdateSQLKeyValue$Type extends MessageType<CMsgGCToGCUpdateSQLKeyValue> {
  constructor() {
    super("CMsgGCToGCUpdateSQLKeyValue", [
      {
        no: 1,
        name: "key_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCUpdateSQLKeyValue>,
  ): CMsgGCToGCUpdateSQLKeyValue {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCUpdateSQLKeyValue>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCUpdateSQLKeyValue,
  ): CMsgGCToGCUpdateSQLKeyValue {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string key_name */ 1:
          message.keyName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCUpdateSQLKeyValue,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string key_name = 1; */
    if (message.keyName !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.keyName);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCUpdateSQLKeyValue
 */
export const CMsgGCToGCUpdateSQLKeyValue =
  new CMsgGCToGCUpdateSQLKeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCServerVersionUpdated$Type extends MessageType<CMsgGCServerVersionUpdated> {
  constructor() {
    super("CMsgGCServerVersionUpdated", [
      {
        no: 1,
        name: "server_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCServerVersionUpdated>,
  ): CMsgGCServerVersionUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCServerVersionUpdated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCServerVersionUpdated,
  ): CMsgGCServerVersionUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 server_version */ 1:
          message.serverVersion = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCServerVersionUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 server_version = 1; */
    if (message.serverVersion !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.serverVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCServerVersionUpdated
 */
export const CMsgGCServerVersionUpdated = new CMsgGCServerVersionUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCClientVersionUpdated$Type extends MessageType<CMsgGCClientVersionUpdated> {
  constructor() {
    super("CMsgGCClientVersionUpdated", [
      {
        no: 1,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCClientVersionUpdated>,
  ): CMsgGCClientVersionUpdated {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCClientVersionUpdated>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCClientVersionUpdated,
  ): CMsgGCClientVersionUpdated {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 client_version */ 1:
          message.clientVersion = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCClientVersionUpdated,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 client_version = 1; */
    if (message.clientVersion !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.clientVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCClientVersionUpdated
 */
export const CMsgGCClientVersionUpdated = new CMsgGCClientVersionUpdated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCWebAPIAccountChanged$Type extends MessageType<CMsgGCToGCWebAPIAccountChanged> {
  constructor() {
    super("CMsgGCToGCWebAPIAccountChanged", []);
  }
  create(
    value?: PartialMessage<CMsgGCToGCWebAPIAccountChanged>,
  ): CMsgGCToGCWebAPIAccountChanged {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCWebAPIAccountChanged>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCWebAPIAccountChanged,
  ): CMsgGCToGCWebAPIAccountChanged {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCWebAPIAccountChanged,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCWebAPIAccountChanged
 */
export const CMsgGCToGCWebAPIAccountChanged =
  new CMsgGCToGCWebAPIAccountChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgExtractGems$Type extends MessageType<CMsgExtractGems> {
  constructor() {
    super("CMsgExtractGems", [
      {
        no: 1,
        name: "tool_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "item_socket_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgExtractGems>): CMsgExtractGems {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgExtractGems>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgExtractGems,
  ): CMsgExtractGems {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 tool_item_id */ 1:
          message.toolItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 item_socket_id */ 3:
          message.itemSocketId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgExtractGems,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 tool_item_id = 1; */
    if (message.toolItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.toolItemId);
    /* optional uint64 item_item_id = 2; */
    if (message.itemItemId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.itemItemId);
    /* optional uint32 item_socket_id = 3; */
    if (message.itemSocketId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.itemSocketId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgExtractGems
 */
export const CMsgExtractGems = new CMsgExtractGems$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgExtractGemsResponse$Type extends MessageType<CMsgExtractGemsResponse> {
  constructor() {
    super("CMsgExtractGemsResponse", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgExtractGemsResponse.EExtractGems",
          CMsgExtractGemsResponse_EExtractGems,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgExtractGemsResponse>,
  ): CMsgExtractGemsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgExtractGemsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgExtractGemsResponse,
  ): CMsgExtractGemsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.itemId = reader.uint64().toBigInt();
          break;
        case /* optional CMsgExtractGemsResponse.EExtractGems response */ 2:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgExtractGemsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.itemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemId);
    /* optional CMsgExtractGemsResponse.EExtractGems response = 2; */
    if (message.response !== undefined)
      writer.tag(2, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgExtractGemsResponse
 */
export const CMsgExtractGemsResponse = new CMsgExtractGemsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddSocket$Type extends MessageType<CMsgAddSocket> {
  constructor() {
    super("CMsgAddSocket", [
      {
        no: 1,
        name: "tool_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "unusual",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddSocket>): CMsgAddSocket {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgAddSocket>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddSocket,
  ): CMsgAddSocket {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 tool_item_id */ 1:
          message.toolItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint64 item_item_id */ 2:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        case /* optional bool unusual */ 3:
          message.unusual = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddSocket,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 tool_item_id = 1; */
    if (message.toolItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.toolItemId);
    /* optional uint64 item_item_id = 2; */
    if (message.itemItemId !== undefined)
      writer.tag(2, WireType.Varint).uint64(message.itemItemId);
    /* optional bool unusual = 3; */
    if (message.unusual !== undefined)
      writer.tag(3, WireType.Varint).bool(message.unusual);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddSocket
 */
export const CMsgAddSocket = new CMsgAddSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddSocketResponse$Type extends MessageType<CMsgAddSocketResponse> {
  constructor() {
    super("CMsgAddSocketResponse", [
      {
        no: 1,
        name: "item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "updated_socket_index",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgAddSocketResponse.EAddSocket",
          CMsgAddSocketResponse_EAddSocket,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddSocketResponse>): CMsgAddSocketResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updatedSocketIndex = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAddSocketResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddSocketResponse,
  ): CMsgAddSocketResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_id */ 1:
          message.itemId = reader.uint64().toBigInt();
          break;
        case /* repeated uint32 updated_socket_index */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.updatedSocketIndex.push(reader.uint32());
          else message.updatedSocketIndex.push(reader.uint32());
          break;
        case /* optional CMsgAddSocketResponse.EAddSocket response */ 3:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddSocketResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_id = 1; */
    if (message.itemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemId);
    /* repeated uint32 updated_socket_index = 2; */
    for (let i = 0; i < message.updatedSocketIndex.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.updatedSocketIndex[i]);
    /* optional CMsgAddSocketResponse.EAddSocket response = 3; */
    if (message.response !== undefined)
      writer.tag(3, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddSocketResponse
 */
export const CMsgAddSocketResponse = new CMsgAddSocketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocketData$Type extends MessageType<CMsgAddItemToSocketData> {
  constructor() {
    super("CMsgAddItemToSocketData", [
      {
        no: 1,
        name: "gem_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "socket_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgAddItemToSocketData>,
  ): CMsgAddItemToSocketData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgAddItemToSocketData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocketData,
  ): CMsgAddItemToSocketData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 gem_item_id */ 1:
          message.gemItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 socket_index */ 2:
          message.socketIndex = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddItemToSocketData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 gem_item_id = 1; */
    if (message.gemItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.gemItemId);
    /* optional uint32 socket_index = 2; */
    if (message.socketIndex !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.socketIndex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocketData
 */
export const CMsgAddItemToSocketData = new CMsgAddItemToSocketData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocket$Type extends MessageType<CMsgAddItemToSocket> {
  constructor() {
    super("CMsgAddItemToSocket", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "gems_to_socket",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgAddItemToSocketData,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgAddItemToSocket>): CMsgAddItemToSocket {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.gemsToSocket = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAddItemToSocket>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocket,
  ): CMsgAddItemToSocket {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        case /* repeated CMsgAddItemToSocketData gems_to_socket */ 2:
          message.gemsToSocket.push(
            CMsgAddItemToSocketData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddItemToSocket,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.itemItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemItemId);
    /* repeated CMsgAddItemToSocketData gems_to_socket = 2; */
    for (let i = 0; i < message.gemsToSocket.length; i++)
      CMsgAddItemToSocketData.internalBinaryWrite(
        message.gemsToSocket[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocket
 */
export const CMsgAddItemToSocket = new CMsgAddItemToSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAddItemToSocketResponse$Type extends MessageType<CMsgAddItemToSocketResponse> {
  constructor() {
    super("CMsgAddItemToSocketResponse", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "updated_socket_index",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgAddItemToSocketResponse.EAddGem",
          CMsgAddItemToSocketResponse_EAddGem,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgAddItemToSocketResponse>,
  ): CMsgAddItemToSocketResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.updatedSocketIndex = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgAddItemToSocketResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgAddItemToSocketResponse,
  ): CMsgAddItemToSocketResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        case /* repeated uint32 updated_socket_index */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.updatedSocketIndex.push(reader.uint32());
          else message.updatedSocketIndex.push(reader.uint32());
          break;
        case /* optional CMsgAddItemToSocketResponse.EAddGem response */ 3:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgAddItemToSocketResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.itemItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemItemId);
    /* repeated uint32 updated_socket_index = 2; */
    for (let i = 0; i < message.updatedSocketIndex.length; i++)
      writer.tag(2, WireType.Varint).uint32(message.updatedSocketIndex[i]);
    /* optional CMsgAddItemToSocketResponse.EAddGem response = 3; */
    if (message.response !== undefined)
      writer.tag(3, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgAddItemToSocketResponse
 */
export const CMsgAddItemToSocketResponse =
  new CMsgAddItemToSocketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgResetStrangeGemCount$Type extends MessageType<CMsgResetStrangeGemCount> {
  constructor() {
    super("CMsgResetStrangeGemCount", [
      {
        no: 1,
        name: "item_item_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "socket_index",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgResetStrangeGemCount>,
  ): CMsgResetStrangeGemCount {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgResetStrangeGemCount>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgResetStrangeGemCount,
  ): CMsgResetStrangeGemCount {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 item_item_id */ 1:
          message.itemItemId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 socket_index */ 2:
          message.socketIndex = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgResetStrangeGemCount,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 item_item_id = 1; */
    if (message.itemItemId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.itemItemId);
    /* optional uint32 socket_index = 2; */
    if (message.socketIndex !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.socketIndex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgResetStrangeGemCount
 */
export const CMsgResetStrangeGemCount = new CMsgResetStrangeGemCount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgResetStrangeGemCountResponse$Type extends MessageType<CMsgResetStrangeGemCountResponse> {
  constructor() {
    super("CMsgResetStrangeGemCountResponse", [
      {
        no: 1,
        name: "response",
        kind: "enum",
        opt: true,
        T: () => [
          "CMsgResetStrangeGemCountResponse.EResetGem",
          CMsgResetStrangeGemCountResponse_EResetGem,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgResetStrangeGemCountResponse>,
  ): CMsgResetStrangeGemCountResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgResetStrangeGemCountResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgResetStrangeGemCountResponse,
  ): CMsgResetStrangeGemCountResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgResetStrangeGemCountResponse.EResetGem response */ 1:
          message.response = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgResetStrangeGemCountResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgResetStrangeGemCountResponse.EResetGem response = 1; */
    if (message.response !== undefined)
      writer.tag(1, WireType.Varint).int32(message.response);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgResetStrangeGemCountResponse
 */
export const CMsgResetStrangeGemCountResponse =
  new CMsgResetStrangeGemCountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollFileRequest$Type extends MessageType<CMsgGCToClientPollFileRequest> {
  constructor() {
    super("CMsgGCToClientPollFileRequest", [
      {
        no: 1,
        name: "file_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "client_version",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "poll_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToClientPollFileRequest>,
  ): CMsgGCToClientPollFileRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToClientPollFileRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollFileRequest,
  ): CMsgGCToClientPollFileRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string file_name */ 1:
          message.fileName = reader.string();
          break;
        case /* optional uint32 client_version */ 2:
          message.clientVersion = reader.uint32();
          break;
        case /* optional uint32 poll_id */ 3:
          message.pollId = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollFileRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string file_name = 1; */
    if (message.fileName !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.fileName);
    /* optional uint32 client_version = 2; */
    if (message.clientVersion !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.clientVersion);
    /* optional uint32 poll_id = 3; */
    if (message.pollId !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.pollId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollFileRequest
 */
export const CMsgGCToClientPollFileRequest =
  new CMsgGCToClientPollFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientPollFileResponse$Type extends MessageType<CMsgGCToClientPollFileResponse> {
  constructor() {
    super("CMsgGCToClientPollFileResponse", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "file_size",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "file_crc",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToClientPollFileResponse>,
  ): CMsgGCToClientPollFileResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToClientPollFileResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientPollFileResponse,
  ): CMsgGCToClientPollFileResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 poll_id */ 1:
          message.pollId = reader.uint32();
          break;
        case /* optional uint32 file_size */ 2:
          message.fileSize = reader.uint32();
          break;
        case /* optional uint32 file_crc */ 3:
          message.fileCrc = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientPollFileResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 poll_id = 1; */
    if (message.pollId !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.pollId);
    /* optional uint32 file_size = 2; */
    if (message.fileSize !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.fileSize);
    /* optional uint32 file_crc = 3; */
    if (message.fileCrc !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.fileCrc);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientPollFileResponse
 */
export const CMsgGCToClientPollFileResponse =
  new CMsgGCToClientPollFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCPerformManualOp$Type extends MessageType<CMsgGCToGCPerformManualOp> {
  constructor() {
    super("CMsgGCToGCPerformManualOp", [
      {
        no: 1,
        name: "op_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "group_code",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCPerformManualOp>,
  ): CMsgGCToGCPerformManualOp {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCPerformManualOp>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCPerformManualOp,
  ): CMsgGCToGCPerformManualOp {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 op_id */ 1:
          message.opId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 group_code */ 2:
          message.groupCode = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCPerformManualOp,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 op_id = 1; */
    if (message.opId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.opId);
    /* optional uint32 group_code = 2; */
    if (message.groupCode !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.groupCode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCPerformManualOp
 */
export const CMsgGCToGCPerformManualOp = new CMsgGCToGCPerformManualOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCPerformManualOpCompleted$Type extends MessageType<CMsgGCToGCPerformManualOpCompleted> {
  constructor() {
    super("CMsgGCToGCPerformManualOpCompleted", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 2,
        name: "source_gc",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToGCPerformManualOpCompleted>,
  ): CMsgGCToGCPerformManualOpCompleted {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCPerformManualOpCompleted>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCPerformManualOpCompleted,
  ): CMsgGCToGCPerformManualOpCompleted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional int32 source_gc */ 2:
          message.sourceGc = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToGCPerformManualOpCompleted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool success = 1; */
    if (message.success !== undefined)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional int32 source_gc = 2; */
    if (message.sourceGc !== undefined)
      writer.tag(2, WireType.Varint).int32(message.sourceGc);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCPerformManualOpCompleted
 */
export const CMsgGCToGCPerformManualOpCompleted =
  new CMsgGCToGCPerformManualOpCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToGCReloadServerRegionSettings$Type extends MessageType<CMsgGCToGCReloadServerRegionSettings> {
  constructor() {
    super("CMsgGCToGCReloadServerRegionSettings", []);
  }
  create(
    value?: PartialMessage<CMsgGCToGCReloadServerRegionSettings>,
  ): CMsgGCToGCReloadServerRegionSettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToGCReloadServerRegionSettings>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToGCReloadServerRegionSettings,
  ): CMsgGCToGCReloadServerRegionSettings {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgGCToGCReloadServerRegionSettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToGCReloadServerRegionSettings
 */
export const CMsgGCToGCReloadServerRegionSettings =
  new CMsgGCToGCReloadServerRegionSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCAdditionalWelcomeMsgList$Type extends MessageType<CMsgGCAdditionalWelcomeMsgList> {
  constructor() {
    super("CMsgGCAdditionalWelcomeMsgList", [
      {
        no: 1,
        name: "welcome_messages",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CExtraMsgBlock,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCAdditionalWelcomeMsgList>,
  ): CMsgGCAdditionalWelcomeMsgList {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.welcomeMessages = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgGCAdditionalWelcomeMsgList>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCAdditionalWelcomeMsgList,
  ): CMsgGCAdditionalWelcomeMsgList {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CExtraMsgBlock welcome_messages */ 1:
          message.welcomeMessages.push(
            CExtraMsgBlock.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCAdditionalWelcomeMsgList,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CExtraMsgBlock welcome_messages = 1; */
    for (let i = 0; i < message.welcomeMessages.length; i++)
      CExtraMsgBlock.internalBinaryWrite(
        message.welcomeMessages[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCAdditionalWelcomeMsgList
 */
export const CMsgGCAdditionalWelcomeMsgList =
  new CMsgGCAdditionalWelcomeMsgList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyRemoteConVars$Type extends MessageType<CMsgApplyRemoteConVars> {
  constructor() {
    super("CMsgApplyRemoteConVars", [
      {
        no: 1,
        name: "con_vars",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgApplyRemoteConVars_ConVar,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgApplyRemoteConVars>,
  ): CMsgApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.conVars = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgApplyRemoteConVars>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyRemoteConVars,
  ): CMsgApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgApplyRemoteConVars.ConVar con_vars */ 1:
          message.conVars.push(
            CMsgApplyRemoteConVars_ConVar.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgApplyRemoteConVars.ConVar con_vars = 1; */
    for (let i = 0; i < message.conVars.length; i++)
      CMsgApplyRemoteConVars_ConVar.internalBinaryWrite(
        message.conVars[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyRemoteConVars
 */
export const CMsgApplyRemoteConVars = new CMsgApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgApplyRemoteConVars_ConVar$Type extends MessageType<CMsgApplyRemoteConVars_ConVar> {
  constructor() {
    super("CMsgApplyRemoteConVars.ConVar", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "version_min",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "version_max",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "platform",
        kind: "enum",
        opt: true,
        T: () => ["EGCPlatform", EGCPlatform],
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgApplyRemoteConVars_ConVar>,
  ): CMsgApplyRemoteConVars_ConVar {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgApplyRemoteConVars_ConVar>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgApplyRemoteConVars_ConVar,
  ): CMsgApplyRemoteConVars_ConVar {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */ 1:
          message.name = reader.string();
          break;
        case /* optional string value */ 2:
          message.value = reader.string();
          break;
        case /* optional uint32 version_min */ 3:
          message.versionMin = reader.uint32();
          break;
        case /* optional uint32 version_max */ 4:
          message.versionMax = reader.uint32();
          break;
        case /* optional EGCPlatform platform */ 5:
          message.platform = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgApplyRemoteConVars_ConVar,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string name = 1; */
    if (message.name !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* optional string value = 2; */
    if (message.value !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    /* optional uint32 version_min = 3; */
    if (message.versionMin !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.versionMin);
    /* optional uint32 version_max = 4; */
    if (message.versionMax !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.versionMax);
    /* optional EGCPlatform platform = 5; */
    if (message.platform !== undefined)
      writer.tag(5, WireType.Varint).int32(message.platform);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgApplyRemoteConVars.ConVar
 */
export const CMsgApplyRemoteConVars_ConVar =
  new CMsgApplyRemoteConVars_ConVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientApplyRemoteConVars$Type extends MessageType<CMsgGCToClientApplyRemoteConVars> {
  constructor() {
    super("CMsgGCToClientApplyRemoteConVars", [
      { no: 1, name: "msg", kind: "message", T: () => CMsgApplyRemoteConVars },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToClientApplyRemoteConVars>,
  ): CMsgGCToClientApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToClientApplyRemoteConVars>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientApplyRemoteConVars,
  ): CMsgGCToClientApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgApplyRemoteConVars msg */ 1:
          message.msg = CMsgApplyRemoteConVars.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.msg,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgApplyRemoteConVars msg = 1; */
    if (message.msg)
      CMsgApplyRemoteConVars.internalBinaryWrite(
        message.msg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientApplyRemoteConVars
 */
export const CMsgGCToClientApplyRemoteConVars =
  new CMsgGCToClientApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToServerApplyRemoteConVars$Type extends MessageType<CMsgGCToServerApplyRemoteConVars> {
  constructor() {
    super("CMsgGCToServerApplyRemoteConVars", [
      { no: 1, name: "msg", kind: "message", T: () => CMsgApplyRemoteConVars },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToServerApplyRemoteConVars>,
  ): CMsgGCToServerApplyRemoteConVars {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToServerApplyRemoteConVars>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToServerApplyRemoteConVars,
  ): CMsgGCToServerApplyRemoteConVars {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgApplyRemoteConVars msg */ 1:
          message.msg = CMsgApplyRemoteConVars.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.msg,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToServerApplyRemoteConVars,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgApplyRemoteConVars msg = 1; */
    if (message.msg)
      CMsgApplyRemoteConVars.internalBinaryWrite(
        message.msg,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToServerApplyRemoteConVars
 */
export const CMsgGCToServerApplyRemoteConVars =
  new CMsgGCToServerApplyRemoteConVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCIntegrityStatus$Type extends MessageType<CMsgClientToGCIntegrityStatus> {
  constructor() {
    super("CMsgClientToGCIntegrityStatus", [
      {
        no: 1,
        name: "report",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "secure_allowed",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "diagnostics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgClientToGCIntegrityStatus_keyvalue,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgClientToGCIntegrityStatus>,
  ): CMsgClientToGCIntegrityStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.diagnostics = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgClientToGCIntegrityStatus>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCIntegrityStatus,
  ): CMsgClientToGCIntegrityStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string report */ 1:
          message.report = reader.string();
          break;
        case /* optional bool secure_allowed */ 2:
          message.secureAllowed = reader.bool();
          break;
        case /* repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics */ 3:
          message.diagnostics.push(
            CMsgClientToGCIntegrityStatus_keyvalue.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCIntegrityStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string report = 1; */
    if (message.report !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.report);
    /* optional bool secure_allowed = 2; */
    if (message.secureAllowed !== undefined)
      writer.tag(2, WireType.Varint).bool(message.secureAllowed);
    /* repeated CMsgClientToGCIntegrityStatus.keyvalue diagnostics = 3; */
    for (let i = 0; i < message.diagnostics.length; i++)
      CMsgClientToGCIntegrityStatus_keyvalue.internalBinaryWrite(
        message.diagnostics[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCIntegrityStatus
 */
export const CMsgClientToGCIntegrityStatus =
  new CMsgClientToGCIntegrityStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCIntegrityStatus_keyvalue$Type extends MessageType<CMsgClientToGCIntegrityStatus_keyvalue> {
  constructor() {
    super("CMsgClientToGCIntegrityStatus.keyvalue", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "extended",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: "string_value",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgClientToGCIntegrityStatus_keyvalue>,
  ): CMsgClientToGCIntegrityStatus_keyvalue {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgClientToGCIntegrityStatus_keyvalue>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCIntegrityStatus_keyvalue,
  ): CMsgClientToGCIntegrityStatus_keyvalue {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 id */ 1:
          message.id = reader.uint32();
          break;
        case /* optional uint32 extended */ 2:
          message.extended = reader.uint32();
          break;
        case /* optional uint64 value */ 3:
          message.value = reader.uint64().toBigInt();
          break;
        case /* optional string string_value */ 4:
          message.stringValue = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCIntegrityStatus_keyvalue,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 id = 1; */
    if (message.id !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.id);
    /* optional uint32 extended = 2; */
    if (message.extended !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.extended);
    /* optional uint64 value = 3; */
    if (message.value !== undefined)
      writer.tag(3, WireType.Varint).uint64(message.value);
    /* optional string string_value = 4; */
    if (message.stringValue !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.stringValue);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCIntegrityStatus.keyvalue
 */
export const CMsgClientToGCIntegrityStatus_keyvalue =
  new CMsgClientToGCIntegrityStatus_keyvalue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCAggregateMetrics$Type extends MessageType<CMsgClientToGCAggregateMetrics> {
  constructor() {
    super("CMsgClientToGCAggregateMetrics", [
      {
        no: 1,
        name: "metrics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgClientToGCAggregateMetrics_SingleMetric,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgClientToGCAggregateMetrics>,
  ): CMsgClientToGCAggregateMetrics {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.metrics = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgClientToGCAggregateMetrics>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCAggregateMetrics,
  ): CMsgClientToGCAggregateMetrics {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics */ 1:
          message.metrics.push(
            CMsgClientToGCAggregateMetrics_SingleMetric.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCAggregateMetrics,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated CMsgClientToGCAggregateMetrics.SingleMetric metrics = 1; */
    for (let i = 0; i < message.metrics.length; i++)
      CMsgClientToGCAggregateMetrics_SingleMetric.internalBinaryWrite(
        message.metrics[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCAggregateMetrics
 */
export const CMsgClientToGCAggregateMetrics =
  new CMsgClientToGCAggregateMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgClientToGCAggregateMetrics_SingleMetric$Type extends MessageType<CMsgClientToGCAggregateMetrics_SingleMetric> {
  constructor() {
    super("CMsgClientToGCAggregateMetrics.SingleMetric", [
      {
        no: 1,
        name: "metric_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "metric_count",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgClientToGCAggregateMetrics_SingleMetric>,
  ): CMsgClientToGCAggregateMetrics_SingleMetric {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgClientToGCAggregateMetrics_SingleMetric>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgClientToGCAggregateMetrics_SingleMetric,
  ): CMsgClientToGCAggregateMetrics_SingleMetric {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string metric_name */ 1:
          message.metricName = reader.string();
          break;
        case /* optional uint32 metric_count */ 2:
          message.metricCount = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgClientToGCAggregateMetrics_SingleMetric,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string metric_name = 1; */
    if (message.metricName !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.metricName);
    /* optional uint32 metric_count = 2; */
    if (message.metricCount !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.metricCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgClientToGCAggregateMetrics.SingleMetric
 */
export const CMsgClientToGCAggregateMetrics_SingleMetric =
  new CMsgClientToGCAggregateMetrics_SingleMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgGCToClientAggregateMetricsBackoff$Type extends MessageType<CMsgGCToClientAggregateMetricsBackoff> {
  constructor() {
    super("CMsgGCToClientAggregateMetricsBackoff", [
      {
        no: 1,
        name: "upload_rate_modifier",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgGCToClientAggregateMetricsBackoff>,
  ): CMsgGCToClientAggregateMetricsBackoff {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgGCToClientAggregateMetricsBackoff>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgGCToClientAggregateMetricsBackoff,
  ): CMsgGCToClientAggregateMetricsBackoff {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float upload_rate_modifier */ 1:
          message.uploadRateModifier = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgGCToClientAggregateMetricsBackoff,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float upload_rate_modifier = 1; */
    if (message.uploadRateModifier !== undefined)
      writer.tag(1, WireType.Bit32).float(message.uploadRateModifier);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgGCToClientAggregateMetricsBackoff
 */
export const CMsgGCToClientAggregateMetricsBackoff =
  new CMsgGCToClientAggregateMetricsBackoff$Type();

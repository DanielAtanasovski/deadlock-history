// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steammessages_steamlearn.steamworkssdk.proto" (syntax proto2)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgSteamLearnDataSourceDescObject
 */
export interface CMsgSteamLearnDataSourceDescObject {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnDataSourceDescElement elements = 1;
     */
    elements: CMsgSteamLearnDataSourceDescElement[];
}
/**
 * @generated from protobuf message CMsgSteamLearnDataSourceDescElement
 */
export interface CMsgSteamLearnDataSourceDescElement {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional ESteamLearnDataType data_type = 2;
     */
    dataType?: ESteamLearnDataType;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataSourceDescObject object = 3;
     */
    object?: CMsgSteamLearnDataSourceDescObject;
    /**
     * @generated from protobuf field: optional uint32 count = 4;
     */
    count?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearnDataSource
 */
export interface CMsgSteamLearnDataSource {
    /**
     * @generated from protobuf field: optional uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 version = 3;
     */
    version?: number;
    /**
     * @generated from protobuf field: optional string source_description = 4;
     */
    sourceDescription?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataSourceDescObject structure = 5;
     */
    structure?: CMsgSteamLearnDataSourceDescObject;
    /**
     * @generated from protobuf field: optional uint32 structure_crc = 6;
     */
    structureCrc?: number;
    /**
     * @generated from protobuf field: optional uint32 cache_duration_seconds = 7;
     */
    cacheDurationSeconds?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearnDataObject
 */
export interface CMsgSteamLearnDataObject {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnDataElement elements = 1;
     */
    elements: CMsgSteamLearnDataElement[];
}
/**
 * @generated from protobuf message CMsgSteamLearnDataElement
 */
export interface CMsgSteamLearnDataElement {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated int32 data_int32s = 20 [json_name = "dataInt32s"];
     */
    dataInt32S: number[];
    /**
     * @generated from protobuf field: repeated float data_floats = 21;
     */
    dataFloats: number[];
    /**
     * @generated from protobuf field: repeated bool data_bools = 22;
     */
    dataBools: boolean[];
    /**
     * @generated from protobuf field: repeated string data_strings = 23;
     */
    dataStrings: string[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnDataObject data_objects = 24;
     */
    dataObjects: CMsgSteamLearnDataObject[];
}
/**
 * @generated from protobuf message CMsgSteamLearnData
 */
export interface CMsgSteamLearnData {
    /**
     * @generated from protobuf field: optional uint32 data_source_id = 1;
     */
    dataSourceId?: number;
    /**
     * @generated from protobuf field: repeated uint64 keys = 2;
     */
    keys: bigint[];
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataObject data_object = 3;
     */
    dataObject?: CMsgSteamLearnDataObject;
}
/**
 * @generated from protobuf message CMsgSteamLearnDataList
 */
export interface CMsgSteamLearnDataList {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnData data = 1;
     */
    data: CMsgSteamLearnData[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_RegisterDataSource_Request
 */
export interface CMsgSteamLearn_RegisterDataSource_Request {
    /**
     * @generated from protobuf field: optional string access_token = 1;
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataSource data_source = 3;
     */
    dataSource?: CMsgSteamLearnDataSource;
}
/**
 * @generated from protobuf message CMsgSteamLearn_RegisterDataSource_Response
 */
export interface CMsgSteamLearn_RegisterDataSource_Response {
    /**
     * @generated from protobuf field: optional ESteammLearnRegisterDataSourceResult result = 1;
     */
    result?: ESteammLearnRegisterDataSourceResult;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataSource data_source = 2;
     */
    dataSource?: CMsgSteamLearnDataSource;
}
/**
 * @generated from protobuf message CMsgSteamLearn_CacheData_Request
 */
export interface CMsgSteamLearn_CacheData_Request {
    /**
     * @generated from protobuf field: optional string access_token = 1;
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnData data = 3;
     */
    data?: CMsgSteamLearnData;
}
/**
 * @generated from protobuf message CMsgSteamLearn_CacheData_Response
 */
export interface CMsgSteamLearn_CacheData_Response {
    /**
     * @generated from protobuf field: optional ESteamLearnCacheDataResult cache_data_result = 1;
     */
    cacheDataResult?: ESteamLearnCacheDataResult;
}
/**
 * @generated from protobuf message CMsgSteamLearn_SnapshotProject_Request
 */
export interface CMsgSteamLearn_SnapshotProject_Request {
    /**
     * @generated from protobuf field: optional string access_token = 1;
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional uint32 project_id = 3;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional uint32 published_version = 7;
     */
    publishedVersion?: number;
    /**
     * @generated from protobuf field: repeated uint64 keys = 4;
     */
    keys: bigint[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnData data = 5;
     */
    data: CMsgSteamLearnData[];
    /**
     * @generated from protobuf field: optional uint32 pending_data_limit_seconds = 6;
     */
    pendingDataLimitSeconds?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_SnapshotProject_Response
 */
export interface CMsgSteamLearn_SnapshotProject_Response {
    /**
     * @generated from protobuf field: optional ESteamLearnSnapshotProjectResult snapshot_result = 1;
     */
    snapshotResult?: ESteamLearnSnapshotProjectResult;
}
/**
 * @generated from protobuf message CMsgSteamLearn_BatchOperation_Request
 */
export interface CMsgSteamLearn_BatchOperation_Request {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_CacheData_Request cache_data_requests = 1;
     */
    cacheDataRequests: CMsgSteamLearn_CacheData_Request[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_SnapshotProject_Request snapshot_requests = 2;
     */
    snapshotRequests: CMsgSteamLearn_SnapshotProject_Request[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_Inference_Request inference_requests = 3;
     */
    inferenceRequests: CMsgSteamLearn_Inference_Request[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_BatchOperation_Response
 */
export interface CMsgSteamLearn_BatchOperation_Response {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_CacheData_Response cache_data_responses = 1;
     */
    cacheDataResponses: CMsgSteamLearn_CacheData_Response[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_SnapshotProject_Response snapshot_responses = 2;
     */
    snapshotResponses: CMsgSteamLearn_SnapshotProject_Response[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_Inference_Response inference_responses = 3;
     */
    inferenceResponses: CMsgSteamLearn_Inference_Response[];
}
/**
 * @generated from protobuf message CMsgSteamLearnAccessTokens
 */
export interface CMsgSteamLearnAccessTokens {
    /**
     * @generated from protobuf field: optional string register_data_source_access_token = 1;
     */
    registerDataSourceAccessToken?: string;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnAccessTokens.CacheDataAccessToken cache_data_access_tokens = 2;
     */
    cacheDataAccessTokens: CMsgSteamLearnAccessTokens_CacheDataAccessToken[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken snapshot_project_access_tokens = 3;
     */
    snapshotProjectAccessTokens: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearnAccessTokens.InferenceAccessToken inference_access_tokens = 4;
     */
    inferenceAccessTokens: CMsgSteamLearnAccessTokens_InferenceAccessToken[];
}
/**
 * @generated from protobuf message CMsgSteamLearnAccessTokens.CacheDataAccessToken
 */
export interface CMsgSteamLearnAccessTokens_CacheDataAccessToken {
    /**
     * @generated from protobuf field: optional uint32 data_source_id = 1;
     */
    dataSourceId?: number;
    /**
     * @generated from protobuf field: optional string access_token = 2;
     */
    accessToken?: string;
}
/**
 * @generated from protobuf message CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken
 */
export interface CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
    /**
     * @generated from protobuf field: optional uint32 project_id = 1;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional string access_token = 2;
     */
    accessToken?: string;
}
/**
 * @generated from protobuf message CMsgSteamLearnAccessTokens.InferenceAccessToken
 */
export interface CMsgSteamLearnAccessTokens_InferenceAccessToken {
    /**
     * @generated from protobuf field: optional uint32 project_id = 1;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional string access_token = 2;
     */
    accessToken?: string;
}
/**
 * @generated from protobuf message CMsgSteamLearn_GetAccessTokens_Request
 */
export interface CMsgSteamLearn_GetAccessTokens_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_GetAccessTokens_Response
 */
export interface CMsgSteamLearn_GetAccessTokens_Response {
    /**
     * @generated from protobuf field: optional ESteamLearnGetAccessTokensResult result = 1;
     */
    result?: ESteamLearnGetAccessTokensResult;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnAccessTokens access_tokens = 2;
     */
    accessTokens?: CMsgSteamLearnAccessTokens;
}
/**
 * @generated from protobuf message CMsgSteamLearn_Inference_Request
 */
export interface CMsgSteamLearn_Inference_Request {
    /**
     * @generated from protobuf field: optional string access_token = 1;
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional uint32 project_id = 3;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional uint32 published_version = 4;
     */
    publishedVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 override_train_id = 5;
     */
    overrideTrainId?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamLearnDataList data = 6;
     */
    data?: CMsgSteamLearnDataList;
    /**
     * @generated from protobuf field: repeated float additional_data = 7;
     */
    additionalData: number[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Request
 */
export interface CMsgSteamLearn_InferenceMetadata_Request {
    /**
     * @generated from protobuf field: optional string access_token = 1;
     */
    accessToken?: string;
    /**
     * @generated from protobuf field: optional uint32 project_id = 3;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional uint32 published_version = 4;
     */
    publishedVersion?: number;
    /**
     * @generated from protobuf field: optional uint32 override_train_id = 5;
     */
    overrideTrainId?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadataBackend_Request
 */
export interface CMsgSteamLearn_InferenceMetadataBackend_Request {
    /**
     * @generated from protobuf field: optional uint32 project_id = 1;
     */
    projectId?: number;
    /**
     * @generated from protobuf field: optional uint32 fetch_id = 2;
     */
    fetchId?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response
 */
export interface CMsgSteamLearn_InferenceMetadata_Response {
    /**
     * @generated from protobuf field: optional ESteamLearnInferenceMetadataResult inference_metadata_result = 1;
     */
    inferenceMetadataResult?: ESteamLearnInferenceMetadataResult;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.RowRange row_range = 2;
     */
    rowRange?: CMsgSteamLearn_InferenceMetadata_Response_RowRange;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.Range ranges = 3;
     */
    ranges: CMsgSteamLearn_InferenceMetadata_Response_Range[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.StdDev std_devs = 4;
     */
    stdDevs: CMsgSteamLearn_InferenceMetadata_Response_StdDev[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable compact_tables = 5;
     */
    compactTables: CMsgSteamLearn_InferenceMetadata_Response_CompactTable[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable sequence_tables = 9;
     */
    sequenceTables: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans kmeans = 6;
     */
    kmeans: CMsgSteamLearn_InferenceMetadata_Response_KMeans[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry app_info = 8;
     */
    appInfo: CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry[];
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram snapshot_histogram = 7;
     */
    snapshotHistogram?: CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.RowRange
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_RowRange {
    /**
     * @generated from protobuf field: optional uint64 min_row = 1;
     */
    minRow?: bigint;
    /**
     * @generated from protobuf field: optional uint64 max_row = 2;
     */
    maxRow?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.Range
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_Range {
    /**
     * @generated from protobuf field: optional string data_element_path = 1;
     */
    dataElementPath?: string;
    /**
     * @generated from protobuf field: optional float min_value = 2;
     */
    minValue?: number;
    /**
     * @generated from protobuf field: optional float max_value = 3;
     */
    maxValue?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.StdDev
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_StdDev {
    /**
     * @generated from protobuf field: optional string data_element_path = 1;
     */
    dataElementPath?: string;
    /**
     * @generated from protobuf field: optional float mean = 2;
     */
    mean?: number;
    /**
     * @generated from protobuf field: optional float std_dev = 3;
     */
    stdDev?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_CompactTable {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry map_values = 2;
     */
    mapValues: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry map_mappings = 3;
     */
    mapMappings: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry {
    /**
     * @generated from protobuf field: optional uint32 value = 1;
     */
    value?: number;
    /**
     * @generated from protobuf field: optional uint32 mapping = 2;
     */
    mapping?: number;
    /**
     * @generated from protobuf field: optional uint64 count = 3;
     */
    count?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry {
    /**
     * @generated from protobuf field: optional uint32 key = 1;
     */
    key?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value = 2;
     */
    value?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry {
    /**
     * @generated from protobuf field: optional uint32 key = 1;
     */
    key?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value = 2;
     */
    value?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_SequenceTable {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry map_values = 2;
     */
    mapValues: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry map_mappings = 3;
     */
    mapMappings: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry[];
    /**
     * @generated from protobuf field: optional uint64 total_count = 4;
     */
    totalCount?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry {
    /**
     * @generated from protobuf field: repeated uint32 values = 1;
     */
    values: number[];
    /**
     * @generated from protobuf field: optional uint32 crc = 2;
     */
    crc?: number;
    /**
     * @generated from protobuf field: optional uint32 count = 3;
     */
    count?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry {
    /**
     * @generated from protobuf field: optional uint32 key = 1;
     */
    key?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value = 2;
     */
    value?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry {
    /**
     * @generated from protobuf field: optional string key = 1;
     */
    key?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value = 2;
     */
    value?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.KMeans
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_KMeans {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster clusters = 2;
     */
    clusters: CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float radius = 3;
     */
    radius?: number;
    /**
     * @generated from protobuf field: optional float radius_75pct = 4 [json_name = "radius75pct"];
     */
    radius75Pct?: number;
    /**
     * @generated from protobuf field: optional float radius_50pct = 5 [json_name = "radius50pct"];
     */
    radius50Pct?: number;
    /**
     * @generated from protobuf field: optional float radius_25pct = 6 [json_name = "radius25pct"];
     */
    radius25Pct?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram {
    /**
     * @generated from protobuf field: optional float min_value = 1;
     */
    minValue?: number;
    /**
     * @generated from protobuf field: optional float max_value = 2;
     */
    maxValue?: number;
    /**
     * @generated from protobuf field: optional uint32 num_buckets = 3;
     */
    numBuckets?: number;
    /**
     * @generated from protobuf field: repeated uint32 bucket_counts = 4;
     */
    bucketCounts: number[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.AppInfo
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_AppInfo {
    /**
     * @generated from protobuf field: optional string country_allow = 1;
     */
    countryAllow?: string;
    /**
     * @generated from protobuf field: optional string country_deny = 2;
     */
    countryDeny?: string;
    /**
     * @generated from protobuf field: optional bool platform_win = 3;
     */
    platformWin?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_mac = 4;
     */
    platformMac?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_linux = 5;
     */
    platformLinux?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_violence = 6;
     */
    adultViolence?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_sex = 7;
     */
    adultSex?: boolean;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry
 */
export interface CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry {
    /**
     * @generated from protobuf field: optional uint32 key = 1;
     */
    key?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceMetadata_Response.AppInfo value = 2;
     */
    value?: CMsgSteamLearn_InferenceMetadata_Response_AppInfo;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response
 */
export interface CMsgSteamLearn_InferenceBackend_Response {
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceBackend_Response.Output outputs = 1;
     */
    outputs: CMsgSteamLearn_InferenceBackend_Response_Output[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.Sequence
 */
export interface CMsgSteamLearn_InferenceBackend_Response_Sequence {
    /**
     * @generated from protobuf field: repeated float value = 1;
     */
    value: number[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.RegressionOutput
 */
export interface CMsgSteamLearn_InferenceBackend_Response_RegressionOutput {
    /**
     * @generated from protobuf field: optional float value = 1;
     */
    value?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput
 */
export interface CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput {
    /**
     * @generated from protobuf field: optional float value = 1;
     */
    value?: number;
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput
 */
export interface CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput {
    /**
     * @generated from protobuf field: repeated float weight = 1;
     */
    weight: number[];
    /**
     * @generated from protobuf field: repeated float value = 2;
     */
    value: number[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence = 3;
     */
    valueSequence: CMsgSteamLearn_InferenceBackend_Response_Sequence[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput
 */
export interface CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput {
    /**
     * @generated from protobuf field: repeated float weight = 1;
     */
    weight: number[];
    /**
     * @generated from protobuf field: repeated float value = 2;
     */
    value: number[];
    /**
     * @generated from protobuf field: repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence = 3;
     */
    valueSequence: CMsgSteamLearn_InferenceBackend_Response_Sequence[];
}
/**
 * @generated from protobuf message CMsgSteamLearn_InferenceBackend_Response.Output
 */
export interface CMsgSteamLearn_InferenceBackend_Response_Output {
    /**
     * @generated from protobuf oneof: ResponseType
     */
    responseType: {
        oneofKind: "binaryCrossentropy";
        /**
         * @generated from protobuf field: CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput binary_crossentropy = 1;
         */
        binaryCrossentropy: CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput;
    } | {
        oneofKind: "categoricalCrossentropy";
        /**
         * @generated from protobuf field: CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput categorical_crossentropy = 2;
         */
        categoricalCrossentropy: CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput;
    } | {
        oneofKind: "multiBinaryCrossentropy";
        /**
         * @generated from protobuf field: CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput multi_binary_crossentropy = 3;
         */
        multiBinaryCrossentropy: CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput;
    } | {
        oneofKind: "regression";
        /**
         * @generated from protobuf field: CMsgSteamLearn_InferenceBackend_Response.RegressionOutput regression = 4;
         */
        regression: CMsgSteamLearn_InferenceBackend_Response_RegressionOutput;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message CMsgSteamLearn_Inference_Response
 */
export interface CMsgSteamLearn_Inference_Response {
    /**
     * @generated from protobuf field: optional ESteamLearnInferenceResult inference_result = 1;
     */
    inferenceResult?: ESteamLearnInferenceResult;
    /**
     * @generated from protobuf field: optional CMsgSteamLearn_InferenceBackend_Response backend_response = 2;
     */
    backendResponse?: CMsgSteamLearn_InferenceBackend_Response;
    /**
     * @generated from protobuf field: repeated uint64 keys = 3;
     */
    keys: bigint[];
}
/**
 * @generated from protobuf enum ESteamLearnDataType
 */
export enum ESteamLearnDataType {
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_INVALID = 0;
     */
    STEAMLEARN_DATATYPE_INVALID = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_INT32 = 1;
     */
    STEAMLEARN_DATATYPE_INT32 = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_FLOAT32 = 2;
     */
    STEAMLEARN_DATATYPE_FLOAT32 = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_BOOL = 3;
     */
    STEAMLEARN_DATATYPE_BOOL = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_STRING = 4;
     */
    STEAMLEARN_DATATYPE_STRING = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_DATATYPE_OBJECT = 5;
     */
    STEAMLEARN_DATATYPE_OBJECT = 5
}
/**
 * @generated from protobuf enum ESteammLearnRegisterDataSourceResult
 */
export enum ESteammLearnRegisterDataSourceResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR = 0;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED = 1;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND = 2;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC = 3;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME = 4;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION = 5;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION = 5,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED = 6;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED = 6,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID = 7;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID = 7,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN = 8;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN = 8,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP = 9;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP = 9,
    /**
     * @generated from protobuf enum value: STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED = 10;
     */
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED = 10
}
/**
 * @generated from protobuf enum ESteamLearnCacheDataResult
 */
export enum ESteamLearnCacheDataResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR = 0;
     */
    STEAMLEARN_CACHE_DATA_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_SUCCESS = 1;
     */
    STEAMLEARN_CACHE_DATA_SUCCESS = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE = 2;
     */
    STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE = 3;
     */
    STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS = 4;
     */
    STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN = 5;
     */
    STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN = 5,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP = 6;
     */
    STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP = 6,
    /**
     * @generated from protobuf enum value: STEAMLEARN_CACHE_DATA_DISABLED = 7;
     */
    STEAMLEARN_CACHE_DATA_DISABLED = 7
}
/**
 * @generated from protobuf enum ESteamLearnSnapshotProjectResult
 */
export enum ESteamLearnSnapshotProjectResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR = 0;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED = 1;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED = 2;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID = 3;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE = 4;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY = 5;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY = 5,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION = 6;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION = 6,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG = 7;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG = 7,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN = 8;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN = 8,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP = 9;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP = 9,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR = 10;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR = 10,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_DISABLED = 11;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_DISABLED = 11,
    /**
     * @generated from protobuf enum value: STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION = 12;
     */
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION = 12
}
/**
 * @generated from protobuf enum ESteamLearnGetAccessTokensResult
 */
export enum ESteamLearnGetAccessTokensResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_GET_ACCESS_TOKENS_ERROR = 0;
     */
    STEAMLEARN_GET_ACCESS_TOKENS_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS = 1;
     */
    STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS = 1
}
/**
 * @generated from protobuf enum ESteamLearnInferenceResult
 */
export enum ESteamLearnInferenceResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR = 0;
     */
    STEAMLEARN_INFERENCE_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_SUCCESS = 1;
     */
    STEAMLEARN_INFERENCE_SUCCESS = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID = 2;
     */
    STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA = 3;
     */
    STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG = 4;
     */
    STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_FORBIDDEN = 5;
     */
    STEAMLEARN_INFERENCE_ERROR_FORBIDDEN = 5,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP = 6;
     */
    STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP = 6,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION = 7;
     */
    STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION = 7,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND = 8;
     */
    STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND = 8,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_ERROR_TOO_BUSY = 9;
     */
    STEAMLEARN_INFERENCE_ERROR_TOO_BUSY = 9
}
/**
 * @generated from protobuf enum ESteamLearnInferenceMetadataResult
 */
export enum ESteamLearnInferenceMetadataResult {
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR = 0;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR = 0,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_SUCCESS = 1;
     */
    STEAMLEARN_INFERENCE_METADATA_SUCCESS = 1,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID = 2;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID = 2,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG = 3;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG = 3,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN = 4;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN = 4,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP = 5;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP = 5,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION = 6;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION = 6,
    /**
     * @generated from protobuf enum value: STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND = 7;
     */
    STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataSourceDescObject$Type extends MessageType<CMsgSteamLearnDataSourceDescObject> {
    constructor() {
        super("CMsgSteamLearnDataSourceDescObject", [
            { no: 1, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnDataSourceDescElement }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataSourceDescObject>): CMsgSteamLearnDataSourceDescObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.elements = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataSourceDescObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataSourceDescObject): CMsgSteamLearnDataSourceDescObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearnDataSourceDescElement elements */ 1:
                    message.elements.push(CMsgSteamLearnDataSourceDescElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataSourceDescObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearnDataSourceDescElement elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            CMsgSteamLearnDataSourceDescElement.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataSourceDescObject
 */
export const CMsgSteamLearnDataSourceDescObject = new CMsgSteamLearnDataSourceDescObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataSourceDescElement$Type extends MessageType<CMsgSteamLearnDataSourceDescElement> {
    constructor() {
        super("CMsgSteamLearnDataSourceDescElement", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_type", kind: "enum", opt: true, T: () => ["ESteamLearnDataType", ESteamLearnDataType] },
            { no: 3, name: "object", kind: "message", T: () => CMsgSteamLearnDataSourceDescObject },
            { no: 4, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataSourceDescElement>): CMsgSteamLearnDataSourceDescElement {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataSourceDescElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataSourceDescElement): CMsgSteamLearnDataSourceDescElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional ESteamLearnDataType data_type */ 2:
                    message.dataType = reader.int32();
                    break;
                case /* optional CMsgSteamLearnDataSourceDescObject object */ 3:
                    message.object = CMsgSteamLearnDataSourceDescObject.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* optional uint32 count */ 4:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataSourceDescElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional ESteamLearnDataType data_type = 2; */
        if (message.dataType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.dataType);
        /* optional CMsgSteamLearnDataSourceDescObject object = 3; */
        if (message.object)
            CMsgSteamLearnDataSourceDescObject.internalBinaryWrite(message.object, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 count = 4; */
        if (message.count !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataSourceDescElement
 */
export const CMsgSteamLearnDataSourceDescElement = new CMsgSteamLearnDataSourceDescElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataSource$Type extends MessageType<CMsgSteamLearnDataSource> {
    constructor() {
        super("CMsgSteamLearnDataSource", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "source_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "structure", kind: "message", T: () => CMsgSteamLearnDataSourceDescObject },
            { no: 6, name: "structure_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "cache_duration_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataSource>): CMsgSteamLearnDataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataSource): CMsgSteamLearnDataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint32 version */ 3:
                    message.version = reader.uint32();
                    break;
                case /* optional string source_description */ 4:
                    message.sourceDescription = reader.string();
                    break;
                case /* optional CMsgSteamLearnDataSourceDescObject structure */ 5:
                    message.structure = CMsgSteamLearnDataSourceDescObject.internalBinaryRead(reader, reader.uint32(), options, message.structure);
                    break;
                case /* optional uint32 structure_crc */ 6:
                    message.structureCrc = reader.uint32();
                    break;
                case /* optional uint32 cache_duration_seconds */ 7:
                    message.cacheDurationSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional uint32 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.version);
        /* optional string source_description = 4; */
        if (message.sourceDescription !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.sourceDescription);
        /* optional CMsgSteamLearnDataSourceDescObject structure = 5; */
        if (message.structure)
            CMsgSteamLearnDataSourceDescObject.internalBinaryWrite(message.structure, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 structure_crc = 6; */
        if (message.structureCrc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.structureCrc);
        /* optional uint32 cache_duration_seconds = 7; */
        if (message.cacheDurationSeconds !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.cacheDurationSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataSource
 */
export const CMsgSteamLearnDataSource = new CMsgSteamLearnDataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataObject$Type extends MessageType<CMsgSteamLearnDataObject> {
    constructor() {
        super("CMsgSteamLearnDataObject", [
            { no: 1, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnDataElement }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataObject>): CMsgSteamLearnDataObject {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.elements = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataObject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataObject): CMsgSteamLearnDataObject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearnDataElement elements */ 1:
                    message.elements.push(CMsgSteamLearnDataElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataObject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearnDataElement elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            CMsgSteamLearnDataElement.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataObject
 */
export const CMsgSteamLearnDataObject = new CMsgSteamLearnDataObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataElement$Type extends MessageType<CMsgSteamLearnDataElement> {
    constructor() {
        super("CMsgSteamLearnDataElement", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "data_int32s", kind: "scalar", jsonName: "dataInt32s", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "data_floats", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "data_bools", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "data_strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "data_objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnDataObject }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataElement>): CMsgSteamLearnDataElement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dataInt32S = [];
        message.dataFloats = [];
        message.dataBools = [];
        message.dataStrings = [];
        message.dataObjects = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataElement): CMsgSteamLearnDataElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated int32 data_int32s = 20 [json_name = "dataInt32s"];*/ 20:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataInt32S.push(reader.int32());
                    else
                        message.dataInt32S.push(reader.int32());
                    break;
                case /* repeated float data_floats */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataFloats.push(reader.float());
                    else
                        message.dataFloats.push(reader.float());
                    break;
                case /* repeated bool data_bools */ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataBools.push(reader.bool());
                    else
                        message.dataBools.push(reader.bool());
                    break;
                case /* repeated string data_strings */ 23:
                    message.dataStrings.push(reader.string());
                    break;
                case /* repeated CMsgSteamLearnDataObject data_objects */ 24:
                    message.dataObjects.push(CMsgSteamLearnDataObject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated int32 data_int32s = 20 [json_name = "dataInt32s"]; */
        for (let i = 0; i < message.dataInt32S.length; i++)
            writer.tag(20, WireType.Varint).int32(message.dataInt32S[i]);
        /* repeated float data_floats = 21; */
        for (let i = 0; i < message.dataFloats.length; i++)
            writer.tag(21, WireType.Bit32).float(message.dataFloats[i]);
        /* repeated bool data_bools = 22; */
        for (let i = 0; i < message.dataBools.length; i++)
            writer.tag(22, WireType.Varint).bool(message.dataBools[i]);
        /* repeated string data_strings = 23; */
        for (let i = 0; i < message.dataStrings.length; i++)
            writer.tag(23, WireType.LengthDelimited).string(message.dataStrings[i]);
        /* repeated CMsgSteamLearnDataObject data_objects = 24; */
        for (let i = 0; i < message.dataObjects.length; i++)
            CMsgSteamLearnDataObject.internalBinaryWrite(message.dataObjects[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataElement
 */
export const CMsgSteamLearnDataElement = new CMsgSteamLearnDataElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnData$Type extends MessageType<CMsgSteamLearnData> {
    constructor() {
        super("CMsgSteamLearnData", [
            { no: 1, name: "data_source_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "data_object", kind: "message", T: () => CMsgSteamLearnDataObject }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnData>): CMsgSteamLearnData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnData): CMsgSteamLearnData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 data_source_id */ 1:
                    message.dataSourceId = reader.uint32();
                    break;
                case /* repeated uint64 keys */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.keys.push(reader.uint64().toBigInt());
                    else
                        message.keys.push(reader.uint64().toBigInt());
                    break;
                case /* optional CMsgSteamLearnDataObject data_object */ 3:
                    message.dataObject = CMsgSteamLearnDataObject.internalBinaryRead(reader, reader.uint32(), options, message.dataObject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 data_source_id = 1; */
        if (message.dataSourceId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dataSourceId);
        /* repeated uint64 keys = 2; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(2, WireType.Varint).uint64(message.keys[i]);
        /* optional CMsgSteamLearnDataObject data_object = 3; */
        if (message.dataObject)
            CMsgSteamLearnDataObject.internalBinaryWrite(message.dataObject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnData
 */
export const CMsgSteamLearnData = new CMsgSteamLearnData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnDataList$Type extends MessageType<CMsgSteamLearnDataList> {
    constructor() {
        super("CMsgSteamLearnDataList", [
            { no: 1, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnData }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnDataList>): CMsgSteamLearnDataList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnDataList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnDataList): CMsgSteamLearnDataList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearnData data */ 1:
                    message.data.push(CMsgSteamLearnData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnDataList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearnData data = 1; */
        for (let i = 0; i < message.data.length; i++)
            CMsgSteamLearnData.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnDataList
 */
export const CMsgSteamLearnDataList = new CMsgSteamLearnDataList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_RegisterDataSource_Request$Type extends MessageType<CMsgSteamLearn_RegisterDataSource_Request> {
    constructor() {
        super("CMsgSteamLearn_RegisterDataSource_Request", [
            { no: 1, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data_source", kind: "message", T: () => CMsgSteamLearnDataSource }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_RegisterDataSource_Request>): CMsgSteamLearn_RegisterDataSource_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_RegisterDataSource_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_RegisterDataSource_Request): CMsgSteamLearn_RegisterDataSource_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* optional CMsgSteamLearnDataSource data_source */ 3:
                    message.dataSource = CMsgSteamLearnDataSource.internalBinaryRead(reader, reader.uint32(), options, message.dataSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_RegisterDataSource_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string access_token = 1; */
        if (message.accessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* optional CMsgSteamLearnDataSource data_source = 3; */
        if (message.dataSource)
            CMsgSteamLearnDataSource.internalBinaryWrite(message.dataSource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_RegisterDataSource_Request
 */
export const CMsgSteamLearn_RegisterDataSource_Request = new CMsgSteamLearn_RegisterDataSource_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_RegisterDataSource_Response$Type extends MessageType<CMsgSteamLearn_RegisterDataSource_Response> {
    constructor() {
        super("CMsgSteamLearn_RegisterDataSource_Response", [
            { no: 1, name: "result", kind: "enum", opt: true, T: () => ["ESteammLearnRegisterDataSourceResult", ESteammLearnRegisterDataSourceResult] },
            { no: 2, name: "data_source", kind: "message", T: () => CMsgSteamLearnDataSource }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_RegisterDataSource_Response>): CMsgSteamLearn_RegisterDataSource_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_RegisterDataSource_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_RegisterDataSource_Response): CMsgSteamLearn_RegisterDataSource_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteammLearnRegisterDataSourceResult result */ 1:
                    message.result = reader.int32();
                    break;
                case /* optional CMsgSteamLearnDataSource data_source */ 2:
                    message.dataSource = CMsgSteamLearnDataSource.internalBinaryRead(reader, reader.uint32(), options, message.dataSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_RegisterDataSource_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteammLearnRegisterDataSourceResult result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* optional CMsgSteamLearnDataSource data_source = 2; */
        if (message.dataSource)
            CMsgSteamLearnDataSource.internalBinaryWrite(message.dataSource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_RegisterDataSource_Response
 */
export const CMsgSteamLearn_RegisterDataSource_Response = new CMsgSteamLearn_RegisterDataSource_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_CacheData_Request$Type extends MessageType<CMsgSteamLearn_CacheData_Request> {
    constructor() {
        super("CMsgSteamLearn_CacheData_Request", [
            { no: 1, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => CMsgSteamLearnData }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_CacheData_Request>): CMsgSteamLearn_CacheData_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_CacheData_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_CacheData_Request): CMsgSteamLearn_CacheData_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* optional CMsgSteamLearnData data */ 3:
                    message.data = CMsgSteamLearnData.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_CacheData_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string access_token = 1; */
        if (message.accessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* optional CMsgSteamLearnData data = 3; */
        if (message.data)
            CMsgSteamLearnData.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_CacheData_Request
 */
export const CMsgSteamLearn_CacheData_Request = new CMsgSteamLearn_CacheData_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_CacheData_Response$Type extends MessageType<CMsgSteamLearn_CacheData_Response> {
    constructor() {
        super("CMsgSteamLearn_CacheData_Response", [
            { no: 1, name: "cache_data_result", kind: "enum", opt: true, T: () => ["ESteamLearnCacheDataResult", ESteamLearnCacheDataResult] }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_CacheData_Response>): CMsgSteamLearn_CacheData_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_CacheData_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_CacheData_Response): CMsgSteamLearn_CacheData_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteamLearnCacheDataResult cache_data_result */ 1:
                    message.cacheDataResult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_CacheData_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteamLearnCacheDataResult cache_data_result = 1; */
        if (message.cacheDataResult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cacheDataResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_CacheData_Response
 */
export const CMsgSteamLearn_CacheData_Response = new CMsgSteamLearn_CacheData_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_SnapshotProject_Request$Type extends MessageType<CMsgSteamLearn_SnapshotProject_Request> {
    constructor() {
        super("CMsgSteamLearn_SnapshotProject_Request", [
            { no: 1, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "published_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnData },
            { no: 6, name: "pending_data_limit_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_SnapshotProject_Request>): CMsgSteamLearn_SnapshotProject_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_SnapshotProject_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_SnapshotProject_Request): CMsgSteamLearn_SnapshotProject_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* optional uint32 project_id */ 3:
                    message.projectId = reader.uint32();
                    break;
                case /* optional uint32 published_version */ 7:
                    message.publishedVersion = reader.uint32();
                    break;
                case /* repeated uint64 keys */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.keys.push(reader.uint64().toBigInt());
                    else
                        message.keys.push(reader.uint64().toBigInt());
                    break;
                case /* repeated CMsgSteamLearnData data */ 5:
                    message.data.push(CMsgSteamLearnData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 pending_data_limit_seconds */ 6:
                    message.pendingDataLimitSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_SnapshotProject_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string access_token = 1; */
        if (message.accessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* optional uint32 project_id = 3; */
        if (message.projectId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.projectId);
        /* optional uint32 published_version = 7; */
        if (message.publishedVersion !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.publishedVersion);
        /* repeated uint64 keys = 4; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(4, WireType.Varint).uint64(message.keys[i]);
        /* repeated CMsgSteamLearnData data = 5; */
        for (let i = 0; i < message.data.length; i++)
            CMsgSteamLearnData.internalBinaryWrite(message.data[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 pending_data_limit_seconds = 6; */
        if (message.pendingDataLimitSeconds !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.pendingDataLimitSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_SnapshotProject_Request
 */
export const CMsgSteamLearn_SnapshotProject_Request = new CMsgSteamLearn_SnapshotProject_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_SnapshotProject_Response$Type extends MessageType<CMsgSteamLearn_SnapshotProject_Response> {
    constructor() {
        super("CMsgSteamLearn_SnapshotProject_Response", [
            { no: 1, name: "snapshot_result", kind: "enum", opt: true, T: () => ["ESteamLearnSnapshotProjectResult", ESteamLearnSnapshotProjectResult] }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_SnapshotProject_Response>): CMsgSteamLearn_SnapshotProject_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_SnapshotProject_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_SnapshotProject_Response): CMsgSteamLearn_SnapshotProject_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteamLearnSnapshotProjectResult snapshot_result */ 1:
                    message.snapshotResult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_SnapshotProject_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteamLearnSnapshotProjectResult snapshot_result = 1; */
        if (message.snapshotResult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.snapshotResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_SnapshotProject_Response
 */
export const CMsgSteamLearn_SnapshotProject_Response = new CMsgSteamLearn_SnapshotProject_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_BatchOperation_Request$Type extends MessageType<CMsgSteamLearn_BatchOperation_Request> {
    constructor() {
        super("CMsgSteamLearn_BatchOperation_Request", [
            { no: 1, name: "cache_data_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_CacheData_Request },
            { no: 2, name: "snapshot_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_SnapshotProject_Request },
            { no: 3, name: "inference_requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_Inference_Request }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_BatchOperation_Request>): CMsgSteamLearn_BatchOperation_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cacheDataRequests = [];
        message.snapshotRequests = [];
        message.inferenceRequests = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_BatchOperation_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_BatchOperation_Request): CMsgSteamLearn_BatchOperation_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearn_CacheData_Request cache_data_requests */ 1:
                    message.cacheDataRequests.push(CMsgSteamLearn_CacheData_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_SnapshotProject_Request snapshot_requests */ 2:
                    message.snapshotRequests.push(CMsgSteamLearn_SnapshotProject_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_Inference_Request inference_requests */ 3:
                    message.inferenceRequests.push(CMsgSteamLearn_Inference_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_BatchOperation_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearn_CacheData_Request cache_data_requests = 1; */
        for (let i = 0; i < message.cacheDataRequests.length; i++)
            CMsgSteamLearn_CacheData_Request.internalBinaryWrite(message.cacheDataRequests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_SnapshotProject_Request snapshot_requests = 2; */
        for (let i = 0; i < message.snapshotRequests.length; i++)
            CMsgSteamLearn_SnapshotProject_Request.internalBinaryWrite(message.snapshotRequests[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_Inference_Request inference_requests = 3; */
        for (let i = 0; i < message.inferenceRequests.length; i++)
            CMsgSteamLearn_Inference_Request.internalBinaryWrite(message.inferenceRequests[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_BatchOperation_Request
 */
export const CMsgSteamLearn_BatchOperation_Request = new CMsgSteamLearn_BatchOperation_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_BatchOperation_Response$Type extends MessageType<CMsgSteamLearn_BatchOperation_Response> {
    constructor() {
        super("CMsgSteamLearn_BatchOperation_Response", [
            { no: 1, name: "cache_data_responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_CacheData_Response },
            { no: 2, name: "snapshot_responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_SnapshotProject_Response },
            { no: 3, name: "inference_responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_Inference_Response }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_BatchOperation_Response>): CMsgSteamLearn_BatchOperation_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cacheDataResponses = [];
        message.snapshotResponses = [];
        message.inferenceResponses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_BatchOperation_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_BatchOperation_Response): CMsgSteamLearn_BatchOperation_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearn_CacheData_Response cache_data_responses */ 1:
                    message.cacheDataResponses.push(CMsgSteamLearn_CacheData_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_SnapshotProject_Response snapshot_responses */ 2:
                    message.snapshotResponses.push(CMsgSteamLearn_SnapshotProject_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_Inference_Response inference_responses */ 3:
                    message.inferenceResponses.push(CMsgSteamLearn_Inference_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_BatchOperation_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearn_CacheData_Response cache_data_responses = 1; */
        for (let i = 0; i < message.cacheDataResponses.length; i++)
            CMsgSteamLearn_CacheData_Response.internalBinaryWrite(message.cacheDataResponses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_SnapshotProject_Response snapshot_responses = 2; */
        for (let i = 0; i < message.snapshotResponses.length; i++)
            CMsgSteamLearn_SnapshotProject_Response.internalBinaryWrite(message.snapshotResponses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_Inference_Response inference_responses = 3; */
        for (let i = 0; i < message.inferenceResponses.length; i++)
            CMsgSteamLearn_Inference_Response.internalBinaryWrite(message.inferenceResponses[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_BatchOperation_Response
 */
export const CMsgSteamLearn_BatchOperation_Response = new CMsgSteamLearn_BatchOperation_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnAccessTokens$Type extends MessageType<CMsgSteamLearnAccessTokens> {
    constructor() {
        super("CMsgSteamLearnAccessTokens", [
            { no: 1, name: "register_data_source_access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cache_data_access_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnAccessTokens_CacheDataAccessToken },
            { no: 3, name: "snapshot_project_access_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken },
            { no: 4, name: "inference_access_tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearnAccessTokens_InferenceAccessToken }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnAccessTokens>): CMsgSteamLearnAccessTokens {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cacheDataAccessTokens = [];
        message.snapshotProjectAccessTokens = [];
        message.inferenceAccessTokens = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnAccessTokens>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnAccessTokens): CMsgSteamLearnAccessTokens {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string register_data_source_access_token */ 1:
                    message.registerDataSourceAccessToken = reader.string();
                    break;
                case /* repeated CMsgSteamLearnAccessTokens.CacheDataAccessToken cache_data_access_tokens */ 2:
                    message.cacheDataAccessTokens.push(CMsgSteamLearnAccessTokens_CacheDataAccessToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken snapshot_project_access_tokens */ 3:
                    message.snapshotProjectAccessTokens.push(CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearnAccessTokens.InferenceAccessToken inference_access_tokens */ 4:
                    message.inferenceAccessTokens.push(CMsgSteamLearnAccessTokens_InferenceAccessToken.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnAccessTokens, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string register_data_source_access_token = 1; */
        if (message.registerDataSourceAccessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.registerDataSourceAccessToken);
        /* repeated CMsgSteamLearnAccessTokens.CacheDataAccessToken cache_data_access_tokens = 2; */
        for (let i = 0; i < message.cacheDataAccessTokens.length; i++)
            CMsgSteamLearnAccessTokens_CacheDataAccessToken.internalBinaryWrite(message.cacheDataAccessTokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken snapshot_project_access_tokens = 3; */
        for (let i = 0; i < message.snapshotProjectAccessTokens.length; i++)
            CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.internalBinaryWrite(message.snapshotProjectAccessTokens[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearnAccessTokens.InferenceAccessToken inference_access_tokens = 4; */
        for (let i = 0; i < message.inferenceAccessTokens.length; i++)
            CMsgSteamLearnAccessTokens_InferenceAccessToken.internalBinaryWrite(message.inferenceAccessTokens[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnAccessTokens
 */
export const CMsgSteamLearnAccessTokens = new CMsgSteamLearnAccessTokens$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnAccessTokens_CacheDataAccessToken$Type extends MessageType<CMsgSteamLearnAccessTokens_CacheDataAccessToken> {
    constructor() {
        super("CMsgSteamLearnAccessTokens.CacheDataAccessToken", [
            { no: 1, name: "data_source_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnAccessTokens_CacheDataAccessToken>): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnAccessTokens_CacheDataAccessToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnAccessTokens_CacheDataAccessToken): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 data_source_id */ 1:
                    message.dataSourceId = reader.uint32();
                    break;
                case /* optional string access_token */ 2:
                    message.accessToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnAccessTokens_CacheDataAccessToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 data_source_id = 1; */
        if (message.dataSourceId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.dataSourceId);
        /* optional string access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnAccessTokens.CacheDataAccessToken
 */
export const CMsgSteamLearnAccessTokens_CacheDataAccessToken = new CMsgSteamLearnAccessTokens_CacheDataAccessToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken$Type extends MessageType<CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken> {
    constructor() {
        super("CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken", [
            { no: 1, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken>): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 project_id */ 1:
                    message.projectId = reader.uint32();
                    break;
                case /* optional string access_token */ 2:
                    message.accessToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 project_id = 1; */
        if (message.projectId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.projectId);
        /* optional string access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnAccessTokens.SnapshotProjectAccessToken
 */
export const CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken = new CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearnAccessTokens_InferenceAccessToken$Type extends MessageType<CMsgSteamLearnAccessTokens_InferenceAccessToken> {
    constructor() {
        super("CMsgSteamLearnAccessTokens.InferenceAccessToken", [
            { no: 1, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearnAccessTokens_InferenceAccessToken>): CMsgSteamLearnAccessTokens_InferenceAccessToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearnAccessTokens_InferenceAccessToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearnAccessTokens_InferenceAccessToken): CMsgSteamLearnAccessTokens_InferenceAccessToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 project_id */ 1:
                    message.projectId = reader.uint32();
                    break;
                case /* optional string access_token */ 2:
                    message.accessToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearnAccessTokens_InferenceAccessToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 project_id = 1; */
        if (message.projectId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.projectId);
        /* optional string access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearnAccessTokens.InferenceAccessToken
 */
export const CMsgSteamLearnAccessTokens_InferenceAccessToken = new CMsgSteamLearnAccessTokens_InferenceAccessToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_GetAccessTokens_Request$Type extends MessageType<CMsgSteamLearn_GetAccessTokens_Request> {
    constructor() {
        super("CMsgSteamLearn_GetAccessTokens_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_GetAccessTokens_Request>): CMsgSteamLearn_GetAccessTokens_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_GetAccessTokens_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_GetAccessTokens_Request): CMsgSteamLearn_GetAccessTokens_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_GetAccessTokens_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_GetAccessTokens_Request
 */
export const CMsgSteamLearn_GetAccessTokens_Request = new CMsgSteamLearn_GetAccessTokens_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_GetAccessTokens_Response$Type extends MessageType<CMsgSteamLearn_GetAccessTokens_Response> {
    constructor() {
        super("CMsgSteamLearn_GetAccessTokens_Response", [
            { no: 1, name: "result", kind: "enum", opt: true, T: () => ["ESteamLearnGetAccessTokensResult", ESteamLearnGetAccessTokensResult] },
            { no: 2, name: "access_tokens", kind: "message", T: () => CMsgSteamLearnAccessTokens }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_GetAccessTokens_Response>): CMsgSteamLearn_GetAccessTokens_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_GetAccessTokens_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_GetAccessTokens_Response): CMsgSteamLearn_GetAccessTokens_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteamLearnGetAccessTokensResult result */ 1:
                    message.result = reader.int32();
                    break;
                case /* optional CMsgSteamLearnAccessTokens access_tokens */ 2:
                    message.accessTokens = CMsgSteamLearnAccessTokens.internalBinaryRead(reader, reader.uint32(), options, message.accessTokens);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_GetAccessTokens_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteamLearnGetAccessTokensResult result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* optional CMsgSteamLearnAccessTokens access_tokens = 2; */
        if (message.accessTokens)
            CMsgSteamLearnAccessTokens.internalBinaryWrite(message.accessTokens, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_GetAccessTokens_Response
 */
export const CMsgSteamLearn_GetAccessTokens_Response = new CMsgSteamLearn_GetAccessTokens_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_Inference_Request$Type extends MessageType<CMsgSteamLearn_Inference_Request> {
    constructor() {
        super("CMsgSteamLearn_Inference_Request", [
            { no: 1, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "published_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "override_train_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "message", T: () => CMsgSteamLearnDataList },
            { no: 7, name: "additional_data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_Inference_Request>): CMsgSteamLearn_Inference_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.additionalData = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_Inference_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_Inference_Request): CMsgSteamLearn_Inference_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* optional uint32 project_id */ 3:
                    message.projectId = reader.uint32();
                    break;
                case /* optional uint32 published_version */ 4:
                    message.publishedVersion = reader.uint32();
                    break;
                case /* optional uint32 override_train_id */ 5:
                    message.overrideTrainId = reader.uint32();
                    break;
                case /* optional CMsgSteamLearnDataList data */ 6:
                    message.data = CMsgSteamLearnDataList.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* repeated float additional_data */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.additionalData.push(reader.float());
                    else
                        message.additionalData.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_Inference_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string access_token = 1; */
        if (message.accessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* optional uint32 project_id = 3; */
        if (message.projectId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.projectId);
        /* optional uint32 published_version = 4; */
        if (message.publishedVersion !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.publishedVersion);
        /* optional uint32 override_train_id = 5; */
        if (message.overrideTrainId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.overrideTrainId);
        /* optional CMsgSteamLearnDataList data = 6; */
        if (message.data)
            CMsgSteamLearnDataList.internalBinaryWrite(message.data, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated float additional_data = 7; */
        for (let i = 0; i < message.additionalData.length; i++)
            writer.tag(7, WireType.Bit32).float(message.additionalData[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_Inference_Request
 */
export const CMsgSteamLearn_Inference_Request = new CMsgSteamLearn_Inference_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Request$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Request> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Request", [
            { no: 1, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "published_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "override_train_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Request>): CMsgSteamLearn_InferenceMetadata_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Request): CMsgSteamLearn_InferenceMetadata_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* optional uint32 project_id */ 3:
                    message.projectId = reader.uint32();
                    break;
                case /* optional uint32 published_version */ 4:
                    message.publishedVersion = reader.uint32();
                    break;
                case /* optional uint32 override_train_id */ 5:
                    message.overrideTrainId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string access_token = 1; */
        if (message.accessToken !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* optional uint32 project_id = 3; */
        if (message.projectId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.projectId);
        /* optional uint32 published_version = 4; */
        if (message.publishedVersion !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.publishedVersion);
        /* optional uint32 override_train_id = 5; */
        if (message.overrideTrainId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.overrideTrainId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Request
 */
export const CMsgSteamLearn_InferenceMetadata_Request = new CMsgSteamLearn_InferenceMetadata_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadataBackend_Request$Type extends MessageType<CMsgSteamLearn_InferenceMetadataBackend_Request> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadataBackend_Request", [
            { no: 1, name: "project_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fetch_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadataBackend_Request>): CMsgSteamLearn_InferenceMetadataBackend_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadataBackend_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadataBackend_Request): CMsgSteamLearn_InferenceMetadataBackend_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 project_id */ 1:
                    message.projectId = reader.uint32();
                    break;
                case /* optional uint32 fetch_id */ 2:
                    message.fetchId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadataBackend_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 project_id = 1; */
        if (message.projectId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.projectId);
        /* optional uint32 fetch_id = 2; */
        if (message.fetchId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.fetchId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadataBackend_Request
 */
export const CMsgSteamLearn_InferenceMetadataBackend_Request = new CMsgSteamLearn_InferenceMetadataBackend_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response", [
            { no: 1, name: "inference_metadata_result", kind: "enum", opt: true, T: () => ["ESteamLearnInferenceMetadataResult", ESteamLearnInferenceMetadataResult] },
            { no: 2, name: "row_range", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_RowRange },
            { no: 3, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_Range },
            { no: 4, name: "std_devs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_StdDev },
            { no: 5, name: "compact_tables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_CompactTable },
            { no: 9, name: "sequence_tables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_SequenceTable },
            { no: 6, name: "kmeans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_KMeans },
            { no: 8, name: "app_info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry },
            { no: 7, name: "snapshot_histogram", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response>): CMsgSteamLearn_InferenceMetadata_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        message.stdDevs = [];
        message.compactTables = [];
        message.sequenceTables = [];
        message.kmeans = [];
        message.appInfo = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response): CMsgSteamLearn_InferenceMetadata_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteamLearnInferenceMetadataResult inference_metadata_result */ 1:
                    message.inferenceMetadataResult = reader.int32();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.RowRange row_range */ 2:
                    message.rowRange = CMsgSteamLearn_InferenceMetadata_Response_RowRange.internalBinaryRead(reader, reader.uint32(), options, message.rowRange);
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.Range ranges */ 3:
                    message.ranges.push(CMsgSteamLearn_InferenceMetadata_Response_Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.StdDev std_devs */ 4:
                    message.stdDevs.push(CMsgSteamLearn_InferenceMetadata_Response_StdDev.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable compact_tables */ 5:
                    message.compactTables.push(CMsgSteamLearn_InferenceMetadata_Response_CompactTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable sequence_tables */ 9:
                    message.sequenceTables.push(CMsgSteamLearn_InferenceMetadata_Response_SequenceTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans kmeans */ 6:
                    message.kmeans.push(CMsgSteamLearn_InferenceMetadata_Response_KMeans.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry app_info */ 8:
                    message.appInfo.push(CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram snapshot_histogram */ 7:
                    message.snapshotHistogram = CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram.internalBinaryRead(reader, reader.uint32(), options, message.snapshotHistogram);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteamLearnInferenceMetadataResult inference_metadata_result = 1; */
        if (message.inferenceMetadataResult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.inferenceMetadataResult);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.RowRange row_range = 2; */
        if (message.rowRange)
            CMsgSteamLearn_InferenceMetadata_Response_RowRange.internalBinaryWrite(message.rowRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.Range ranges = 3; */
        for (let i = 0; i < message.ranges.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_Range.internalBinaryWrite(message.ranges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.StdDev std_devs = 4; */
        for (let i = 0; i < message.stdDevs.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_StdDev.internalBinaryWrite(message.stdDevs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable compact_tables = 5; */
        for (let i = 0; i < message.compactTables.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_CompactTable.internalBinaryWrite(message.compactTables[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable sequence_tables = 9; */
        for (let i = 0; i < message.sequenceTables.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_SequenceTable.internalBinaryWrite(message.sequenceTables[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans kmeans = 6; */
        for (let i = 0; i < message.kmeans.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_KMeans.internalBinaryWrite(message.kmeans[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry app_info = 8; */
        for (let i = 0; i < message.appInfo.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry.internalBinaryWrite(message.appInfo[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram snapshot_histogram = 7; */
        if (message.snapshotHistogram)
            CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram.internalBinaryWrite(message.snapshotHistogram, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response
 */
export const CMsgSteamLearn_InferenceMetadata_Response = new CMsgSteamLearn_InferenceMetadata_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_RowRange$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_RowRange> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.RowRange", [
            { no: 1, name: "min_row", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_row", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_RowRange>): CMsgSteamLearn_InferenceMetadata_Response_RowRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_RowRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_RowRange): CMsgSteamLearn_InferenceMetadata_Response_RowRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_row */ 1:
                    message.minRow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_row */ 2:
                    message.maxRow = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_RowRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 min_row = 1; */
        if (message.minRow !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.minRow);
        /* optional uint64 max_row = 2; */
        if (message.maxRow !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.maxRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.RowRange
 */
export const CMsgSteamLearn_InferenceMetadata_Response_RowRange = new CMsgSteamLearn_InferenceMetadata_Response_RowRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_Range$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_Range> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.Range", [
            { no: 1, name: "data_element_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "min_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "max_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_Range>): CMsgSteamLearn_InferenceMetadata_Response_Range {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_Range>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_Range): CMsgSteamLearn_InferenceMetadata_Response_Range {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string data_element_path */ 1:
                    message.dataElementPath = reader.string();
                    break;
                case /* optional float min_value */ 2:
                    message.minValue = reader.float();
                    break;
                case /* optional float max_value */ 3:
                    message.maxValue = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_Range, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string data_element_path = 1; */
        if (message.dataElementPath !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.dataElementPath);
        /* optional float min_value = 2; */
        if (message.minValue !== undefined)
            writer.tag(2, WireType.Bit32).float(message.minValue);
        /* optional float max_value = 3; */
        if (message.maxValue !== undefined)
            writer.tag(3, WireType.Bit32).float(message.maxValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.Range
 */
export const CMsgSteamLearn_InferenceMetadata_Response_Range = new CMsgSteamLearn_InferenceMetadata_Response_Range$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_StdDev$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_StdDev> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.StdDev", [
            { no: 1, name: "data_element_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mean", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "std_dev", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_StdDev>): CMsgSteamLearn_InferenceMetadata_Response_StdDev {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_StdDev>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_StdDev): CMsgSteamLearn_InferenceMetadata_Response_StdDev {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string data_element_path */ 1:
                    message.dataElementPath = reader.string();
                    break;
                case /* optional float mean */ 2:
                    message.mean = reader.float();
                    break;
                case /* optional float std_dev */ 3:
                    message.stdDev = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_StdDev, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string data_element_path = 1; */
        if (message.dataElementPath !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.dataElementPath);
        /* optional float mean = 2; */
        if (message.mean !== undefined)
            writer.tag(2, WireType.Bit32).float(message.mean);
        /* optional float std_dev = 3; */
        if (message.stdDev !== undefined)
            writer.tag(3, WireType.Bit32).float(message.stdDev);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.StdDev
 */
export const CMsgSteamLearn_InferenceMetadata_Response_StdDev = new CMsgSteamLearn_InferenceMetadata_Response_StdDev$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_CompactTable$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_CompactTable> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.CompactTable", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map_values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry },
            { no: 3, name: "map_mappings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_CompactTable>): CMsgSteamLearn_InferenceMetadata_Response_CompactTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapValues = [];
        message.mapMappings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_CompactTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable): CMsgSteamLearn_InferenceMetadata_Response_CompactTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry map_values */ 2:
                    message.mapValues.push(CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry map_mappings */ 3:
                    message.mapMappings.push(CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_CompactTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry map_values = 2; */
        for (let i = 0; i < message.mapValues.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry.internalBinaryWrite(message.mapValues[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry map_mappings = 3; */
        for (let i = 0; i < message.mapMappings.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry.internalBinaryWrite(message.mapMappings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable
 */
export const CMsgSteamLearn_InferenceMetadata_Response_CompactTable = new CMsgSteamLearn_InferenceMetadata_Response_CompactTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "mapping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry>): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 value */ 1:
                    message.value = reader.uint32();
                    break;
                case /* optional uint32 mapping */ 2:
                    message.mapping = reader.uint32();
                    break;
                case /* optional uint64 count */ 3:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.value);
        /* optional uint32 mapping = 2; */
        if (message.mapping !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.mapping);
        /* optional uint64 count = 3; */
        if (message.count !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry = new CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry>): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value */ 2:
                    message.value = CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value = 2; */
        if (message.value)
            CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry = new CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapValuesEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry>): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry): CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value */ 2:
                    message.value = CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry value = 2; */
        if (message.value)
            CMsgSteamLearn_InferenceMetadata_Response_CompactTable_Entry.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry = new CMsgSteamLearn_InferenceMetadata_Response_CompactTable_MapMappingsEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_SequenceTable$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.SequenceTable", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "map_values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry },
            { no: 3, name: "map_mappings", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry },
            { no: 4, name: "total_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable>): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mapValues = [];
        message.mapMappings = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry map_values */ 2:
                    message.mapValues.push(CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry map_mappings */ 3:
                    message.mapMappings.push(CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 total_count */ 4:
                    message.totalCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry map_values = 2; */
        for (let i = 0; i < message.mapValues.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry.internalBinaryWrite(message.mapValues[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry map_mappings = 3; */
        for (let i = 0; i < message.mapMappings.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry.internalBinaryWrite(message.mapMappings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 total_count = 4; */
        if (message.totalCount !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable
 */
export const CMsgSteamLearn_InferenceMetadata_Response_SequenceTable = new CMsgSteamLearn_InferenceMetadata_Response_SequenceTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry", [
            { no: 1, name: "values", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry>): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 values */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.values.push(reader.uint32());
                    else
                        message.values.push(reader.uint32());
                    break;
                case /* optional uint32 crc */ 2:
                    message.crc = reader.uint32();
                    break;
                case /* optional uint32 count */ 3:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 values = 1; */
        for (let i = 0; i < message.values.length; i++)
            writer.tag(1, WireType.Varint).uint32(message.values[i]);
        /* optional uint32 crc = 2; */
        if (message.crc !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.crc);
        /* optional uint32 count = 3; */
        if (message.count !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry = new CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry>): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value */ 2:
                    message.value = CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value = 2; */
        if (message.value)
            CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapValuesEntry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry = new CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapValuesEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry>): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry): CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value */ 2:
                    message.value = CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.Entry value = 2; */
        if (message.value)
            CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_Entry.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.SequenceTable.MapMappingsEntry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry = new CMsgSteamLearn_InferenceMetadata_Response_SequenceTable_MapMappingsEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_KMeans$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_KMeans> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.KMeans", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "clusters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_KMeans>): CMsgSteamLearn_InferenceMetadata_Response_KMeans {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_KMeans>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_KMeans): CMsgSteamLearn_InferenceMetadata_Response_KMeans {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster clusters */ 2:
                    message.clusters.push(CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_KMeans, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster clusters = 2; */
        for (let i = 0; i < message.clusters.length; i++)
            CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster.internalBinaryWrite(message.clusters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.KMeans
 */
export const CMsgSteamLearn_InferenceMetadata_Response_KMeans = new CMsgSteamLearn_InferenceMetadata_Response_KMeans$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "radius_75pct", kind: "scalar", jsonName: "radius75pct", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "radius_50pct", kind: "scalar", jsonName: "radius50pct", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "radius_25pct", kind: "scalar", jsonName: "radius25pct", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster>): CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster): CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float radius */ 3:
                    message.radius = reader.float();
                    break;
                case /* optional float radius_75pct = 4 [json_name = "radius75pct"];*/ 4:
                    message.radius75Pct = reader.float();
                    break;
                case /* optional float radius_50pct = 5 [json_name = "radius50pct"];*/ 5:
                    message.radius50Pct = reader.float();
                    break;
                case /* optional float radius_25pct = 6 [json_name = "radius25pct"];*/ 6:
                    message.radius25Pct = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float radius = 3; */
        if (message.radius !== undefined)
            writer.tag(3, WireType.Bit32).float(message.radius);
        /* optional float radius_75pct = 4 [json_name = "radius75pct"]; */
        if (message.radius75Pct !== undefined)
            writer.tag(4, WireType.Bit32).float(message.radius75Pct);
        /* optional float radius_50pct = 5 [json_name = "radius50pct"]; */
        if (message.radius50Pct !== undefined)
            writer.tag(5, WireType.Bit32).float(message.radius50Pct);
        /* optional float radius_25pct = 6 [json_name = "radius25pct"]; */
        if (message.radius25Pct !== undefined)
            writer.tag(6, WireType.Bit32).float(message.radius25Pct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster
 */
export const CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster = new CMsgSteamLearn_InferenceMetadata_Response_KMeans_Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram", [
            { no: 1, name: "min_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "max_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "num_buckets", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bucket_counts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram>): CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketCounts = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram): CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float min_value */ 1:
                    message.minValue = reader.float();
                    break;
                case /* optional float max_value */ 2:
                    message.maxValue = reader.float();
                    break;
                case /* optional uint32 num_buckets */ 3:
                    message.numBuckets = reader.uint32();
                    break;
                case /* repeated uint32 bucket_counts */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bucketCounts.push(reader.uint32());
                    else
                        message.bucketCounts.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float min_value = 1; */
        if (message.minValue !== undefined)
            writer.tag(1, WireType.Bit32).float(message.minValue);
        /* optional float max_value = 2; */
        if (message.maxValue !== undefined)
            writer.tag(2, WireType.Bit32).float(message.maxValue);
        /* optional uint32 num_buckets = 3; */
        if (message.numBuckets !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.numBuckets);
        /* repeated uint32 bucket_counts = 4; */
        for (let i = 0; i < message.bucketCounts.length; i++)
            writer.tag(4, WireType.Varint).uint32(message.bucketCounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram
 */
export const CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram = new CMsgSteamLearn_InferenceMetadata_Response_SnapshotHistogram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_AppInfo$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_AppInfo> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.AppInfo", [
            { no: 1, name: "country_allow", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "country_deny", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform_win", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "platform_mac", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "platform_linux", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "adult_violence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "adult_sex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_AppInfo>): CMsgSteamLearn_InferenceMetadata_Response_AppInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_AppInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_AppInfo): CMsgSteamLearn_InferenceMetadata_Response_AppInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string country_allow */ 1:
                    message.countryAllow = reader.string();
                    break;
                case /* optional string country_deny */ 2:
                    message.countryDeny = reader.string();
                    break;
                case /* optional bool platform_win */ 3:
                    message.platformWin = reader.bool();
                    break;
                case /* optional bool platform_mac */ 4:
                    message.platformMac = reader.bool();
                    break;
                case /* optional bool platform_linux */ 5:
                    message.platformLinux = reader.bool();
                    break;
                case /* optional bool adult_violence */ 6:
                    message.adultViolence = reader.bool();
                    break;
                case /* optional bool adult_sex */ 7:
                    message.adultSex = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_AppInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string country_allow = 1; */
        if (message.countryAllow !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.countryAllow);
        /* optional string country_deny = 2; */
        if (message.countryDeny !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.countryDeny);
        /* optional bool platform_win = 3; */
        if (message.platformWin !== undefined)
            writer.tag(3, WireType.Varint).bool(message.platformWin);
        /* optional bool platform_mac = 4; */
        if (message.platformMac !== undefined)
            writer.tag(4, WireType.Varint).bool(message.platformMac);
        /* optional bool platform_linux = 5; */
        if (message.platformLinux !== undefined)
            writer.tag(5, WireType.Varint).bool(message.platformLinux);
        /* optional bool adult_violence = 6; */
        if (message.adultViolence !== undefined)
            writer.tag(6, WireType.Varint).bool(message.adultViolence);
        /* optional bool adult_sex = 7; */
        if (message.adultSex !== undefined)
            writer.tag(7, WireType.Varint).bool(message.adultSex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.AppInfo
 */
export const CMsgSteamLearn_InferenceMetadata_Response_AppInfo = new CMsgSteamLearn_InferenceMetadata_Response_AppInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry$Type extends MessageType<CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry> {
    constructor() {
        super("CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "message", T: () => CMsgSteamLearn_InferenceMetadata_Response_AppInfo }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry>): CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry): CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* optional CMsgSteamLearn_InferenceMetadata_Response.AppInfo value */ 2:
                    message.value = CMsgSteamLearn_InferenceMetadata_Response_AppInfo.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.key);
        /* optional CMsgSteamLearn_InferenceMetadata_Response.AppInfo value = 2; */
        if (message.value)
            CMsgSteamLearn_InferenceMetadata_Response_AppInfo.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceMetadata_Response.AppInfoEntry
 */
export const CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry = new CMsgSteamLearn_InferenceMetadata_Response_AppInfoEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response", [
            { no: 1, name: "outputs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceBackend_Response_Output }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response>): CMsgSteamLearn_InferenceBackend_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.outputs = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response): CMsgSteamLearn_InferenceBackend_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamLearn_InferenceBackend_Response.Output outputs */ 1:
                    message.outputs.push(CMsgSteamLearn_InferenceBackend_Response_Output.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamLearn_InferenceBackend_Response.Output outputs = 1; */
        for (let i = 0; i < message.outputs.length; i++)
            CMsgSteamLearn_InferenceBackend_Response_Output.internalBinaryWrite(message.outputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response
 */
export const CMsgSteamLearn_InferenceBackend_Response = new CMsgSteamLearn_InferenceBackend_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_Sequence$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_Sequence> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.Sequence", [
            { no: 1, name: "value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_Sequence>): CMsgSteamLearn_InferenceBackend_Response_Sequence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_Sequence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_Sequence): CMsgSteamLearn_InferenceBackend_Response_Sequence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float value */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.value.push(reader.float());
                    else
                        message.value.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_Sequence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float value = 1; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(1, WireType.Bit32).float(message.value[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.Sequence
 */
export const CMsgSteamLearn_InferenceBackend_Response_Sequence = new CMsgSteamLearn_InferenceBackend_Response_Sequence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_RegressionOutput$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_RegressionOutput> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.RegressionOutput", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_RegressionOutput>): CMsgSteamLearn_InferenceBackend_Response_RegressionOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_RegressionOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_RegressionOutput): CMsgSteamLearn_InferenceBackend_Response_RegressionOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float value */ 1:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_RegressionOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.RegressionOutput
 */
export const CMsgSteamLearn_InferenceBackend_Response_RegressionOutput = new CMsgSteamLearn_InferenceBackend_Response_RegressionOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput>): CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput): CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float value */ 1:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput
 */
export const CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput = new CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput", [
            { no: 1, name: "weight", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "value_sequence", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceBackend_Response_Sequence }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput>): CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.weight = [];
        message.value = [];
        message.valueSequence = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput): CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float weight */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.weight.push(reader.float());
                    else
                        message.weight.push(reader.float());
                    break;
                case /* repeated float value */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.value.push(reader.float());
                    else
                        message.value.push(reader.float());
                    break;
                case /* repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence */ 3:
                    message.valueSequence.push(CMsgSteamLearn_InferenceBackend_Response_Sequence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float weight = 1; */
        for (let i = 0; i < message.weight.length; i++)
            writer.tag(1, WireType.Bit32).float(message.weight[i]);
        /* repeated float value = 2; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(2, WireType.Bit32).float(message.value[i]);
        /* repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence = 3; */
        for (let i = 0; i < message.valueSequence.length; i++)
            CMsgSteamLearn_InferenceBackend_Response_Sequence.internalBinaryWrite(message.valueSequence[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput
 */
export const CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput = new CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput", [
            { no: 1, name: "weight", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "value", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "value_sequence", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamLearn_InferenceBackend_Response_Sequence }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput>): CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.weight = [];
        message.value = [];
        message.valueSequence = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput): CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float weight */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.weight.push(reader.float());
                    else
                        message.weight.push(reader.float());
                    break;
                case /* repeated float value */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.value.push(reader.float());
                    else
                        message.value.push(reader.float());
                    break;
                case /* repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence */ 3:
                    message.valueSequence.push(CMsgSteamLearn_InferenceBackend_Response_Sequence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float weight = 1; */
        for (let i = 0; i < message.weight.length; i++)
            writer.tag(1, WireType.Bit32).float(message.weight[i]);
        /* repeated float value = 2; */
        for (let i = 0; i < message.value.length; i++)
            writer.tag(2, WireType.Bit32).float(message.value[i]);
        /* repeated CMsgSteamLearn_InferenceBackend_Response.Sequence value_sequence = 3; */
        for (let i = 0; i < message.valueSequence.length; i++)
            CMsgSteamLearn_InferenceBackend_Response_Sequence.internalBinaryWrite(message.valueSequence[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput
 */
export const CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput = new CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_InferenceBackend_Response_Output$Type extends MessageType<CMsgSteamLearn_InferenceBackend_Response_Output> {
    constructor() {
        super("CMsgSteamLearn_InferenceBackend_Response.Output", [
            { no: 1, name: "binary_crossentropy", kind: "message", oneof: "responseType", T: () => CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput },
            { no: 2, name: "categorical_crossentropy", kind: "message", oneof: "responseType", T: () => CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput },
            { no: 3, name: "multi_binary_crossentropy", kind: "message", oneof: "responseType", T: () => CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput },
            { no: 4, name: "regression", kind: "message", oneof: "responseType", T: () => CMsgSteamLearn_InferenceBackend_Response_RegressionOutput }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_InferenceBackend_Response_Output>): CMsgSteamLearn_InferenceBackend_Response_Output {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responseType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_InferenceBackend_Response_Output>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_InferenceBackend_Response_Output): CMsgSteamLearn_InferenceBackend_Response_Output {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput binary_crossentropy */ 1:
                    message.responseType = {
                        oneofKind: "binaryCrossentropy",
                        binaryCrossentropy: CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput.internalBinaryRead(reader, reader.uint32(), options, (message.responseType as any).binaryCrossentropy)
                    };
                    break;
                case /* CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput categorical_crossentropy */ 2:
                    message.responseType = {
                        oneofKind: "categoricalCrossentropy",
                        categoricalCrossentropy: CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput.internalBinaryRead(reader, reader.uint32(), options, (message.responseType as any).categoricalCrossentropy)
                    };
                    break;
                case /* CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput multi_binary_crossentropy */ 3:
                    message.responseType = {
                        oneofKind: "multiBinaryCrossentropy",
                        multiBinaryCrossentropy: CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput.internalBinaryRead(reader, reader.uint32(), options, (message.responseType as any).multiBinaryCrossentropy)
                    };
                    break;
                case /* CMsgSteamLearn_InferenceBackend_Response.RegressionOutput regression */ 4:
                    message.responseType = {
                        oneofKind: "regression",
                        regression: CMsgSteamLearn_InferenceBackend_Response_RegressionOutput.internalBinaryRead(reader, reader.uint32(), options, (message.responseType as any).regression)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_InferenceBackend_Response_Output, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput binary_crossentropy = 1; */
        if (message.responseType.oneofKind === "binaryCrossentropy")
            CMsgSteamLearn_InferenceBackend_Response_BinaryCrossEntropyOutput.internalBinaryWrite(message.responseType.binaryCrossentropy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput categorical_crossentropy = 2; */
        if (message.responseType.oneofKind === "categoricalCrossentropy")
            CMsgSteamLearn_InferenceBackend_Response_CategoricalCrossEntropyOutput.internalBinaryWrite(message.responseType.categoricalCrossentropy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput multi_binary_crossentropy = 3; */
        if (message.responseType.oneofKind === "multiBinaryCrossentropy")
            CMsgSteamLearn_InferenceBackend_Response_MutliBinaryCrossEntropyOutput.internalBinaryWrite(message.responseType.multiBinaryCrossentropy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* CMsgSteamLearn_InferenceBackend_Response.RegressionOutput regression = 4; */
        if (message.responseType.oneofKind === "regression")
            CMsgSteamLearn_InferenceBackend_Response_RegressionOutput.internalBinaryWrite(message.responseType.regression, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_InferenceBackend_Response.Output
 */
export const CMsgSteamLearn_InferenceBackend_Response_Output = new CMsgSteamLearn_InferenceBackend_Response_Output$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamLearn_Inference_Response$Type extends MessageType<CMsgSteamLearn_Inference_Response> {
    constructor() {
        super("CMsgSteamLearn_Inference_Response", [
            { no: 1, name: "inference_result", kind: "enum", opt: true, T: () => ["ESteamLearnInferenceResult", ESteamLearnInferenceResult] },
            { no: 2, name: "backend_response", kind: "message", T: () => CMsgSteamLearn_InferenceBackend_Response },
            { no: 3, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamLearn_Inference_Response>): CMsgSteamLearn_Inference_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamLearn_Inference_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamLearn_Inference_Response): CMsgSteamLearn_Inference_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESteamLearnInferenceResult inference_result */ 1:
                    message.inferenceResult = reader.int32();
                    break;
                case /* optional CMsgSteamLearn_InferenceBackend_Response backend_response */ 2:
                    message.backendResponse = CMsgSteamLearn_InferenceBackend_Response.internalBinaryRead(reader, reader.uint32(), options, message.backendResponse);
                    break;
                case /* repeated uint64 keys */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.keys.push(reader.uint64().toBigInt());
                    else
                        message.keys.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamLearn_Inference_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESteamLearnInferenceResult inference_result = 1; */
        if (message.inferenceResult !== undefined)
            writer.tag(1, WireType.Varint).int32(message.inferenceResult);
        /* optional CMsgSteamLearn_InferenceBackend_Response backend_response = 2; */
        if (message.backendResponse)
            CMsgSteamLearn_InferenceBackend_Response.internalBinaryWrite(message.backendResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(3, WireType.Varint).uint64(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamLearn_Inference_Response
 */
export const CMsgSteamLearn_Inference_Response = new CMsgSteamLearn_Inference_Response$Type();
/**
 * @generated ServiceType for protobuf service SteamLearn
 */
export const SteamLearn = new ServiceType("SteamLearn", [
    { name: "RegisterDataSource", options: { method_description: "Registers a data desc (or finds a data desc if it's already registered)." }, I: CMsgSteamLearn_RegisterDataSource_Request, O: CMsgSteamLearn_RegisterDataSource_Response },
    { name: "CacheData", options: { method_description: "Updates a cached data entry." }, I: CMsgSteamLearn_CacheData_Request, O: CMsgSteamLearn_CacheData_Response },
    { name: "SnapshotProject", options: { method_description: "Snapshots the current data for a project." }, I: CMsgSteamLearn_SnapshotProject_Request, O: CMsgSteamLearn_SnapshotProject_Response },
    { name: "BatchOperation", options: { method_description: "Batches multiple data updates, snapshots, and inference requests into a single call" }, I: CMsgSteamLearn_BatchOperation_Request, O: CMsgSteamLearn_BatchOperation_Response },
    { name: "GetAccessTokens", options: { method_description: "Gets the access tokens needed for registering data sources, submitting data to them, and snapshotting projects" }, I: CMsgSteamLearn_GetAccessTokens_Request, O: CMsgSteamLearn_GetAccessTokens_Response },
    { name: "Inference", options: { method_description: "Inferences using supplied data, or data associated with the specified key." }, I: CMsgSteamLearn_Inference_Request, O: CMsgSteamLearn_Inference_Response },
    { name: "InferenceMetadata", options: { method_description: "Requests the metadata that was generated from a specified fetch." }, I: CMsgSteamLearn_InferenceMetadata_Request, O: CMsgSteamLearn_InferenceMetadata_Response }
], { service_description: "Service for submitting data, training, and inferencing with SteamLearn." });

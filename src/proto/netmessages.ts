// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "netmessages.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgVector } from "./networkbasetypes";
import { CMsgQAngle } from "./networkbasetypes";
import { CSVCMsg_GameSessionConfiguration } from "./networkbasetypes";
/**
 * @generated from protobuf message CCLCMsg_ClientInfo
 */
export interface CCLCMsg_ClientInfo {
    /**
     * @generated from protobuf field: optional fixed32 send_table_crc = 1;
     */
    sendTableCrc?: number;
    /**
     * @generated from protobuf field: optional uint32 server_count = 2;
     */
    serverCount?: number;
    /**
     * @generated from protobuf field: optional bool is_hltv = 3;
     */
    isHltv?: boolean;
    /**
     * @generated from protobuf field: optional uint32 friends_id = 5;
     */
    friendsId?: number;
    /**
     * @generated from protobuf field: optional string friends_name = 6;
     */
    friendsName?: string;
}
/**
 * @generated from protobuf message CCLCMsg_Move
 */
export interface CCLCMsg_Move {
    /**
     * @generated from protobuf field: optional bytes data = 3;
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 last_command_number = 4;
     */
    lastCommandNumber?: number;
}
/**
 * @generated from protobuf message CMsgVoiceAudio
 */
export interface CMsgVoiceAudio {
    /**
     * @generated from protobuf field: optional VoiceDataFormat_t format = 1;
     */
    format?: VoiceDataFormat_t;
    /**
     * @generated from protobuf field: optional bytes voice_data = 2;
     */
    voiceData?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 sequence_bytes = 3;
     */
    sequenceBytes?: number;
    /**
     * @generated from protobuf field: optional uint32 section_number = 4;
     */
    sectionNumber?: number;
    /**
     * @generated from protobuf field: optional uint32 sample_rate = 5;
     */
    sampleRate?: number;
    /**
     * @generated from protobuf field: optional uint32 uncompressed_sample_offset = 6;
     */
    uncompressedSampleOffset?: number;
    /**
     * @generated from protobuf field: optional uint32 num_packets = 7;
     */
    numPackets?: number;
    /**
     * @generated from protobuf field: repeated uint32 packet_offsets = 8 [packed = true];
     */
    packetOffsets: number[];
    /**
     * @generated from protobuf field: optional float voice_level = 9;
     */
    voiceLevel?: number;
}
/**
 * @generated from protobuf message CCLCMsg_VoiceData
 */
export interface CCLCMsg_VoiceData {
    /**
     * @generated from protobuf field: optional CMsgVoiceAudio audio = 1;
     */
    audio?: CMsgVoiceAudio;
    /**
     * @generated from protobuf field: optional fixed64 xuid = 2;
     */
    xuid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 tick = 3;
     */
    tick?: number;
}
/**
 * @generated from protobuf message CCLCMsg_BaselineAck
 */
export interface CCLCMsg_BaselineAck {
    /**
     * @generated from protobuf field: optional int32 baseline_tick = 1;
     */
    baselineTick?: number;
    /**
     * @generated from protobuf field: optional int32 baseline_nr = 2;
     */
    baselineNr?: number;
}
/**
 * @generated from protobuf message CCLCMsg_ListenEvents
 */
export interface CCLCMsg_ListenEvents {
    /**
     * @generated from protobuf field: repeated fixed32 event_mask = 1;
     */
    eventMask: number[];
}
/**
 * @generated from protobuf message CCLCMsg_RespondCvarValue
 */
export interface CCLCMsg_RespondCvarValue {
    /**
     * @generated from protobuf field: optional int32 cookie = 1;
     */
    cookie?: number;
    /**
     * @generated from protobuf field: optional int32 status_code = 2;
     */
    statusCode?: number;
    /**
     * @generated from protobuf field: optional string name = 3;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 4;
     */
    value?: string;
}
/**
 * @generated from protobuf message CCLCMsg_FileCRCCheck
 */
export interface CCLCMsg_FileCRCCheck {
    /**
     * @generated from protobuf field: optional int32 code_path = 1;
     */
    codePath?: number;
    /**
     * @generated from protobuf field: optional string path = 2;
     */
    path?: string;
    /**
     * @generated from protobuf field: optional int32 code_filename = 3;
     */
    codeFilename?: number;
    /**
     * @generated from protobuf field: optional string filename = 4;
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional fixed32 crc = 5;
     */
    crc?: number;
}
/**
 * @generated from protobuf message CCLCMsg_LoadingProgress
 */
export interface CCLCMsg_LoadingProgress {
    /**
     * @generated from protobuf field: optional int32 progress = 1;
     */
    progress?: number;
}
/**
 * @generated from protobuf message CCLCMsg_SplitPlayerConnect
 */
export interface CCLCMsg_SplitPlayerConnect {
    /**
     * @generated from protobuf field: optional string playername = 1;
     */
    playername?: string;
}
/**
 * @generated from protobuf message CCLCMsg_SplitPlayerDisconnect
 */
export interface CCLCMsg_SplitPlayerDisconnect {
    /**
     * @generated from protobuf field: optional int32 slot = 1;
     */
    slot?: number;
}
/**
 * @generated from protobuf message CCLCMsg_ServerStatus
 */
export interface CCLCMsg_ServerStatus {
    /**
     * @generated from protobuf field: optional bool simplified = 1;
     */
    simplified?: boolean;
}
/**
 * @generated from protobuf message CCLCMsg_RequestPause
 */
export interface CCLCMsg_RequestPause {
    /**
     * @generated from protobuf field: optional RequestPause_t pause_type = 1;
     */
    pauseType?: RequestPause_t;
    /**
     * @generated from protobuf field: optional int32 pause_group = 2;
     */
    pauseGroup?: number;
}
/**
 * @generated from protobuf message CCLCMsg_CmdKeyValues
 */
export interface CCLCMsg_CmdKeyValues {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CCLCMsg_RconServerDetails
 */
export interface CCLCMsg_RconServerDetails {
    /**
     * @generated from protobuf field: optional bytes token = 1;
     */
    token?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSource2SystemSpecs
 */
export interface CMsgSource2SystemSpecs {
    /**
     * @generated from protobuf field: optional string cpu_id = 1;
     */
    cpuId?: string;
    /**
     * @generated from protobuf field: optional string cpu_brand = 2;
     */
    cpuBrand?: string;
    /**
     * @generated from protobuf field: optional uint32 cpu_model = 3;
     */
    cpuModel?: number;
    /**
     * @generated from protobuf field: optional uint32 cpu_num_physical = 4;
     */
    cpuNumPhysical?: number;
    /**
     * @generated from protobuf field: optional uint32 ram_physical_total_mb = 21;
     */
    ramPhysicalTotalMb?: number;
    /**
     * @generated from protobuf field: optional string gpu_rendersystem_dll_name = 41;
     */
    gpuRendersystemDllName?: string;
    /**
     * @generated from protobuf field: optional uint32 gpu_vendor_id = 42;
     */
    gpuVendorId?: number;
    /**
     * @generated from protobuf field: optional string gpu_driver_name = 43;
     */
    gpuDriverName?: string;
    /**
     * @generated from protobuf field: optional uint32 gpu_driver_version_high = 44;
     */
    gpuDriverVersionHigh?: number;
    /**
     * @generated from protobuf field: optional uint32 gpu_driver_version_low = 45;
     */
    gpuDriverVersionLow?: number;
    /**
     * @generated from protobuf field: optional uint32 gpu_dx_support_level = 46;
     */
    gpuDxSupportLevel?: number;
    /**
     * @generated from protobuf field: optional uint32 gpu_texture_memory_size_mb = 47;
     */
    gpuTextureMemorySizeMb?: number;
}
/**
 * @generated from protobuf message CMsgSource2VProfLiteReportItem
 */
export interface CMsgSource2VProfLiteReportItem {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 active_samples = 2;
     */
    activeSamples?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_max = 3;
     */
    usecMax?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_avg_active = 11;
     */
    usecAvgActive?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_p50_active = 12;
     */
    usecP50Active?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_p99_active = 13;
     */
    usecP99Active?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_avg_all = 21;
     */
    usecAvgAll?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_p50_all = 22;
     */
    usecP50All?: number;
    /**
     * @generated from protobuf field: optional uint32 usec_p99_all = 23;
     */
    usecP99All?: number;
}
/**
 * @generated from protobuf message CMsgSource2VProfLiteReport
 */
export interface CMsgSource2VProfLiteReport {
    /**
     * @generated from protobuf field: optional CMsgSource2VProfLiteReportItem total = 1;
     */
    total?: CMsgSource2VProfLiteReportItem;
    /**
     * @generated from protobuf field: repeated CMsgSource2VProfLiteReportItem items = 2;
     */
    items: CMsgSource2VProfLiteReportItem[];
    /**
     * @generated from protobuf field: optional uint32 discarded_frames = 3;
     */
    discardedFrames?: number;
}
/**
 * @generated from protobuf message CCLCMsg_Diagnostic
 */
export interface CCLCMsg_Diagnostic {
    /**
     * @generated from protobuf field: optional CMsgSource2SystemSpecs system_specs = 1;
     */
    systemSpecs?: CMsgSource2SystemSpecs;
    /**
     * @generated from protobuf field: optional CMsgSource2VProfLiteReport vprof_report = 2;
     */
    vprofReport?: CMsgSource2VProfLiteReport;
}
/**
 * @generated from protobuf message CSource2Metrics_MatchPerfSummary_Notification
 */
export interface CSource2Metrics_MatchPerfSummary_Notification {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string game_mode = 2;
     */
    gameMode?: string;
    /**
     * @generated from protobuf field: optional uint32 server_build_id = 3;
     */
    serverBuildId?: number;
    /**
     * @generated from protobuf field: optional CMsgSource2VProfLiteReport server_profile = 10;
     */
    serverProfile?: CMsgSource2VProfLiteReport;
    /**
     * @generated from protobuf field: repeated CSource2Metrics_MatchPerfSummary_Notification.Client clients = 11;
     */
    clients: CSource2Metrics_MatchPerfSummary_Notification_Client[];
    /**
     * @generated from protobuf field: optional string map = 20;
     */
    map?: string;
}
/**
 * @generated from protobuf message CSource2Metrics_MatchPerfSummary_Notification.Client
 */
export interface CSource2Metrics_MatchPerfSummary_Notification_Client {
    /**
     * @generated from protobuf field: optional CMsgSource2SystemSpecs system_specs = 1;
     */
    systemSpecs?: CMsgSource2SystemSpecs;
    /**
     * @generated from protobuf field: optional CMsgSource2VProfLiteReport profile = 2;
     */
    profile?: CMsgSource2VProfLiteReport;
    /**
     * @generated from protobuf field: optional uint32 build_id = 3;
     */
    buildId?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 10;
     */
    steamid?: bigint;
}
/**
 * @generated from protobuf message CSVCMsg_ServerInfo
 */
export interface CSVCMsg_ServerInfo {
    /**
     * @generated from protobuf field: optional int32 protocol = 1;
     */
    protocol?: number;
    /**
     * @generated from protobuf field: optional int32 server_count = 2;
     */
    serverCount?: number;
    /**
     * @generated from protobuf field: optional bool is_dedicated = 3;
     */
    isDedicated?: boolean;
    /**
     * @generated from protobuf field: optional bool is_hltv = 4;
     */
    isHltv?: boolean;
    /**
     * @generated from protobuf field: optional int32 c_os = 6;
     */
    cOs?: number;
    /**
     * @generated from protobuf field: optional int32 max_clients = 10;
     */
    maxClients?: number;
    /**
     * @generated from protobuf field: optional int32 max_classes = 11;
     */
    maxClasses?: number;
    /**
     * @generated from protobuf field: optional int32 player_slot = 12;
     */
    playerSlot?: number;
    /**
     * @generated from protobuf field: optional float tick_interval = 13;
     */
    tickInterval?: number;
    /**
     * @generated from protobuf field: optional string game_dir = 14;
     */
    gameDir?: string;
    /**
     * @generated from protobuf field: optional string map_name = 15;
     */
    mapName?: string;
    /**
     * @generated from protobuf field: optional string sky_name = 16;
     */
    skyName?: string;
    /**
     * @generated from protobuf field: optional string host_name = 17;
     */
    hostName?: string;
    /**
     * @generated from protobuf field: optional string addon_name = 18;
     */
    addonName?: string;
    /**
     * @generated from protobuf field: optional CSVCMsg_GameSessionConfiguration game_session_config = 19;
     */
    gameSessionConfig?: CSVCMsg_GameSessionConfiguration;
    /**
     * @generated from protobuf field: optional bytes game_session_manifest = 20;
     */
    gameSessionManifest?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_ClassInfo
 */
export interface CSVCMsg_ClassInfo {
    /**
     * @generated from protobuf field: optional bool create_on_client = 1;
     */
    createOnClient?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_ClassInfo.class_t classes = 2;
     */
    classes: CSVCMsg_ClassInfo_class_t[];
}
/**
 * @generated from protobuf message CSVCMsg_ClassInfo.class_t
 */
export interface CSVCMsg_ClassInfo_class_t {
    /**
     * @generated from protobuf field: optional int32 class_id = 1;
     */
    classId?: number;
    /**
     * @generated from protobuf field: optional string class_name = 3;
     */
    className?: string;
}
/**
 * @generated from protobuf message CSVCMsg_SetPause
 */
export interface CSVCMsg_SetPause {
    /**
     * @generated from protobuf field: optional bool paused = 1;
     */
    paused?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_VoiceInit
 */
export interface CSVCMsg_VoiceInit {
    /**
     * @generated from protobuf field: optional int32 quality = 1;
     */
    quality?: number;
    /**
     * @generated from protobuf field: optional string codec = 2;
     */
    codec?: string;
    /**
     * @generated from protobuf field: optional int32 version = 3;
     */
    version?: number;
}
/**
 * @generated from protobuf message CSVCMsg_Print
 */
export interface CSVCMsg_Print {
    /**
     * @generated from protobuf field: optional string text = 1;
     */
    text?: string;
}
/**
 * @generated from protobuf message CSVCMsg_Sounds
 */
export interface CSVCMsg_Sounds {
    /**
     * @generated from protobuf field: optional bool reliable_sound = 1;
     */
    reliableSound?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_Sounds.sounddata_t sounds = 2;
     */
    sounds: CSVCMsg_Sounds_sounddata_t[];
}
/**
 * @generated from protobuf message CSVCMsg_Sounds.sounddata_t
 */
export interface CSVCMsg_Sounds_sounddata_t {
    /**
     * @generated from protobuf field: optional sint32 origin_x = 1;
     */
    originX?: number;
    /**
     * @generated from protobuf field: optional sint32 origin_y = 2;
     */
    originY?: number;
    /**
     * @generated from protobuf field: optional sint32 origin_z = 3;
     */
    originZ?: number;
    /**
     * @generated from protobuf field: optional uint32 volume = 4;
     */
    volume?: number;
    /**
     * @generated from protobuf field: optional float delay_value = 5;
     */
    delayValue?: number;
    /**
     * @generated from protobuf field: optional int32 sequence_number = 6;
     */
    sequenceNumber?: number;
    /**
     * @generated from protobuf field: optional int32 entity_index = 7;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 channel = 8;
     */
    channel?: number;
    /**
     * @generated from protobuf field: optional int32 pitch = 9;
     */
    pitch?: number;
    /**
     * @generated from protobuf field: optional int32 flags = 10;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 sound_num = 11;
     */
    soundNum?: number;
    /**
     * @generated from protobuf field: optional fixed32 sound_num_handle = 12;
     */
    soundNumHandle?: number;
    /**
     * @generated from protobuf field: optional int32 speaker_entity = 13;
     */
    speakerEntity?: number;
    /**
     * @generated from protobuf field: optional int32 random_seed = 14;
     */
    randomSeed?: number;
    /**
     * @generated from protobuf field: optional int32 sound_level = 15;
     */
    soundLevel?: number;
    /**
     * @generated from protobuf field: optional bool is_sentence = 16;
     */
    isSentence?: boolean;
    /**
     * @generated from protobuf field: optional bool is_ambient = 17;
     */
    isAmbient?: boolean;
    /**
     * @generated from protobuf field: optional uint32 guid = 18;
     */
    guid?: number;
    /**
     * @generated from protobuf field: optional fixed64 sound_resource_id = 19;
     */
    soundResourceId?: bigint;
}
/**
 * @generated from protobuf message CSVCMsg_Prefetch
 */
export interface CSVCMsg_Prefetch {
    /**
     * @generated from protobuf field: optional int32 sound_index = 1;
     */
    soundIndex?: number;
    /**
     * @generated from protobuf field: optional PrefetchType resource_type = 2;
     */
    resourceType?: PrefetchType;
}
/**
 * @generated from protobuf message CSVCMsg_SetView
 */
export interface CSVCMsg_SetView {
    /**
     * @generated from protobuf field: optional int32 entity_index = 1;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 slot = 2;
     */
    slot?: number;
}
/**
 * @generated from protobuf message CSVCMsg_FixAngle
 */
export interface CSVCMsg_FixAngle {
    /**
     * @generated from protobuf field: optional bool relative = 1;
     */
    relative?: boolean;
    /**
     * @generated from protobuf field: optional CMsgQAngle angle = 2;
     */
    angle?: CMsgQAngle;
}
/**
 * @generated from protobuf message CSVCMsg_CrosshairAngle
 */
export interface CSVCMsg_CrosshairAngle {
    /**
     * @generated from protobuf field: optional CMsgQAngle angle = 1;
     */
    angle?: CMsgQAngle;
}
/**
 * @generated from protobuf message CSVCMsg_BSPDecal
 */
export interface CSVCMsg_BSPDecal {
    /**
     * @generated from protobuf field: optional CMsgVector pos = 1;
     */
    pos?: CMsgVector;
    /**
     * @generated from protobuf field: optional int32 decal_texture_index = 2;
     */
    decalTextureIndex?: number;
    /**
     * @generated from protobuf field: optional int32 entity_index = 3;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 model_index = 4;
     */
    modelIndex?: number;
    /**
     * @generated from protobuf field: optional bool low_priority = 5;
     */
    lowPriority?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_SplitScreen
 */
export interface CSVCMsg_SplitScreen {
    /**
     * @generated from protobuf field: optional ESplitScreenMessageType type = 1;
     */
    type?: ESplitScreenMessageType;
    /**
     * @generated from protobuf field: optional int32 slot = 2;
     */
    slot?: number;
    /**
     * @generated from protobuf field: optional int32 player_index = 3;
     */
    playerIndex?: number;
}
/**
 * @generated from protobuf message CSVCMsg_GetCvarValue
 */
export interface CSVCMsg_GetCvarValue {
    /**
     * @generated from protobuf field: optional int32 cookie = 1;
     */
    cookie?: number;
    /**
     * @generated from protobuf field: optional string cvar_name = 2;
     */
    cvarName?: string;
}
/**
 * @generated from protobuf message CSVCMsg_Menu
 */
export interface CSVCMsg_Menu {
    /**
     * @generated from protobuf field: optional int32 dialog_type = 1;
     */
    dialogType?: number;
    /**
     * @generated from protobuf field: optional bytes menu_key_values = 2;
     */
    menuKeyValues?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_UserMessage
 */
export interface CSVCMsg_UserMessage {
    /**
     * @generated from protobuf field: optional int32 msg_type = 1;
     */
    msgType?: number;
    /**
     * @generated from protobuf field: optional bytes msg_data = 2;
     */
    msgData?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 passthrough = 3;
     */
    passthrough?: number;
}
/**
 * @generated from protobuf message CSVCMsg_SendTable
 */
export interface CSVCMsg_SendTable {
    /**
     * @generated from protobuf field: optional bool is_end = 1;
     */
    isEnd?: boolean;
    /**
     * @generated from protobuf field: optional string net_table_name = 2;
     */
    netTableName?: string;
    /**
     * @generated from protobuf field: optional bool needs_decoder = 3;
     */
    needsDecoder?: boolean;
    /**
     * @generated from protobuf field: repeated CSVCMsg_SendTable.sendprop_t props = 4;
     */
    props: CSVCMsg_SendTable_sendprop_t[];
}
/**
 * @generated from protobuf message CSVCMsg_SendTable.sendprop_t
 */
export interface CSVCMsg_SendTable_sendprop_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string var_name = 2;
     */
    varName?: string;
    /**
     * @generated from protobuf field: optional int32 flags = 3;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional int32 priority = 4;
     */
    priority?: number;
    /**
     * @generated from protobuf field: optional string dt_name = 5;
     */
    dtName?: string;
    /**
     * @generated from protobuf field: optional int32 num_elements = 6;
     */
    numElements?: number;
    /**
     * @generated from protobuf field: optional float low_value = 7;
     */
    lowValue?: number;
    /**
     * @generated from protobuf field: optional float high_value = 8;
     */
    highValue?: number;
    /**
     * @generated from protobuf field: optional int32 num_bits = 9;
     */
    numBits?: number;
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList
 */
export interface CSVCMsg_GameEventList {
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEventList.descriptor_t descriptors = 1;
     */
    descriptors: CSVCMsg_GameEventList_descriptor_t[];
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList.key_t
 */
export interface CSVCMsg_GameEventList_key_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
}
/**
 * @generated from protobuf message CSVCMsg_GameEventList.descriptor_t
 */
export interface CSVCMsg_GameEventList_descriptor_t {
    /**
     * @generated from protobuf field: optional int32 eventid = 1;
     */
    eventid?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEventList.key_t keys = 3;
     */
    keys: CSVCMsg_GameEventList_key_t[];
}
/**
 * @generated from protobuf message CSVCMsg_PacketEntities
 */
export interface CSVCMsg_PacketEntities {
    /**
     * @generated from protobuf field: optional int32 max_entries = 1;
     */
    maxEntries?: number;
    /**
     * @generated from protobuf field: optional int32 updated_entries = 2;
     */
    updatedEntries?: number;
    /**
     * @generated from protobuf field: optional bool legacy_is_delta = 3;
     */
    legacyIsDelta?: boolean;
    /**
     * @generated from protobuf field: optional bool update_baseline = 4;
     */
    updateBaseline?: boolean;
    /**
     * @generated from protobuf field: optional int32 baseline = 5;
     */
    baseline?: number;
    /**
     * @generated from protobuf field: optional int32 delta_from = 6;
     */
    deltaFrom?: number;
    /**
     * @generated from protobuf field: optional bytes entity_data = 7;
     */
    entityData?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool pending_full_frame = 8;
     */
    pendingFullFrame?: boolean;
    /**
     * @generated from protobuf field: optional uint32 active_spawngroup_handle = 9;
     */
    activeSpawngroupHandle?: number;
    /**
     * @generated from protobuf field: optional uint32 max_spawngroup_creationsequence = 10;
     */
    maxSpawngroupCreationsequence?: number;
    /**
     * @generated from protobuf field: optional uint32 last_cmd_number_executed = 11;
     */
    lastCmdNumberExecuted?: number;
    /**
     * @generated from protobuf field: optional sint32 last_cmd_number_recv_delta = 17;
     */
    lastCmdNumberRecvDelta?: number;
    /**
     * @generated from protobuf field: optional uint32 server_tick = 12;
     */
    serverTick?: number;
    /**
     * @generated from protobuf field: optional bytes serialized_entities = 13;
     */
    serializedEntities?: Uint8Array;
    /**
     * @generated from protobuf field: repeated CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
     */
    alternateBaselines: CSVCMsg_PacketEntities_alternate_baseline_t[];
    /**
     * @generated from protobuf field: optional uint32 has_pvs_vis_bits = 16;
     */
    hasPvsVisBits?: number;
    /**
     * @generated from protobuf field: repeated sint32 cmd_recv_status = 22 [packed = true];
     */
    cmdRecvStatus: number[];
    /**
     * @generated from protobuf field: optional CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
     */
    nonTransmittedEntities?: CSVCMsg_PacketEntities_non_transmitted_entities_t;
    /**
     * @generated from protobuf field: optional uint32 cq_starved_command_ticks = 20;
     */
    cqStarvedCommandTicks?: number;
    /**
     * @generated from protobuf field: optional uint32 cq_discarded_command_ticks = 21;
     */
    cqDiscardedCommandTicks?: number;
    /**
     * @generated from protobuf field: optional bytes dev_padding = 999;
     */
    devPadding?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_PacketEntities.alternate_baseline_t
 */
export interface CSVCMsg_PacketEntities_alternate_baseline_t {
    /**
     * @generated from protobuf field: optional int32 entity_index = 1;
     */
    entityIndex?: number;
    /**
     * @generated from protobuf field: optional int32 baseline_index = 2;
     */
    baselineIndex?: number;
}
/**
 * @generated from protobuf message CSVCMsg_PacketEntities.non_transmitted_entities_t
 */
export interface CSVCMsg_PacketEntities_non_transmitted_entities_t {
    /**
     * @generated from protobuf field: optional int32 header_count = 1;
     */
    headerCount?: number;
    /**
     * @generated from protobuf field: optional bytes data = 2;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_TempEntities
 */
export interface CSVCMsg_TempEntities {
    /**
     * @generated from protobuf field: optional bool reliable = 1;
     */
    reliable?: boolean;
    /**
     * @generated from protobuf field: optional int32 num_entries = 2;
     */
    numEntries?: number;
    /**
     * @generated from protobuf field: optional bytes entity_data = 3;
     */
    entityData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_CreateStringTable
 */
export interface CSVCMsg_CreateStringTable {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 num_entries = 2;
     */
    numEntries?: number;
    /**
     * @generated from protobuf field: optional bool user_data_fixed_size = 3;
     */
    userDataFixedSize?: boolean;
    /**
     * @generated from protobuf field: optional int32 user_data_size = 4;
     */
    userDataSize?: number;
    /**
     * @generated from protobuf field: optional int32 user_data_size_bits = 5;
     */
    userDataSizeBits?: number;
    /**
     * @generated from protobuf field: optional int32 flags = 6;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional bytes string_data = 7;
     */
    stringData?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 uncompressed_size = 8;
     */
    uncompressedSize?: number;
    /**
     * @generated from protobuf field: optional bool data_compressed = 9;
     */
    dataCompressed?: boolean;
    /**
     * @generated from protobuf field: optional bool using_varint_bitcounts = 10;
     */
    usingVarintBitcounts?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_UpdateStringTable
 */
export interface CSVCMsg_UpdateStringTable {
    /**
     * @generated from protobuf field: optional int32 table_id = 1;
     */
    tableId?: number;
    /**
     * @generated from protobuf field: optional int32 num_changed_entries = 2;
     */
    numChangedEntries?: number;
    /**
     * @generated from protobuf field: optional bytes string_data = 3;
     */
    stringData?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_VoiceData
 */
export interface CSVCMsg_VoiceData {
    /**
     * @generated from protobuf field: optional CMsgVoiceAudio audio = 1;
     */
    audio?: CMsgVoiceAudio;
    /**
     * @generated from protobuf field: optional int32 client = 2;
     */
    client?: number;
    /**
     * @generated from protobuf field: optional bool proximity = 3;
     */
    proximity?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 xuid = 4;
     */
    xuid?: bigint;
    /**
     * @generated from protobuf field: optional int32 audible_mask = 5;
     */
    audibleMask?: number;
    /**
     * @generated from protobuf field: optional uint32 tick = 6;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional int32 passthrough = 7;
     */
    passthrough?: number;
}
/**
 * @generated from protobuf message CSVCMsg_PacketReliable
 */
export interface CSVCMsg_PacketReliable {
    /**
     * @generated from protobuf field: optional int32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional int32 messagessize = 2;
     */
    messagessize?: number;
    /**
     * @generated from protobuf field: optional bool state = 3;
     */
    state?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_FullFrameSplit
 */
export interface CSVCMsg_FullFrameSplit {
    /**
     * @generated from protobuf field: optional int32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional int32 section = 2;
     */
    section?: number;
    /**
     * @generated from protobuf field: optional int32 total = 3;
     */
    total?: number;
    /**
     * @generated from protobuf field: optional bytes data = 4;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_HLTVStatus
 */
export interface CSVCMsg_HLTVStatus {
    /**
     * @generated from protobuf field: optional string master = 1;
     */
    master?: string;
    /**
     * @generated from protobuf field: optional int32 clients = 2;
     */
    clients?: number;
    /**
     * @generated from protobuf field: optional int32 slots = 3;
     */
    slots?: number;
    /**
     * @generated from protobuf field: optional int32 proxies = 4;
     */
    proxies?: number;
}
/**
 * @generated from protobuf message CSVCMsg_ServerSteamID
 */
export interface CSVCMsg_ServerSteamID {
    /**
     * @generated from protobuf field: optional uint64 steam_id = 1;
     */
    steamId?: bigint;
}
/**
 * @generated from protobuf message CSVCMsg_CmdKeyValues
 */
export interface CSVCMsg_CmdKeyValues {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message CSVCMsg_RconServerDetails
 */
export interface CSVCMsg_RconServerDetails {
    /**
     * @generated from protobuf field: optional bytes token = 1;
     */
    token?: Uint8Array;
    /**
     * @generated from protobuf field: optional string details = 2;
     */
    details?: string;
}
/**
 * @generated from protobuf message CMsgIPCAddress
 */
export interface CMsgIPCAddress {
    /**
     * @generated from protobuf field: optional fixed64 computer_guid = 1;
     */
    computerGuid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 process_id = 2;
     */
    processId?: number;
}
/**
 * @generated from protobuf message CMsgServerPeer
 */
export interface CMsgServerPeer {
    /**
     * @generated from protobuf field: optional int32 player_slot = 1;
     */
    playerSlot?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 2;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional CMsgIPCAddress ipc = 3;
     */
    ipc?: CMsgIPCAddress;
    /**
     * @generated from protobuf field: optional bool they_hear_you = 4;
     */
    theyHearYou?: boolean;
    /**
     * @generated from protobuf field: optional bool you_hear_them = 5;
     */
    youHearThem?: boolean;
    /**
     * @generated from protobuf field: optional bool is_listenserver_host = 6;
     */
    isListenserverHost?: boolean;
}
/**
 * @generated from protobuf message CSVCMsg_PeerList
 */
export interface CSVCMsg_PeerList {
    /**
     * @generated from protobuf field: repeated CMsgServerPeer peer = 1;
     */
    peer: CMsgServerPeer[];
}
/**
 * @generated from protobuf message CSVCMsg_ClearAllStringTables
 */
export interface CSVCMsg_ClearAllStringTables {
    /**
     * @generated from protobuf field: optional string mapname = 1;
     */
    mapname?: string;
    /**
     * @generated from protobuf field: optional bool create_tables_skipped = 3;
     */
    createTablesSkipped?: boolean;
}
/**
 * @generated from protobuf message ProtoFlattenedSerializerField_t
 */
export interface ProtoFlattenedSerializerField_t {
    /**
     * @generated from protobuf field: optional int32 var_type_sym = 1;
     */
    varTypeSym?: number;
    /**
     * @generated from protobuf field: optional int32 var_name_sym = 2;
     */
    varNameSym?: number;
    /**
     * @generated from protobuf field: optional int32 bit_count = 3;
     */
    bitCount?: number;
    /**
     * @generated from protobuf field: optional float low_value = 4;
     */
    lowValue?: number;
    /**
     * @generated from protobuf field: optional float high_value = 5;
     */
    highValue?: number;
    /**
     * @generated from protobuf field: optional int32 encode_flags = 6;
     */
    encodeFlags?: number;
    /**
     * @generated from protobuf field: optional int32 field_serializer_name_sym = 7;
     */
    fieldSerializerNameSym?: number;
    /**
     * @generated from protobuf field: optional int32 field_serializer_version = 8;
     */
    fieldSerializerVersion?: number;
    /**
     * @generated from protobuf field: optional int32 send_node_sym = 9;
     */
    sendNodeSym?: number;
    /**
     * @generated from protobuf field: optional int32 var_encoder_sym = 10;
     */
    varEncoderSym?: number;
    /**
     * @generated from protobuf field: repeated ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
     */
    polymorphicTypes: ProtoFlattenedSerializerField_t_polymorphic_field_t[];
    /**
     * @generated from protobuf field: optional int32 var_serializer_sym = 12;
     */
    varSerializerSym?: number;
}
/**
 * @generated from protobuf message ProtoFlattenedSerializerField_t.polymorphic_field_t
 */
export interface ProtoFlattenedSerializerField_t_polymorphic_field_t {
    /**
     * @generated from protobuf field: optional int32 polymorphic_field_serializer_name_sym = 1;
     */
    polymorphicFieldSerializerNameSym?: number;
    /**
     * @generated from protobuf field: optional int32 polymorphic_field_serializer_version = 2;
     */
    polymorphicFieldSerializerVersion?: number;
}
/**
 * @generated from protobuf message ProtoFlattenedSerializer_t
 */
export interface ProtoFlattenedSerializer_t {
    /**
     * @generated from protobuf field: optional int32 serializer_name_sym = 1;
     */
    serializerNameSym?: number;
    /**
     * @generated from protobuf field: optional int32 serializer_version = 2;
     */
    serializerVersion?: number;
    /**
     * @generated from protobuf field: repeated int32 fields_index = 3;
     */
    fieldsIndex: number[];
}
/**
 * @generated from protobuf message CSVCMsg_FlattenedSerializer
 */
export interface CSVCMsg_FlattenedSerializer {
    /**
     * @generated from protobuf field: repeated ProtoFlattenedSerializer_t serializers = 1;
     */
    serializers: ProtoFlattenedSerializer_t[];
    /**
     * @generated from protobuf field: repeated string symbols = 2;
     */
    symbols: string[];
    /**
     * @generated from protobuf field: repeated ProtoFlattenedSerializerField_t fields = 3;
     */
    fields: ProtoFlattenedSerializerField_t[];
}
/**
 * @generated from protobuf message CSVCMsg_StopSound
 */
export interface CSVCMsg_StopSound {
    /**
     * @generated from protobuf field: optional fixed32 guid = 1;
     */
    guid?: number;
}
/**
 * @generated from protobuf message CBidirMsg_RebroadcastGameEvent
 */
export interface CBidirMsg_RebroadcastGameEvent {
    /**
     * @generated from protobuf field: optional bool posttoserver = 1;
     */
    posttoserver?: boolean;
    /**
     * @generated from protobuf field: optional int32 buftype = 2;
     */
    buftype?: number;
    /**
     * @generated from protobuf field: optional uint32 clientbitcount = 3;
     */
    clientbitcount?: number;
    /**
     * @generated from protobuf field: optional uint64 receivingclients = 4;
     */
    receivingclients?: bigint;
}
/**
 * @generated from protobuf message CBidirMsg_RebroadcastSource
 */
export interface CBidirMsg_RebroadcastSource {
    /**
     * @generated from protobuf field: optional int32 eventsource = 1;
     */
    eventsource?: number;
}
/**
 * @generated from protobuf message CMsgServerNetworkStats
 */
export interface CMsgServerNetworkStats {
    /**
     * @generated from protobuf field: optional bool dedicated = 1;
     */
    dedicated?: boolean;
    /**
     * @generated from protobuf field: optional int32 cpu_usage = 2;
     */
    cpuUsage?: number;
    /**
     * @generated from protobuf field: optional int32 memory_used_mb = 3;
     */
    memoryUsedMb?: number;
    /**
     * @generated from protobuf field: optional int32 memory_free_mb = 4;
     */
    memoryFreeMb?: number;
    /**
     * @generated from protobuf field: optional int32 uptime = 5;
     */
    uptime?: number;
    /**
     * @generated from protobuf field: optional int32 spawn_count = 6;
     */
    spawnCount?: number;
    /**
     * @generated from protobuf field: optional int32 num_clients = 8;
     */
    numClients?: number;
    /**
     * @generated from protobuf field: optional int32 num_bots = 9;
     */
    numBots?: number;
    /**
     * @generated from protobuf field: optional int32 num_spectators = 10;
     */
    numSpectators?: number;
    /**
     * @generated from protobuf field: optional int32 num_tv_relays = 11;
     */
    numTvRelays?: number;
    /**
     * @generated from protobuf field: optional float fps = 12;
     */
    fps?: number;
    /**
     * @generated from protobuf field: repeated CMsgServerNetworkStats.Port ports = 17;
     */
    ports: CMsgServerNetworkStats_Port[];
    /**
     * @generated from protobuf field: optional float avg_ping_ms = 18;
     */
    avgPingMs?: number;
    /**
     * @generated from protobuf field: optional float avg_engine_latency_out = 19;
     */
    avgEngineLatencyOut?: number;
    /**
     * @generated from protobuf field: optional float avg_packets_out = 20;
     */
    avgPacketsOut?: number;
    /**
     * @generated from protobuf field: optional float avg_packets_in = 21;
     */
    avgPacketsIn?: number;
    /**
     * @generated from protobuf field: optional float avg_loss_out = 22;
     */
    avgLossOut?: number;
    /**
     * @generated from protobuf field: optional float avg_loss_in = 23;
     */
    avgLossIn?: number;
    /**
     * @generated from protobuf field: optional float avg_data_out = 24;
     */
    avgDataOut?: number;
    /**
     * @generated from protobuf field: optional float avg_data_in = 25;
     */
    avgDataIn?: number;
    /**
     * @generated from protobuf field: optional uint64 total_data_in = 26;
     */
    totalDataIn?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_packets_in = 27;
     */
    totalPacketsIn?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_data_out = 28;
     */
    totalDataOut?: bigint;
    /**
     * @generated from protobuf field: optional uint64 total_packets_out = 29;
     */
    totalPacketsOut?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgServerNetworkStats.Player players = 30;
     */
    players: CMsgServerNetworkStats_Player[];
}
/**
 * @generated from protobuf message CMsgServerNetworkStats.Port
 */
export interface CMsgServerNetworkStats_Port {
    /**
     * @generated from protobuf field: optional int32 port = 1;
     */
    port?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
}
/**
 * @generated from protobuf message CMsgServerNetworkStats.Player
 */
export interface CMsgServerNetworkStats_Player {
    /**
     * @generated from protobuf field: optional uint64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional string remote_addr = 2;
     */
    remoteAddr?: string;
    /**
     * @generated from protobuf field: optional int32 ping_avg_ms = 4;
     */
    pingAvgMs?: number;
    /**
     * @generated from protobuf field: optional float packet_loss_pct = 5;
     */
    packetLossPct?: number;
    /**
     * @generated from protobuf field: optional bool is_bot = 6;
     */
    isBot?: boolean;
    /**
     * @generated from protobuf field: optional float loss_in = 7;
     */
    lossIn?: number;
    /**
     * @generated from protobuf field: optional float loss_out = 8;
     */
    lossOut?: number;
    /**
     * @generated from protobuf field: optional int32 engine_latency_ms = 9;
     */
    engineLatencyMs?: number;
}
/**
 * @generated from protobuf message CSVCMsg_HltvReplay
 */
export interface CSVCMsg_HltvReplay {
    /**
     * @generated from protobuf field: optional int32 delay = 1;
     */
    delay?: number;
    /**
     * @generated from protobuf field: optional int32 primary_target = 2;
     */
    primaryTarget?: number;
    /**
     * @generated from protobuf field: optional int32 replay_stop_at = 3;
     */
    replayStopAt?: number;
    /**
     * @generated from protobuf field: optional int32 replay_start_at = 4;
     */
    replayStartAt?: number;
    /**
     * @generated from protobuf field: optional int32 replay_slowdown_begin = 5;
     */
    replaySlowdownBegin?: number;
    /**
     * @generated from protobuf field: optional int32 replay_slowdown_end = 6;
     */
    replaySlowdownEnd?: number;
    /**
     * @generated from protobuf field: optional float replay_slowdown_rate = 7;
     */
    replaySlowdownRate?: number;
    /**
     * @generated from protobuf field: optional int32 reason = 8;
     */
    reason?: number;
}
/**
 * @generated from protobuf message CCLCMsg_HltvReplay
 */
export interface CCLCMsg_HltvReplay {
    /**
     * @generated from protobuf field: optional int32 request = 1;
     */
    request?: number;
    /**
     * @generated from protobuf field: optional float slowdown_length = 2;
     */
    slowdownLength?: number;
    /**
     * @generated from protobuf field: optional float slowdown_rate = 3;
     */
    slowdownRate?: number;
    /**
     * @generated from protobuf field: optional int32 primary_target = 4;
     */
    primaryTarget?: number;
    /**
     * @generated from protobuf field: optional float event_time = 5;
     */
    eventTime?: number;
}
/**
 * @generated from protobuf message CSVCMsg_Broadcast_Command
 */
export interface CSVCMsg_Broadcast_Command {
    /**
     * @generated from protobuf field: optional string cmd = 1;
     */
    cmd?: string;
}
/**
 * @generated from protobuf message CCLCMsg_HltvFixupOperatorTick
 */
export interface CCLCMsg_HltvFixupOperatorTick {
    /**
     * @generated from protobuf field: optional int32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional bytes props_data = 2;
     */
    propsData?: Uint8Array;
    /**
     * @generated from protobuf field: optional CMsgVector origin = 3;
     */
    origin?: CMsgVector;
    /**
     * @generated from protobuf field: optional CMsgQAngle eye_angles = 4;
     */
    eyeAngles?: CMsgQAngle;
    /**
     * @generated from protobuf field: optional int32 observer_mode = 5;
     */
    observerMode?: number;
    /**
     * @generated from protobuf field: optional bool cameraman_scoreboard = 6;
     */
    cameramanScoreboard?: boolean;
    /**
     * @generated from protobuf field: optional int32 observer_target = 7;
     */
    observerTarget?: number;
    /**
     * @generated from protobuf field: optional CMsgVector view_offset = 8;
     */
    viewOffset?: CMsgVector;
}
/**
 * @generated from protobuf message CSVCMsg_HltvFixupOperatorStatus
 */
export interface CSVCMsg_HltvFixupOperatorStatus {
    /**
     * @generated from protobuf field: optional uint32 mode = 1;
     */
    mode?: number;
    /**
     * @generated from protobuf field: optional string override_operator_name = 2;
     */
    overrideOperatorName?: string;
}
/**
 * @generated from protobuf message CMsgServerUserCmd
 */
export interface CMsgServerUserCmd {
    /**
     * @generated from protobuf field: optional bytes data = 1;
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional int32 cmd_number = 2;
     */
    cmdNumber?: number;
    /**
     * @generated from protobuf field: optional int32 player_slot = 3;
     */
    playerSlot?: number;
    /**
     * @generated from protobuf field: optional int32 server_tick_executed = 4;
     */
    serverTickExecuted?: number;
    /**
     * @generated from protobuf field: optional int32 client_tick = 5;
     */
    clientTick?: number;
}
/**
 * @generated from protobuf message CSVCMsg_UserCommands
 */
export interface CSVCMsg_UserCommands {
    /**
     * @generated from protobuf field: repeated CMsgServerUserCmd commands = 1;
     */
    commands: CMsgServerUserCmd[];
}
/**
 * @generated from protobuf enum CLC_Messages
 */
export enum CLC_Messages {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: clc_ClientInfo = 20;
     */
    clc_ClientInfo = 20,
    /**
     * @generated from protobuf enum value: clc_Move = 21;
     */
    clc_Move = 21,
    /**
     * @generated from protobuf enum value: clc_VoiceData = 22;
     */
    clc_VoiceData = 22,
    /**
     * @generated from protobuf enum value: clc_BaselineAck = 23;
     */
    clc_BaselineAck = 23,
    /**
     * @generated from protobuf enum value: clc_RespondCvarValue = 25;
     */
    clc_RespondCvarValue = 25,
    /**
     * @generated from protobuf enum value: clc_FileCRCCheck = 26;
     */
    clc_FileCRCCheck = 26,
    /**
     * @generated from protobuf enum value: clc_LoadingProgress = 27;
     */
    clc_LoadingProgress = 27,
    /**
     * @generated from protobuf enum value: clc_SplitPlayerConnect = 28;
     */
    clc_SplitPlayerConnect = 28,
    /**
     * @generated from protobuf enum value: clc_SplitPlayerDisconnect = 30;
     */
    clc_SplitPlayerDisconnect = 30,
    /**
     * @generated from protobuf enum value: clc_ServerStatus = 31;
     */
    clc_ServerStatus = 31,
    /**
     * @generated from protobuf enum value: clc_RequestPause = 33;
     */
    clc_RequestPause = 33,
    /**
     * @generated from protobuf enum value: clc_CmdKeyValues = 34;
     */
    clc_CmdKeyValues = 34,
    /**
     * @generated from protobuf enum value: clc_RconServerDetails = 35;
     */
    clc_RconServerDetails = 35,
    /**
     * @generated from protobuf enum value: clc_HltvReplay = 36;
     */
    clc_HltvReplay = 36,
    /**
     * @generated from protobuf enum value: clc_Diagnostic = 37;
     */
    clc_Diagnostic = 37
}
/**
 * @generated from protobuf enum SVC_Messages
 */
export enum SVC_Messages {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: svc_ServerInfo = 40;
     */
    svc_ServerInfo = 40,
    /**
     * @generated from protobuf enum value: svc_FlattenedSerializer = 41;
     */
    svc_FlattenedSerializer = 41,
    /**
     * @generated from protobuf enum value: svc_ClassInfo = 42;
     */
    svc_ClassInfo = 42,
    /**
     * @generated from protobuf enum value: svc_SetPause = 43;
     */
    svc_SetPause = 43,
    /**
     * @generated from protobuf enum value: svc_CreateStringTable = 44;
     */
    svc_CreateStringTable = 44,
    /**
     * @generated from protobuf enum value: svc_UpdateStringTable = 45;
     */
    svc_UpdateStringTable = 45,
    /**
     * @generated from protobuf enum value: svc_VoiceInit = 46;
     */
    svc_VoiceInit = 46,
    /**
     * @generated from protobuf enum value: svc_VoiceData = 47;
     */
    svc_VoiceData = 47,
    /**
     * @generated from protobuf enum value: svc_Print = 48;
     */
    svc_Print = 48,
    /**
     * @generated from protobuf enum value: svc_Sounds = 49;
     */
    svc_Sounds = 49,
    /**
     * @generated from protobuf enum value: svc_SetView = 50;
     */
    svc_SetView = 50,
    /**
     * @generated from protobuf enum value: svc_ClearAllStringTables = 51;
     */
    svc_ClearAllStringTables = 51,
    /**
     * @generated from protobuf enum value: svc_CmdKeyValues = 52;
     */
    svc_CmdKeyValues = 52,
    /**
     * @generated from protobuf enum value: svc_BSPDecal = 53;
     */
    svc_BSPDecal = 53,
    /**
     * @generated from protobuf enum value: svc_SplitScreen = 54;
     */
    svc_SplitScreen = 54,
    /**
     * @generated from protobuf enum value: svc_PacketEntities = 55;
     */
    svc_PacketEntities = 55,
    /**
     * @generated from protobuf enum value: svc_Prefetch = 56;
     */
    svc_Prefetch = 56,
    /**
     * @generated from protobuf enum value: svc_Menu = 57;
     */
    svc_Menu = 57,
    /**
     * @generated from protobuf enum value: svc_GetCvarValue = 58;
     */
    svc_GetCvarValue = 58,
    /**
     * @generated from protobuf enum value: svc_StopSound = 59;
     */
    svc_StopSound = 59,
    /**
     * @generated from protobuf enum value: svc_PeerList = 60;
     */
    svc_PeerList = 60,
    /**
     * @generated from protobuf enum value: svc_PacketReliable = 61;
     */
    svc_PacketReliable = 61,
    /**
     * @generated from protobuf enum value: svc_HLTVStatus = 62;
     */
    svc_HLTVStatus = 62,
    /**
     * @generated from protobuf enum value: svc_ServerSteamID = 63;
     */
    svc_ServerSteamID = 63,
    /**
     * @generated from protobuf enum value: svc_FullFrameSplit = 70;
     */
    svc_FullFrameSplit = 70,
    /**
     * @generated from protobuf enum value: svc_RconServerDetails = 71;
     */
    svc_RconServerDetails = 71,
    /**
     * @generated from protobuf enum value: svc_UserMessage = 72;
     */
    svc_UserMessage = 72,
    /**
     * @generated from protobuf enum value: svc_Broadcast_Command = 74;
     */
    svc_Broadcast_Command = 74,
    /**
     * @generated from protobuf enum value: svc_HltvFixupOperatorStatus = 75;
     */
    svc_HltvFixupOperatorStatus = 75,
    /**
     * @generated from protobuf enum value: svc_UserCmds = 76;
     */
    svc_UserCmds = 76
}
/**
 * @generated from protobuf enum VoiceDataFormat_t
 */
export enum VoiceDataFormat_t {
    /**
     * @generated from protobuf enum value: VOICEDATA_FORMAT_STEAM = 0;
     */
    VOICEDATA_FORMAT_STEAM = 0,
    /**
     * @generated from protobuf enum value: VOICEDATA_FORMAT_ENGINE = 1;
     */
    VOICEDATA_FORMAT_ENGINE = 1,
    /**
     * @generated from protobuf enum value: VOICEDATA_FORMAT_OPUS = 2;
     */
    VOICEDATA_FORMAT_OPUS = 2
}
/**
 * @generated from protobuf enum RequestPause_t
 */
export enum RequestPause_t {
    /**
     * @generated from protobuf enum value: RP_PAUSE = 0;
     */
    RP_PAUSE = 0,
    /**
     * @generated from protobuf enum value: RP_UNPAUSE = 1;
     */
    RP_UNPAUSE = 1,
    /**
     * @generated from protobuf enum value: RP_TOGGLEPAUSE = 2;
     */
    RP_TOGGLEPAUSE = 2
}
/**
 * @generated from protobuf enum PrefetchType
 */
export enum PrefetchType {
    /**
     * @generated from protobuf enum value: PFT_SOUND = 0;
     */
    PFT_SOUND = 0
}
/**
 * @generated from protobuf enum ESplitScreenMessageType
 */
export enum ESplitScreenMessageType {
    /**
     * @generated from protobuf enum value: MSG_SPLITSCREEN_ADDUSER = 0;
     */
    MSG_SPLITSCREEN_ADDUSER = 0,
    /**
     * @generated from protobuf enum value: MSG_SPLITSCREEN_REMOVEUSER = 1;
     */
    MSG_SPLITSCREEN_REMOVEUSER = 1
}
/**
 * @generated from protobuf enum EQueryCvarValueStatus
 */
export enum EQueryCvarValueStatus {
    /**
     * @generated from protobuf enum value: eQueryCvarValueStatus_ValueIntact = 0;
     */
    eQueryCvarValueStatus_ValueIntact = 0,
    /**
     * @generated from protobuf enum value: eQueryCvarValueStatus_CvarNotFound = 1;
     */
    eQueryCvarValueStatus_CvarNotFound = 1,
    /**
     * @generated from protobuf enum value: eQueryCvarValueStatus_NotACvar = 2;
     */
    eQueryCvarValueStatus_NotACvar = 2,
    /**
     * @generated from protobuf enum value: eQueryCvarValueStatus_CvarProtected = 3;
     */
    eQueryCvarValueStatus_CvarProtected = 3
}
/**
 * @generated from protobuf enum DIALOG_TYPE
 */
export enum DIALOG_TYPE {
    /**
     * @generated from protobuf enum value: DIALOG_MSG = 0;
     */
    DIALOG_MSG = 0,
    /**
     * @generated from protobuf enum value: DIALOG_MENU = 1;
     */
    DIALOG_MENU = 1,
    /**
     * @generated from protobuf enum value: DIALOG_TEXT = 2;
     */
    DIALOG_TEXT = 2,
    /**
     * @generated from protobuf enum value: DIALOG_ENTRY = 3;
     */
    DIALOG_ENTRY = 3,
    /**
     * @generated from protobuf enum value: DIALOG_ASKCONNECT = 4;
     */
    DIALOG_ASKCONNECT = 4
}
/**
 * @generated from protobuf enum SVC_Messages_LowFrequency
 */
export enum SVC_Messages_LowFrequency {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: svc_dummy = 600;
     */
    svc_dummy = 600
}
/**
 * @generated from protobuf enum Bidirectional_Messages
 */
export enum Bidirectional_Messages {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: bi_RebroadcastGameEvent = 16;
     */
    bi_RebroadcastGameEvent = 16,
    /**
     * @generated from protobuf enum value: bi_RebroadcastSource = 17;
     */
    bi_RebroadcastSource = 17,
    /**
     * @generated from protobuf enum value: bi_GameEvent = 18;
     */
    bi_GameEvent = 18
}
/**
 * @generated from protobuf enum Bidirectional_Messages_LowFrequency
 */
export enum Bidirectional_Messages_LowFrequency {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: bi_RelayInfo = 700;
     */
    bi_RelayInfo = 700,
    /**
     * @generated from protobuf enum value: bi_RelayPacket = 701;
     */
    bi_RelayPacket = 701
}
/**
 * @generated from protobuf enum ReplayEventType_t
 */
export enum ReplayEventType_t {
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_CANCEL = 0;
     */
    REPLAY_EVENT_CANCEL = 0,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_DEATH = 1;
     */
    REPLAY_EVENT_DEATH = 1,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_GENERIC = 2;
     */
    REPLAY_EVENT_GENERIC = 2,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3;
     */
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
    /**
     * @generated from protobuf enum value: REPLAY_EVENT_VICTORY = 4;
     */
    REPLAY_EVENT_VICTORY = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_ClientInfo$Type extends MessageType<CCLCMsg_ClientInfo> {
    constructor() {
        super("CCLCMsg_ClientInfo", [
            { no: 1, name: "send_table_crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "server_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_hltv", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "friends_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "friends_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_ClientInfo>): CCLCMsg_ClientInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_ClientInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_ClientInfo): CCLCMsg_ClientInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 send_table_crc */ 1:
                    message.sendTableCrc = reader.fixed32();
                    break;
                case /* optional uint32 server_count */ 2:
                    message.serverCount = reader.uint32();
                    break;
                case /* optional bool is_hltv */ 3:
                    message.isHltv = reader.bool();
                    break;
                case /* optional uint32 friends_id */ 5:
                    message.friendsId = reader.uint32();
                    break;
                case /* optional string friends_name */ 6:
                    message.friendsName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_ClientInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 send_table_crc = 1; */
        if (message.sendTableCrc !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.sendTableCrc);
        /* optional uint32 server_count = 2; */
        if (message.serverCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.serverCount);
        /* optional bool is_hltv = 3; */
        if (message.isHltv !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isHltv);
        /* optional uint32 friends_id = 5; */
        if (message.friendsId !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.friendsId);
        /* optional string friends_name = 6; */
        if (message.friendsName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.friendsName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_ClientInfo
 */
export const CCLCMsg_ClientInfo = new CCLCMsg_ClientInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_Move$Type extends MessageType<CCLCMsg_Move> {
    constructor() {
        super("CCLCMsg_Move", [
            { no: 3, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "last_command_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_Move>): CCLCMsg_Move {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_Move>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_Move): CCLCMsg_Move {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* optional uint32 last_command_number */ 4:
                    message.lastCommandNumber = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_Move, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 3; */
        if (message.data !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* optional uint32 last_command_number = 4; */
        if (message.lastCommandNumber !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.lastCommandNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_Move
 */
export const CCLCMsg_Move = new CCLCMsg_Move$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgVoiceAudio$Type extends MessageType<CMsgVoiceAudio> {
    constructor() {
        super("CMsgVoiceAudio", [
            { no: 1, name: "format", kind: "enum", opt: true, T: () => ["VoiceDataFormat_t", VoiceDataFormat_t] },
            { no: 2, name: "voice_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "sequence_bytes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "section_number", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sample_rate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "uncompressed_sample_offset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "num_packets", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "packet_offsets", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "voice_level", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgVoiceAudio>): CMsgVoiceAudio {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packetOffsets = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgVoiceAudio>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgVoiceAudio): CMsgVoiceAudio {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional VoiceDataFormat_t format */ 1:
                    message.format = reader.int32();
                    break;
                case /* optional bytes voice_data */ 2:
                    message.voiceData = reader.bytes();
                    break;
                case /* optional int32 sequence_bytes */ 3:
                    message.sequenceBytes = reader.int32();
                    break;
                case /* optional uint32 section_number */ 4:
                    message.sectionNumber = reader.uint32();
                    break;
                case /* optional uint32 sample_rate */ 5:
                    message.sampleRate = reader.uint32();
                    break;
                case /* optional uint32 uncompressed_sample_offset */ 6:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                case /* optional uint32 num_packets */ 7:
                    message.numPackets = reader.uint32();
                    break;
                case /* repeated uint32 packet_offsets = 8 [packed = true];*/ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packetOffsets.push(reader.uint32());
                    else
                        message.packetOffsets.push(reader.uint32());
                    break;
                case /* optional float voice_level */ 9:
                    message.voiceLevel = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgVoiceAudio, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional VoiceDataFormat_t format = 1; */
        if (message.format !== undefined)
            writer.tag(1, WireType.Varint).int32(message.format);
        /* optional bytes voice_data = 2; */
        if (message.voiceData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.voiceData);
        /* optional int32 sequence_bytes = 3; */
        if (message.sequenceBytes !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sequenceBytes);
        /* optional uint32 section_number = 4; */
        if (message.sectionNumber !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.sectionNumber);
        /* optional uint32 sample_rate = 5; */
        if (message.sampleRate !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.sampleRate);
        /* optional uint32 uncompressed_sample_offset = 6; */
        if (message.uncompressedSampleOffset !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.uncompressedSampleOffset);
        /* optional uint32 num_packets = 7; */
        if (message.numPackets !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.numPackets);
        /* repeated uint32 packet_offsets = 8 [packed = true]; */
        if (message.packetOffsets.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packetOffsets.length; i++)
                writer.uint32(message.packetOffsets[i]);
            writer.join();
        }
        /* optional float voice_level = 9; */
        if (message.voiceLevel !== undefined)
            writer.tag(9, WireType.Bit32).float(message.voiceLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgVoiceAudio
 */
export const CMsgVoiceAudio = new CMsgVoiceAudio$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_VoiceData$Type extends MessageType<CCLCMsg_VoiceData> {
    constructor() {
        super("CCLCMsg_VoiceData", [
            { no: 1, name: "audio", kind: "message", T: () => CMsgVoiceAudio },
            { no: 2, name: "xuid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_VoiceData>): CCLCMsg_VoiceData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_VoiceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_VoiceData): CCLCMsg_VoiceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgVoiceAudio audio */ 1:
                    message.audio = CMsgVoiceAudio.internalBinaryRead(reader, reader.uint32(), options, message.audio);
                    break;
                case /* optional fixed64 xuid */ 2:
                    message.xuid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 tick */ 3:
                    message.tick = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_VoiceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgVoiceAudio audio = 1; */
        if (message.audio)
            CMsgVoiceAudio.internalBinaryWrite(message.audio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 xuid = 2; */
        if (message.xuid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.xuid);
        /* optional uint32 tick = 3; */
        if (message.tick !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.tick);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_VoiceData
 */
export const CCLCMsg_VoiceData = new CCLCMsg_VoiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_BaselineAck$Type extends MessageType<CCLCMsg_BaselineAck> {
    constructor() {
        super("CCLCMsg_BaselineAck", [
            { no: 1, name: "baseline_tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "baseline_nr", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_BaselineAck>): CCLCMsg_BaselineAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_BaselineAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_BaselineAck): CCLCMsg_BaselineAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 baseline_tick */ 1:
                    message.baselineTick = reader.int32();
                    break;
                case /* optional int32 baseline_nr */ 2:
                    message.baselineNr = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_BaselineAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 baseline_tick = 1; */
        if (message.baselineTick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.baselineTick);
        /* optional int32 baseline_nr = 2; */
        if (message.baselineNr !== undefined)
            writer.tag(2, WireType.Varint).int32(message.baselineNr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_BaselineAck
 */
export const CCLCMsg_BaselineAck = new CCLCMsg_BaselineAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_ListenEvents$Type extends MessageType<CCLCMsg_ListenEvents> {
    constructor() {
        super("CCLCMsg_ListenEvents", [
            { no: 1, name: "event_mask", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_ListenEvents>): CCLCMsg_ListenEvents {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventMask = [];
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_ListenEvents>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_ListenEvents): CCLCMsg_ListenEvents {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed32 event_mask */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eventMask.push(reader.fixed32());
                    else
                        message.eventMask.push(reader.fixed32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_ListenEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed32 event_mask = 1; */
        for (let i = 0; i < message.eventMask.length; i++)
            writer.tag(1, WireType.Bit32).fixed32(message.eventMask[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_ListenEvents
 */
export const CCLCMsg_ListenEvents = new CCLCMsg_ListenEvents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_RespondCvarValue$Type extends MessageType<CCLCMsg_RespondCvarValue> {
    constructor() {
        super("CCLCMsg_RespondCvarValue", [
            { no: 1, name: "cookie", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status_code", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_RespondCvarValue>): CCLCMsg_RespondCvarValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_RespondCvarValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_RespondCvarValue): CCLCMsg_RespondCvarValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cookie */ 1:
                    message.cookie = reader.int32();
                    break;
                case /* optional int32 status_code */ 2:
                    message.statusCode = reader.int32();
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 4:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_RespondCvarValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cookie = 1; */
        if (message.cookie !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cookie);
        /* optional int32 status_code = 2; */
        if (message.statusCode !== undefined)
            writer.tag(2, WireType.Varint).int32(message.statusCode);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional string value = 4; */
        if (message.value !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_RespondCvarValue
 */
export const CCLCMsg_RespondCvarValue = new CCLCMsg_RespondCvarValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_FileCRCCheck$Type extends MessageType<CCLCMsg_FileCRCCheck> {
    constructor() {
        super("CCLCMsg_FileCRCCheck", [
            { no: 1, name: "code_path", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code_filename", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "crc", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_FileCRCCheck>): CCLCMsg_FileCRCCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_FileCRCCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_FileCRCCheck): CCLCMsg_FileCRCCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 code_path */ 1:
                    message.codePath = reader.int32();
                    break;
                case /* optional string path */ 2:
                    message.path = reader.string();
                    break;
                case /* optional int32 code_filename */ 3:
                    message.codeFilename = reader.int32();
                    break;
                case /* optional string filename */ 4:
                    message.filename = reader.string();
                    break;
                case /* optional fixed32 crc */ 5:
                    message.crc = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_FileCRCCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 code_path = 1; */
        if (message.codePath !== undefined)
            writer.tag(1, WireType.Varint).int32(message.codePath);
        /* optional string path = 2; */
        if (message.path !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* optional int32 code_filename = 3; */
        if (message.codeFilename !== undefined)
            writer.tag(3, WireType.Varint).int32(message.codeFilename);
        /* optional string filename = 4; */
        if (message.filename !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.filename);
        /* optional fixed32 crc = 5; */
        if (message.crc !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.crc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_FileCRCCheck
 */
export const CCLCMsg_FileCRCCheck = new CCLCMsg_FileCRCCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_LoadingProgress$Type extends MessageType<CCLCMsg_LoadingProgress> {
    constructor() {
        super("CCLCMsg_LoadingProgress", [
            { no: 1, name: "progress", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_LoadingProgress>): CCLCMsg_LoadingProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_LoadingProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_LoadingProgress): CCLCMsg_LoadingProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 progress */ 1:
                    message.progress = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_LoadingProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 progress = 1; */
        if (message.progress !== undefined)
            writer.tag(1, WireType.Varint).int32(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_LoadingProgress
 */
export const CCLCMsg_LoadingProgress = new CCLCMsg_LoadingProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_SplitPlayerConnect$Type extends MessageType<CCLCMsg_SplitPlayerConnect> {
    constructor() {
        super("CCLCMsg_SplitPlayerConnect", [
            { no: 1, name: "playername", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_SplitPlayerConnect>): CCLCMsg_SplitPlayerConnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_SplitPlayerConnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_SplitPlayerConnect): CCLCMsg_SplitPlayerConnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string playername */ 1:
                    message.playername = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_SplitPlayerConnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string playername = 1; */
        if (message.playername !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.playername);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_SplitPlayerConnect
 */
export const CCLCMsg_SplitPlayerConnect = new CCLCMsg_SplitPlayerConnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_SplitPlayerDisconnect$Type extends MessageType<CCLCMsg_SplitPlayerDisconnect> {
    constructor() {
        super("CCLCMsg_SplitPlayerDisconnect", [
            { no: 1, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_SplitPlayerDisconnect>): CCLCMsg_SplitPlayerDisconnect {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_SplitPlayerDisconnect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_SplitPlayerDisconnect): CCLCMsg_SplitPlayerDisconnect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_SplitPlayerDisconnect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 slot = 1; */
        if (message.slot !== undefined)
            writer.tag(1, WireType.Varint).int32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_SplitPlayerDisconnect
 */
export const CCLCMsg_SplitPlayerDisconnect = new CCLCMsg_SplitPlayerDisconnect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_ServerStatus$Type extends MessageType<CCLCMsg_ServerStatus> {
    constructor() {
        super("CCLCMsg_ServerStatus", [
            { no: 1, name: "simplified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_ServerStatus>): CCLCMsg_ServerStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_ServerStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_ServerStatus): CCLCMsg_ServerStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool simplified */ 1:
                    message.simplified = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_ServerStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool simplified = 1; */
        if (message.simplified !== undefined)
            writer.tag(1, WireType.Varint).bool(message.simplified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_ServerStatus
 */
export const CCLCMsg_ServerStatus = new CCLCMsg_ServerStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_RequestPause$Type extends MessageType<CCLCMsg_RequestPause> {
    constructor() {
        super("CCLCMsg_RequestPause", [
            { no: 1, name: "pause_type", kind: "enum", opt: true, T: () => ["RequestPause_t", RequestPause_t] },
            { no: 2, name: "pause_group", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_RequestPause>): CCLCMsg_RequestPause {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_RequestPause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_RequestPause): CCLCMsg_RequestPause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional RequestPause_t pause_type */ 1:
                    message.pauseType = reader.int32();
                    break;
                case /* optional int32 pause_group */ 2:
                    message.pauseGroup = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_RequestPause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional RequestPause_t pause_type = 1; */
        if (message.pauseType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.pauseType);
        /* optional int32 pause_group = 2; */
        if (message.pauseGroup !== undefined)
            writer.tag(2, WireType.Varint).int32(message.pauseGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_RequestPause
 */
export const CCLCMsg_RequestPause = new CCLCMsg_RequestPause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_CmdKeyValues$Type extends MessageType<CCLCMsg_CmdKeyValues> {
    constructor() {
        super("CCLCMsg_CmdKeyValues", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_CmdKeyValues>): CCLCMsg_CmdKeyValues {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_CmdKeyValues>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_CmdKeyValues): CCLCMsg_CmdKeyValues {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_CmdKeyValues, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_CmdKeyValues
 */
export const CCLCMsg_CmdKeyValues = new CCLCMsg_CmdKeyValues$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_RconServerDetails$Type extends MessageType<CCLCMsg_RconServerDetails> {
    constructor() {
        super("CCLCMsg_RconServerDetails", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_RconServerDetails>): CCLCMsg_RconServerDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_RconServerDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_RconServerDetails): CCLCMsg_RconServerDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes token */ 1:
                    message.token = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_RconServerDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_RconServerDetails
 */
export const CCLCMsg_RconServerDetails = new CCLCMsg_RconServerDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSource2SystemSpecs$Type extends MessageType<CMsgSource2SystemSpecs> {
    constructor() {
        super("CMsgSource2SystemSpecs", [
            { no: 1, name: "cpu_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cpu_brand", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cpu_model", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cpu_num_physical", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "ram_physical_total_mb", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "gpu_rendersystem_dll_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "gpu_vendor_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 43, name: "gpu_driver_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 44, name: "gpu_driver_version_high", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 45, name: "gpu_driver_version_low", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 46, name: "gpu_dx_support_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 47, name: "gpu_texture_memory_size_mb", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSource2SystemSpecs>): CMsgSource2SystemSpecs {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSource2SystemSpecs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSource2SystemSpecs): CMsgSource2SystemSpecs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string cpu_id */ 1:
                    message.cpuId = reader.string();
                    break;
                case /* optional string cpu_brand */ 2:
                    message.cpuBrand = reader.string();
                    break;
                case /* optional uint32 cpu_model */ 3:
                    message.cpuModel = reader.uint32();
                    break;
                case /* optional uint32 cpu_num_physical */ 4:
                    message.cpuNumPhysical = reader.uint32();
                    break;
                case /* optional uint32 ram_physical_total_mb */ 21:
                    message.ramPhysicalTotalMb = reader.uint32();
                    break;
                case /* optional string gpu_rendersystem_dll_name */ 41:
                    message.gpuRendersystemDllName = reader.string();
                    break;
                case /* optional uint32 gpu_vendor_id */ 42:
                    message.gpuVendorId = reader.uint32();
                    break;
                case /* optional string gpu_driver_name */ 43:
                    message.gpuDriverName = reader.string();
                    break;
                case /* optional uint32 gpu_driver_version_high */ 44:
                    message.gpuDriverVersionHigh = reader.uint32();
                    break;
                case /* optional uint32 gpu_driver_version_low */ 45:
                    message.gpuDriverVersionLow = reader.uint32();
                    break;
                case /* optional uint32 gpu_dx_support_level */ 46:
                    message.gpuDxSupportLevel = reader.uint32();
                    break;
                case /* optional uint32 gpu_texture_memory_size_mb */ 47:
                    message.gpuTextureMemorySizeMb = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSource2SystemSpecs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string cpu_id = 1; */
        if (message.cpuId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.cpuId);
        /* optional string cpu_brand = 2; */
        if (message.cpuBrand !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cpuBrand);
        /* optional uint32 cpu_model = 3; */
        if (message.cpuModel !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.cpuModel);
        /* optional uint32 cpu_num_physical = 4; */
        if (message.cpuNumPhysical !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.cpuNumPhysical);
        /* optional uint32 ram_physical_total_mb = 21; */
        if (message.ramPhysicalTotalMb !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.ramPhysicalTotalMb);
        /* optional string gpu_rendersystem_dll_name = 41; */
        if (message.gpuRendersystemDllName !== undefined)
            writer.tag(41, WireType.LengthDelimited).string(message.gpuRendersystemDllName);
        /* optional uint32 gpu_vendor_id = 42; */
        if (message.gpuVendorId !== undefined)
            writer.tag(42, WireType.Varint).uint32(message.gpuVendorId);
        /* optional string gpu_driver_name = 43; */
        if (message.gpuDriverName !== undefined)
            writer.tag(43, WireType.LengthDelimited).string(message.gpuDriverName);
        /* optional uint32 gpu_driver_version_high = 44; */
        if (message.gpuDriverVersionHigh !== undefined)
            writer.tag(44, WireType.Varint).uint32(message.gpuDriverVersionHigh);
        /* optional uint32 gpu_driver_version_low = 45; */
        if (message.gpuDriverVersionLow !== undefined)
            writer.tag(45, WireType.Varint).uint32(message.gpuDriverVersionLow);
        /* optional uint32 gpu_dx_support_level = 46; */
        if (message.gpuDxSupportLevel !== undefined)
            writer.tag(46, WireType.Varint).uint32(message.gpuDxSupportLevel);
        /* optional uint32 gpu_texture_memory_size_mb = 47; */
        if (message.gpuTextureMemorySizeMb !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.gpuTextureMemorySizeMb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSource2SystemSpecs
 */
export const CMsgSource2SystemSpecs = new CMsgSource2SystemSpecs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSource2VProfLiteReportItem$Type extends MessageType<CMsgSource2VProfLiteReportItem> {
    constructor() {
        super("CMsgSource2VProfLiteReportItem", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_samples", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "usec_max", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "usec_avg_active", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "usec_p50_active", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "usec_p99_active", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "usec_avg_all", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "usec_p50_all", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "usec_p99_all", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSource2VProfLiteReportItem>): CMsgSource2VProfLiteReportItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSource2VProfLiteReportItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSource2VProfLiteReportItem): CMsgSource2VProfLiteReportItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional uint32 active_samples */ 2:
                    message.activeSamples = reader.uint32();
                    break;
                case /* optional uint32 usec_max */ 3:
                    message.usecMax = reader.uint32();
                    break;
                case /* optional uint32 usec_avg_active */ 11:
                    message.usecAvgActive = reader.uint32();
                    break;
                case /* optional uint32 usec_p50_active */ 12:
                    message.usecP50Active = reader.uint32();
                    break;
                case /* optional uint32 usec_p99_active */ 13:
                    message.usecP99Active = reader.uint32();
                    break;
                case /* optional uint32 usec_avg_all */ 21:
                    message.usecAvgAll = reader.uint32();
                    break;
                case /* optional uint32 usec_p50_all */ 22:
                    message.usecP50All = reader.uint32();
                    break;
                case /* optional uint32 usec_p99_all */ 23:
                    message.usecP99All = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSource2VProfLiteReportItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional uint32 active_samples = 2; */
        if (message.activeSamples !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.activeSamples);
        /* optional uint32 usec_max = 3; */
        if (message.usecMax !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.usecMax);
        /* optional uint32 usec_avg_active = 11; */
        if (message.usecAvgActive !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.usecAvgActive);
        /* optional uint32 usec_p50_active = 12; */
        if (message.usecP50Active !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.usecP50Active);
        /* optional uint32 usec_p99_active = 13; */
        if (message.usecP99Active !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.usecP99Active);
        /* optional uint32 usec_avg_all = 21; */
        if (message.usecAvgAll !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.usecAvgAll);
        /* optional uint32 usec_p50_all = 22; */
        if (message.usecP50All !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.usecP50All);
        /* optional uint32 usec_p99_all = 23; */
        if (message.usecP99All !== undefined)
            writer.tag(23, WireType.Varint).uint32(message.usecP99All);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSource2VProfLiteReportItem
 */
export const CMsgSource2VProfLiteReportItem = new CMsgSource2VProfLiteReportItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSource2VProfLiteReport$Type extends MessageType<CMsgSource2VProfLiteReport> {
    constructor() {
        super("CMsgSource2VProfLiteReport", [
            { no: 1, name: "total", kind: "message", T: () => CMsgSource2VProfLiteReportItem },
            { no: 2, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSource2VProfLiteReportItem },
            { no: 3, name: "discarded_frames", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSource2VProfLiteReport>): CMsgSource2VProfLiteReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSource2VProfLiteReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSource2VProfLiteReport): CMsgSource2VProfLiteReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSource2VProfLiteReportItem total */ 1:
                    message.total = CMsgSource2VProfLiteReportItem.internalBinaryRead(reader, reader.uint32(), options, message.total);
                    break;
                case /* repeated CMsgSource2VProfLiteReportItem items */ 2:
                    message.items.push(CMsgSource2VProfLiteReportItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 discarded_frames */ 3:
                    message.discardedFrames = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSource2VProfLiteReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSource2VProfLiteReportItem total = 1; */
        if (message.total)
            CMsgSource2VProfLiteReportItem.internalBinaryWrite(message.total, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSource2VProfLiteReportItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            CMsgSource2VProfLiteReportItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 discarded_frames = 3; */
        if (message.discardedFrames !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.discardedFrames);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSource2VProfLiteReport
 */
export const CMsgSource2VProfLiteReport = new CMsgSource2VProfLiteReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_Diagnostic$Type extends MessageType<CCLCMsg_Diagnostic> {
    constructor() {
        super("CCLCMsg_Diagnostic", [
            { no: 1, name: "system_specs", kind: "message", T: () => CMsgSource2SystemSpecs },
            { no: 2, name: "vprof_report", kind: "message", T: () => CMsgSource2VProfLiteReport }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_Diagnostic>): CCLCMsg_Diagnostic {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_Diagnostic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_Diagnostic): CCLCMsg_Diagnostic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSource2SystemSpecs system_specs */ 1:
                    message.systemSpecs = CMsgSource2SystemSpecs.internalBinaryRead(reader, reader.uint32(), options, message.systemSpecs);
                    break;
                case /* optional CMsgSource2VProfLiteReport vprof_report */ 2:
                    message.vprofReport = CMsgSource2VProfLiteReport.internalBinaryRead(reader, reader.uint32(), options, message.vprofReport);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_Diagnostic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSource2SystemSpecs system_specs = 1; */
        if (message.systemSpecs)
            CMsgSource2SystemSpecs.internalBinaryWrite(message.systemSpecs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSource2VProfLiteReport vprof_report = 2; */
        if (message.vprofReport)
            CMsgSource2VProfLiteReport.internalBinaryWrite(message.vprofReport, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_Diagnostic
 */
export const CCLCMsg_Diagnostic = new CCLCMsg_Diagnostic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSource2Metrics_MatchPerfSummary_Notification$Type extends MessageType<CSource2Metrics_MatchPerfSummary_Notification> {
    constructor() {
        super("CSource2Metrics_MatchPerfSummary_Notification", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "game_mode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "server_build_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "server_profile", kind: "message", T: () => CMsgSource2VProfLiteReport },
            { no: 11, name: "clients", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSource2Metrics_MatchPerfSummary_Notification_Client },
            { no: 20, name: "map", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSource2Metrics_MatchPerfSummary_Notification>): CSource2Metrics_MatchPerfSummary_Notification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clients = [];
        if (value !== undefined)
            reflectionMergePartial<CSource2Metrics_MatchPerfSummary_Notification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSource2Metrics_MatchPerfSummary_Notification): CSource2Metrics_MatchPerfSummary_Notification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string game_mode */ 2:
                    message.gameMode = reader.string();
                    break;
                case /* optional uint32 server_build_id */ 3:
                    message.serverBuildId = reader.uint32();
                    break;
                case /* optional CMsgSource2VProfLiteReport server_profile */ 10:
                    message.serverProfile = CMsgSource2VProfLiteReport.internalBinaryRead(reader, reader.uint32(), options, message.serverProfile);
                    break;
                case /* repeated CSource2Metrics_MatchPerfSummary_Notification.Client clients */ 11:
                    message.clients.push(CSource2Metrics_MatchPerfSummary_Notification_Client.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string map */ 20:
                    message.map = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSource2Metrics_MatchPerfSummary_Notification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string game_mode = 2; */
        if (message.gameMode !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gameMode);
        /* optional uint32 server_build_id = 3; */
        if (message.serverBuildId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.serverBuildId);
        /* optional CMsgSource2VProfLiteReport server_profile = 10; */
        if (message.serverProfile)
            CMsgSource2VProfLiteReport.internalBinaryWrite(message.serverProfile, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated CSource2Metrics_MatchPerfSummary_Notification.Client clients = 11; */
        for (let i = 0; i < message.clients.length; i++)
            CSource2Metrics_MatchPerfSummary_Notification_Client.internalBinaryWrite(message.clients[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional string map = 20; */
        if (message.map !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.map);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSource2Metrics_MatchPerfSummary_Notification
 */
export const CSource2Metrics_MatchPerfSummary_Notification = new CSource2Metrics_MatchPerfSummary_Notification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSource2Metrics_MatchPerfSummary_Notification_Client$Type extends MessageType<CSource2Metrics_MatchPerfSummary_Notification_Client> {
    constructor() {
        super("CSource2Metrics_MatchPerfSummary_Notification.Client", [
            { no: 1, name: "system_specs", kind: "message", T: () => CMsgSource2SystemSpecs },
            { no: 2, name: "profile", kind: "message", T: () => CMsgSource2VProfLiteReport },
            { no: 3, name: "build_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSource2Metrics_MatchPerfSummary_Notification_Client>): CSource2Metrics_MatchPerfSummary_Notification_Client {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSource2Metrics_MatchPerfSummary_Notification_Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSource2Metrics_MatchPerfSummary_Notification_Client): CSource2Metrics_MatchPerfSummary_Notification_Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSource2SystemSpecs system_specs */ 1:
                    message.systemSpecs = CMsgSource2SystemSpecs.internalBinaryRead(reader, reader.uint32(), options, message.systemSpecs);
                    break;
                case /* optional CMsgSource2VProfLiteReport profile */ 2:
                    message.profile = CMsgSource2VProfLiteReport.internalBinaryRead(reader, reader.uint32(), options, message.profile);
                    break;
                case /* optional uint32 build_id */ 3:
                    message.buildId = reader.uint32();
                    break;
                case /* optional fixed64 steamid */ 10:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSource2Metrics_MatchPerfSummary_Notification_Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSource2SystemSpecs system_specs = 1; */
        if (message.systemSpecs)
            CMsgSource2SystemSpecs.internalBinaryWrite(message.systemSpecs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSource2VProfLiteReport profile = 2; */
        if (message.profile)
            CMsgSource2VProfLiteReport.internalBinaryWrite(message.profile, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 build_id = 3; */
        if (message.buildId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.buildId);
        /* optional fixed64 steamid = 10; */
        if (message.steamid !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.steamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSource2Metrics_MatchPerfSummary_Notification.Client
 */
export const CSource2Metrics_MatchPerfSummary_Notification_Client = new CSource2Metrics_MatchPerfSummary_Notification_Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ServerInfo$Type extends MessageType<CSVCMsg_ServerInfo> {
    constructor() {
        super("CSVCMsg_ServerInfo", [
            { no: 1, name: "protocol", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "server_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_dedicated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_hltv", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "c_os", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "max_clients", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "max_classes", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "player_slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "tick_interval", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "game_dir", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "map_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "sky_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "host_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "addon_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "game_session_config", kind: "message", T: () => CSVCMsg_GameSessionConfiguration },
            { no: 20, name: "game_session_manifest", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ServerInfo>): CSVCMsg_ServerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ServerInfo): CSVCMsg_ServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 protocol */ 1:
                    message.protocol = reader.int32();
                    break;
                case /* optional int32 server_count */ 2:
                    message.serverCount = reader.int32();
                    break;
                case /* optional bool is_dedicated */ 3:
                    message.isDedicated = reader.bool();
                    break;
                case /* optional bool is_hltv */ 4:
                    message.isHltv = reader.bool();
                    break;
                case /* optional int32 c_os */ 6:
                    message.cOs = reader.int32();
                    break;
                case /* optional int32 max_clients */ 10:
                    message.maxClients = reader.int32();
                    break;
                case /* optional int32 max_classes */ 11:
                    message.maxClasses = reader.int32();
                    break;
                case /* optional int32 player_slot */ 12:
                    message.playerSlot = reader.int32();
                    break;
                case /* optional float tick_interval */ 13:
                    message.tickInterval = reader.float();
                    break;
                case /* optional string game_dir */ 14:
                    message.gameDir = reader.string();
                    break;
                case /* optional string map_name */ 15:
                    message.mapName = reader.string();
                    break;
                case /* optional string sky_name */ 16:
                    message.skyName = reader.string();
                    break;
                case /* optional string host_name */ 17:
                    message.hostName = reader.string();
                    break;
                case /* optional string addon_name */ 18:
                    message.addonName = reader.string();
                    break;
                case /* optional CSVCMsg_GameSessionConfiguration game_session_config */ 19:
                    message.gameSessionConfig = CSVCMsg_GameSessionConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.gameSessionConfig);
                    break;
                case /* optional bytes game_session_manifest */ 20:
                    message.gameSessionManifest = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 protocol = 1; */
        if (message.protocol !== undefined)
            writer.tag(1, WireType.Varint).int32(message.protocol);
        /* optional int32 server_count = 2; */
        if (message.serverCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.serverCount);
        /* optional bool is_dedicated = 3; */
        if (message.isDedicated !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isDedicated);
        /* optional bool is_hltv = 4; */
        if (message.isHltv !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isHltv);
        /* optional int32 c_os = 6; */
        if (message.cOs !== undefined)
            writer.tag(6, WireType.Varint).int32(message.cOs);
        /* optional int32 max_clients = 10; */
        if (message.maxClients !== undefined)
            writer.tag(10, WireType.Varint).int32(message.maxClients);
        /* optional int32 max_classes = 11; */
        if (message.maxClasses !== undefined)
            writer.tag(11, WireType.Varint).int32(message.maxClasses);
        /* optional int32 player_slot = 12; */
        if (message.playerSlot !== undefined)
            writer.tag(12, WireType.Varint).int32(message.playerSlot);
        /* optional float tick_interval = 13; */
        if (message.tickInterval !== undefined)
            writer.tag(13, WireType.Bit32).float(message.tickInterval);
        /* optional string game_dir = 14; */
        if (message.gameDir !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.gameDir);
        /* optional string map_name = 15; */
        if (message.mapName !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.mapName);
        /* optional string sky_name = 16; */
        if (message.skyName !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.skyName);
        /* optional string host_name = 17; */
        if (message.hostName !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.hostName);
        /* optional string addon_name = 18; */
        if (message.addonName !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.addonName);
        /* optional CSVCMsg_GameSessionConfiguration game_session_config = 19; */
        if (message.gameSessionConfig)
            CSVCMsg_GameSessionConfiguration.internalBinaryWrite(message.gameSessionConfig, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes game_session_manifest = 20; */
        if (message.gameSessionManifest !== undefined)
            writer.tag(20, WireType.LengthDelimited).bytes(message.gameSessionManifest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ServerInfo
 */
export const CSVCMsg_ServerInfo = new CSVCMsg_ServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ClassInfo$Type extends MessageType<CSVCMsg_ClassInfo> {
    constructor() {
        super("CSVCMsg_ClassInfo", [
            { no: 1, name: "create_on_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "classes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_ClassInfo_class_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ClassInfo>): CSVCMsg_ClassInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classes = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ClassInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ClassInfo): CSVCMsg_ClassInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool create_on_client */ 1:
                    message.createOnClient = reader.bool();
                    break;
                case /* repeated CSVCMsg_ClassInfo.class_t classes */ 2:
                    message.classes.push(CSVCMsg_ClassInfo_class_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ClassInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool create_on_client = 1; */
        if (message.createOnClient !== undefined)
            writer.tag(1, WireType.Varint).bool(message.createOnClient);
        /* repeated CSVCMsg_ClassInfo.class_t classes = 2; */
        for (let i = 0; i < message.classes.length; i++)
            CSVCMsg_ClassInfo_class_t.internalBinaryWrite(message.classes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ClassInfo
 */
export const CSVCMsg_ClassInfo = new CSVCMsg_ClassInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ClassInfo_class_t$Type extends MessageType<CSVCMsg_ClassInfo_class_t> {
    constructor() {
        super("CSVCMsg_ClassInfo.class_t", [
            { no: 1, name: "class_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "class_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ClassInfo_class_t>): CSVCMsg_ClassInfo_class_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ClassInfo_class_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ClassInfo_class_t): CSVCMsg_ClassInfo_class_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 class_id */ 1:
                    message.classId = reader.int32();
                    break;
                case /* optional string class_name */ 3:
                    message.className = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ClassInfo_class_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 class_id = 1; */
        if (message.classId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.classId);
        /* optional string class_name = 3; */
        if (message.className !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.className);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ClassInfo.class_t
 */
export const CSVCMsg_ClassInfo_class_t = new CSVCMsg_ClassInfo_class_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SetPause$Type extends MessageType<CSVCMsg_SetPause> {
    constructor() {
        super("CSVCMsg_SetPause", [
            { no: 1, name: "paused", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SetPause>): CSVCMsg_SetPause {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SetPause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SetPause): CSVCMsg_SetPause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool paused */ 1:
                    message.paused = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SetPause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool paused = 1; */
        if (message.paused !== undefined)
            writer.tag(1, WireType.Varint).bool(message.paused);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SetPause
 */
export const CSVCMsg_SetPause = new CSVCMsg_SetPause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_VoiceInit$Type extends MessageType<CSVCMsg_VoiceInit> {
    constructor() {
        super("CSVCMsg_VoiceInit", [
            { no: 1, name: "quality", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "codec", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_VoiceInit>): CSVCMsg_VoiceInit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_VoiceInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_VoiceInit): CSVCMsg_VoiceInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 quality */ 1:
                    message.quality = reader.int32();
                    break;
                case /* optional string codec */ 2:
                    message.codec = reader.string();
                    break;
                case /* optional int32 version */ 3:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_VoiceInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 quality = 1; */
        if (message.quality !== undefined)
            writer.tag(1, WireType.Varint).int32(message.quality);
        /* optional string codec = 2; */
        if (message.codec !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.codec);
        /* optional int32 version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_VoiceInit
 */
export const CSVCMsg_VoiceInit = new CSVCMsg_VoiceInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Print$Type extends MessageType<CSVCMsg_Print> {
    constructor() {
        super("CSVCMsg_Print", [
            { no: 1, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Print>): CSVCMsg_Print {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Print>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Print): CSVCMsg_Print {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Print, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string text = 1; */
        if (message.text !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Print
 */
export const CSVCMsg_Print = new CSVCMsg_Print$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Sounds$Type extends MessageType<CSVCMsg_Sounds> {
    constructor() {
        super("CSVCMsg_Sounds", [
            { no: 1, name: "reliable_sound", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sounds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_Sounds_sounddata_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Sounds>): CSVCMsg_Sounds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sounds = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Sounds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Sounds): CSVCMsg_Sounds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool reliable_sound */ 1:
                    message.reliableSound = reader.bool();
                    break;
                case /* repeated CSVCMsg_Sounds.sounddata_t sounds */ 2:
                    message.sounds.push(CSVCMsg_Sounds_sounddata_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Sounds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool reliable_sound = 1; */
        if (message.reliableSound !== undefined)
            writer.tag(1, WireType.Varint).bool(message.reliableSound);
        /* repeated CSVCMsg_Sounds.sounddata_t sounds = 2; */
        for (let i = 0; i < message.sounds.length; i++)
            CSVCMsg_Sounds_sounddata_t.internalBinaryWrite(message.sounds[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Sounds
 */
export const CSVCMsg_Sounds = new CSVCMsg_Sounds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Sounds_sounddata_t$Type extends MessageType<CSVCMsg_Sounds_sounddata_t> {
    constructor() {
        super("CSVCMsg_Sounds.sounddata_t", [
            { no: 1, name: "origin_x", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "origin_y", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "origin_z", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "volume", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "delay_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "sequence_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "channel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "pitch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "sound_num", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "sound_num_handle", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 13, name: "speaker_entity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "random_seed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "sound_level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "is_sentence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "is_ambient", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "guid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "sound_resource_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Sounds_sounddata_t>): CSVCMsg_Sounds_sounddata_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Sounds_sounddata_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Sounds_sounddata_t): CSVCMsg_Sounds_sounddata_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 origin_x */ 1:
                    message.originX = reader.sint32();
                    break;
                case /* optional sint32 origin_y */ 2:
                    message.originY = reader.sint32();
                    break;
                case /* optional sint32 origin_z */ 3:
                    message.originZ = reader.sint32();
                    break;
                case /* optional uint32 volume */ 4:
                    message.volume = reader.uint32();
                    break;
                case /* optional float delay_value */ 5:
                    message.delayValue = reader.float();
                    break;
                case /* optional int32 sequence_number */ 6:
                    message.sequenceNumber = reader.int32();
                    break;
                case /* optional int32 entity_index */ 7:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 channel */ 8:
                    message.channel = reader.int32();
                    break;
                case /* optional int32 pitch */ 9:
                    message.pitch = reader.int32();
                    break;
                case /* optional int32 flags */ 10:
                    message.flags = reader.int32();
                    break;
                case /* optional uint32 sound_num */ 11:
                    message.soundNum = reader.uint32();
                    break;
                case /* optional fixed32 sound_num_handle */ 12:
                    message.soundNumHandle = reader.fixed32();
                    break;
                case /* optional int32 speaker_entity */ 13:
                    message.speakerEntity = reader.int32();
                    break;
                case /* optional int32 random_seed */ 14:
                    message.randomSeed = reader.int32();
                    break;
                case /* optional int32 sound_level */ 15:
                    message.soundLevel = reader.int32();
                    break;
                case /* optional bool is_sentence */ 16:
                    message.isSentence = reader.bool();
                    break;
                case /* optional bool is_ambient */ 17:
                    message.isAmbient = reader.bool();
                    break;
                case /* optional uint32 guid */ 18:
                    message.guid = reader.uint32();
                    break;
                case /* optional fixed64 sound_resource_id */ 19:
                    message.soundResourceId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Sounds_sounddata_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 origin_x = 1; */
        if (message.originX !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.originX);
        /* optional sint32 origin_y = 2; */
        if (message.originY !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.originY);
        /* optional sint32 origin_z = 3; */
        if (message.originZ !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.originZ);
        /* optional uint32 volume = 4; */
        if (message.volume !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.volume);
        /* optional float delay_value = 5; */
        if (message.delayValue !== undefined)
            writer.tag(5, WireType.Bit32).float(message.delayValue);
        /* optional int32 sequence_number = 6; */
        if (message.sequenceNumber !== undefined)
            writer.tag(6, WireType.Varint).int32(message.sequenceNumber);
        /* optional int32 entity_index = 7; */
        if (message.entityIndex !== undefined)
            writer.tag(7, WireType.Varint).int32(message.entityIndex);
        /* optional int32 channel = 8; */
        if (message.channel !== undefined)
            writer.tag(8, WireType.Varint).int32(message.channel);
        /* optional int32 pitch = 9; */
        if (message.pitch !== undefined)
            writer.tag(9, WireType.Varint).int32(message.pitch);
        /* optional int32 flags = 10; */
        if (message.flags !== undefined)
            writer.tag(10, WireType.Varint).int32(message.flags);
        /* optional uint32 sound_num = 11; */
        if (message.soundNum !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.soundNum);
        /* optional fixed32 sound_num_handle = 12; */
        if (message.soundNumHandle !== undefined)
            writer.tag(12, WireType.Bit32).fixed32(message.soundNumHandle);
        /* optional int32 speaker_entity = 13; */
        if (message.speakerEntity !== undefined)
            writer.tag(13, WireType.Varint).int32(message.speakerEntity);
        /* optional int32 random_seed = 14; */
        if (message.randomSeed !== undefined)
            writer.tag(14, WireType.Varint).int32(message.randomSeed);
        /* optional int32 sound_level = 15; */
        if (message.soundLevel !== undefined)
            writer.tag(15, WireType.Varint).int32(message.soundLevel);
        /* optional bool is_sentence = 16; */
        if (message.isSentence !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isSentence);
        /* optional bool is_ambient = 17; */
        if (message.isAmbient !== undefined)
            writer.tag(17, WireType.Varint).bool(message.isAmbient);
        /* optional uint32 guid = 18; */
        if (message.guid !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.guid);
        /* optional fixed64 sound_resource_id = 19; */
        if (message.soundResourceId !== undefined)
            writer.tag(19, WireType.Bit64).fixed64(message.soundResourceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Sounds.sounddata_t
 */
export const CSVCMsg_Sounds_sounddata_t = new CSVCMsg_Sounds_sounddata_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Prefetch$Type extends MessageType<CSVCMsg_Prefetch> {
    constructor() {
        super("CSVCMsg_Prefetch", [
            { no: 1, name: "sound_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "resource_type", kind: "enum", opt: true, T: () => ["PrefetchType", PrefetchType] }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Prefetch>): CSVCMsg_Prefetch {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Prefetch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Prefetch): CSVCMsg_Prefetch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sound_index */ 1:
                    message.soundIndex = reader.int32();
                    break;
                case /* optional PrefetchType resource_type */ 2:
                    message.resourceType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Prefetch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 sound_index = 1; */
        if (message.soundIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.soundIndex);
        /* optional PrefetchType resource_type = 2; */
        if (message.resourceType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.resourceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Prefetch
 */
export const CSVCMsg_Prefetch = new CSVCMsg_Prefetch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SetView$Type extends MessageType<CSVCMsg_SetView> {
    constructor() {
        super("CSVCMsg_SetView", [
            { no: 1, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SetView>): CSVCMsg_SetView {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SetView>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SetView): CSVCMsg_SetView {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 entity_index */ 1:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SetView, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 entity_index = 1; */
        if (message.entityIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.entityIndex);
        /* optional int32 slot = 2; */
        if (message.slot !== undefined)
            writer.tag(2, WireType.Varint).int32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SetView
 */
export const CSVCMsg_SetView = new CSVCMsg_SetView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_FixAngle$Type extends MessageType<CSVCMsg_FixAngle> {
    constructor() {
        super("CSVCMsg_FixAngle", [
            { no: 1, name: "relative", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "angle", kind: "message", T: () => CMsgQAngle }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_FixAngle>): CSVCMsg_FixAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_FixAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_FixAngle): CSVCMsg_FixAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool relative */ 1:
                    message.relative = reader.bool();
                    break;
                case /* optional CMsgQAngle angle */ 2:
                    message.angle = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_FixAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool relative = 1; */
        if (message.relative !== undefined)
            writer.tag(1, WireType.Varint).bool(message.relative);
        /* optional CMsgQAngle angle = 2; */
        if (message.angle)
            CMsgQAngle.internalBinaryWrite(message.angle, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_FixAngle
 */
export const CSVCMsg_FixAngle = new CSVCMsg_FixAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CrosshairAngle$Type extends MessageType<CSVCMsg_CrosshairAngle> {
    constructor() {
        super("CSVCMsg_CrosshairAngle", [
            { no: 1, name: "angle", kind: "message", T: () => CMsgQAngle }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CrosshairAngle>): CSVCMsg_CrosshairAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CrosshairAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CrosshairAngle): CSVCMsg_CrosshairAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgQAngle angle */ 1:
                    message.angle = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.angle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CrosshairAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgQAngle angle = 1; */
        if (message.angle)
            CMsgQAngle.internalBinaryWrite(message.angle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CrosshairAngle
 */
export const CSVCMsg_CrosshairAngle = new CSVCMsg_CrosshairAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_BSPDecal$Type extends MessageType<CSVCMsg_BSPDecal> {
    constructor() {
        super("CSVCMsg_BSPDecal", [
            { no: 1, name: "pos", kind: "message", T: () => CMsgVector },
            { no: 2, name: "decal_texture_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "model_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "low_priority", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_BSPDecal>): CSVCMsg_BSPDecal {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_BSPDecal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_BSPDecal): CSVCMsg_BSPDecal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgVector pos */ 1:
                    message.pos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.pos);
                    break;
                case /* optional int32 decal_texture_index */ 2:
                    message.decalTextureIndex = reader.int32();
                    break;
                case /* optional int32 entity_index */ 3:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 model_index */ 4:
                    message.modelIndex = reader.int32();
                    break;
                case /* optional bool low_priority */ 5:
                    message.lowPriority = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_BSPDecal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgVector pos = 1; */
        if (message.pos)
            CMsgVector.internalBinaryWrite(message.pos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 decal_texture_index = 2; */
        if (message.decalTextureIndex !== undefined)
            writer.tag(2, WireType.Varint).int32(message.decalTextureIndex);
        /* optional int32 entity_index = 3; */
        if (message.entityIndex !== undefined)
            writer.tag(3, WireType.Varint).int32(message.entityIndex);
        /* optional int32 model_index = 4; */
        if (message.modelIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.modelIndex);
        /* optional bool low_priority = 5; */
        if (message.lowPriority !== undefined)
            writer.tag(5, WireType.Varint).bool(message.lowPriority);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_BSPDecal
 */
export const CSVCMsg_BSPDecal = new CSVCMsg_BSPDecal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SplitScreen$Type extends MessageType<CSVCMsg_SplitScreen> {
    constructor() {
        super("CSVCMsg_SplitScreen", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["ESplitScreenMessageType", ESplitScreenMessageType] },
            { no: 2, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "player_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SplitScreen>): CSVCMsg_SplitScreen {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SplitScreen>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SplitScreen): CSVCMsg_SplitScreen {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ESplitScreenMessageType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 slot */ 2:
                    message.slot = reader.int32();
                    break;
                case /* optional int32 player_index */ 3:
                    message.playerIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SplitScreen, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ESplitScreenMessageType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 slot = 2; */
        if (message.slot !== undefined)
            writer.tag(2, WireType.Varint).int32(message.slot);
        /* optional int32 player_index = 3; */
        if (message.playerIndex !== undefined)
            writer.tag(3, WireType.Varint).int32(message.playerIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SplitScreen
 */
export const CSVCMsg_SplitScreen = new CSVCMsg_SplitScreen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GetCvarValue$Type extends MessageType<CSVCMsg_GetCvarValue> {
    constructor() {
        super("CSVCMsg_GetCvarValue", [
            { no: 1, name: "cookie", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cvar_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GetCvarValue>): CSVCMsg_GetCvarValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GetCvarValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GetCvarValue): CSVCMsg_GetCvarValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cookie */ 1:
                    message.cookie = reader.int32();
                    break;
                case /* optional string cvar_name */ 2:
                    message.cvarName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GetCvarValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cookie = 1; */
        if (message.cookie !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cookie);
        /* optional string cvar_name = 2; */
        if (message.cvarName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.cvarName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GetCvarValue
 */
export const CSVCMsg_GetCvarValue = new CSVCMsg_GetCvarValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Menu$Type extends MessageType<CSVCMsg_Menu> {
    constructor() {
        super("CSVCMsg_Menu", [
            { no: 1, name: "dialog_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "menu_key_values", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Menu>): CSVCMsg_Menu {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Menu>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Menu): CSVCMsg_Menu {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 dialog_type */ 1:
                    message.dialogType = reader.int32();
                    break;
                case /* optional bytes menu_key_values */ 2:
                    message.menuKeyValues = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Menu, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 dialog_type = 1; */
        if (message.dialogType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.dialogType);
        /* optional bytes menu_key_values = 2; */
        if (message.menuKeyValues !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.menuKeyValues);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Menu
 */
export const CSVCMsg_Menu = new CSVCMsg_Menu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_UserMessage$Type extends MessageType<CSVCMsg_UserMessage> {
    constructor() {
        super("CSVCMsg_UserMessage", [
            { no: 1, name: "msg_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "msg_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "passthrough", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_UserMessage>): CSVCMsg_UserMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_UserMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_UserMessage): CSVCMsg_UserMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 msg_type */ 1:
                    message.msgType = reader.int32();
                    break;
                case /* optional bytes msg_data */ 2:
                    message.msgData = reader.bytes();
                    break;
                case /* optional int32 passthrough */ 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_UserMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 msg_type = 1; */
        if (message.msgType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.msgType);
        /* optional bytes msg_data = 2; */
        if (message.msgData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.msgData);
        /* optional int32 passthrough = 3; */
        if (message.passthrough !== undefined)
            writer.tag(3, WireType.Varint).int32(message.passthrough);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_UserMessage
 */
export const CSVCMsg_UserMessage = new CSVCMsg_UserMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SendTable$Type extends MessageType<CSVCMsg_SendTable> {
    constructor() {
        super("CSVCMsg_SendTable", [
            { no: 1, name: "is_end", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "net_table_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "needs_decoder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "props", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_SendTable_sendprop_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SendTable>): CSVCMsg_SendTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.props = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SendTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SendTable): CSVCMsg_SendTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_end */ 1:
                    message.isEnd = reader.bool();
                    break;
                case /* optional string net_table_name */ 2:
                    message.netTableName = reader.string();
                    break;
                case /* optional bool needs_decoder */ 3:
                    message.needsDecoder = reader.bool();
                    break;
                case /* repeated CSVCMsg_SendTable.sendprop_t props */ 4:
                    message.props.push(CSVCMsg_SendTable_sendprop_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SendTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_end = 1; */
        if (message.isEnd !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isEnd);
        /* optional string net_table_name = 2; */
        if (message.netTableName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.netTableName);
        /* optional bool needs_decoder = 3; */
        if (message.needsDecoder !== undefined)
            writer.tag(3, WireType.Varint).bool(message.needsDecoder);
        /* repeated CSVCMsg_SendTable.sendprop_t props = 4; */
        for (let i = 0; i < message.props.length; i++)
            CSVCMsg_SendTable_sendprop_t.internalBinaryWrite(message.props[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SendTable
 */
export const CSVCMsg_SendTable = new CSVCMsg_SendTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_SendTable_sendprop_t$Type extends MessageType<CSVCMsg_SendTable_sendprop_t> {
    constructor() {
        super("CSVCMsg_SendTable.sendprop_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "var_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "priority", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "dt_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "num_elements", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "low_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "high_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "num_bits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_SendTable_sendprop_t>): CSVCMsg_SendTable_sendprop_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_SendTable_sendprop_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_SendTable_sendprop_t): CSVCMsg_SendTable_sendprop_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string var_name */ 2:
                    message.varName = reader.string();
                    break;
                case /* optional int32 flags */ 3:
                    message.flags = reader.int32();
                    break;
                case /* optional int32 priority */ 4:
                    message.priority = reader.int32();
                    break;
                case /* optional string dt_name */ 5:
                    message.dtName = reader.string();
                    break;
                case /* optional int32 num_elements */ 6:
                    message.numElements = reader.int32();
                    break;
                case /* optional float low_value */ 7:
                    message.lowValue = reader.float();
                    break;
                case /* optional float high_value */ 8:
                    message.highValue = reader.float();
                    break;
                case /* optional int32 num_bits */ 9:
                    message.numBits = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_SendTable_sendprop_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string var_name = 2; */
        if (message.varName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.varName);
        /* optional int32 flags = 3; */
        if (message.flags !== undefined)
            writer.tag(3, WireType.Varint).int32(message.flags);
        /* optional int32 priority = 4; */
        if (message.priority !== undefined)
            writer.tag(4, WireType.Varint).int32(message.priority);
        /* optional string dt_name = 5; */
        if (message.dtName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.dtName);
        /* optional int32 num_elements = 6; */
        if (message.numElements !== undefined)
            writer.tag(6, WireType.Varint).int32(message.numElements);
        /* optional float low_value = 7; */
        if (message.lowValue !== undefined)
            writer.tag(7, WireType.Bit32).float(message.lowValue);
        /* optional float high_value = 8; */
        if (message.highValue !== undefined)
            writer.tag(8, WireType.Bit32).float(message.highValue);
        /* optional int32 num_bits = 9; */
        if (message.numBits !== undefined)
            writer.tag(9, WireType.Varint).int32(message.numBits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_SendTable.sendprop_t
 */
export const CSVCMsg_SendTable_sendprop_t = new CSVCMsg_SendTable_sendprop_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList$Type extends MessageType<CSVCMsg_GameEventList> {
    constructor() {
        super("CSVCMsg_GameEventList", [
            { no: 1, name: "descriptors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEventList_descriptor_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList>): CSVCMsg_GameEventList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptors = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList): CSVCMsg_GameEventList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CSVCMsg_GameEventList.descriptor_t descriptors */ 1:
                    message.descriptors.push(CSVCMsg_GameEventList_descriptor_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CSVCMsg_GameEventList.descriptor_t descriptors = 1; */
        for (let i = 0; i < message.descriptors.length; i++)
            CSVCMsg_GameEventList_descriptor_t.internalBinaryWrite(message.descriptors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList
 */
export const CSVCMsg_GameEventList = new CSVCMsg_GameEventList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList_key_t$Type extends MessageType<CSVCMsg_GameEventList_key_t> {
    constructor() {
        super("CSVCMsg_GameEventList.key_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList_key_t>): CSVCMsg_GameEventList_key_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList_key_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList_key_t): CSVCMsg_GameEventList_key_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList_key_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList.key_t
 */
export const CSVCMsg_GameEventList_key_t = new CSVCMsg_GameEventList_key_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEventList_descriptor_t$Type extends MessageType<CSVCMsg_GameEventList_descriptor_t> {
    constructor() {
        super("CSVCMsg_GameEventList.descriptor_t", [
            { no: 1, name: "eventid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEventList_key_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEventList_descriptor_t>): CSVCMsg_GameEventList_descriptor_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEventList_descriptor_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEventList_descriptor_t): CSVCMsg_GameEventList_descriptor_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eventid */ 1:
                    message.eventid = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated CSVCMsg_GameEventList.key_t keys */ 3:
                    message.keys.push(CSVCMsg_GameEventList_key_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEventList_descriptor_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eventid = 1; */
        if (message.eventid !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eventid);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated CSVCMsg_GameEventList.key_t keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            CSVCMsg_GameEventList_key_t.internalBinaryWrite(message.keys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEventList.descriptor_t
 */
export const CSVCMsg_GameEventList_descriptor_t = new CSVCMsg_GameEventList_descriptor_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PacketEntities$Type extends MessageType<CSVCMsg_PacketEntities> {
    constructor() {
        super("CSVCMsg_PacketEntities", [
            { no: 1, name: "max_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "updated_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "legacy_is_delta", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "update_baseline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "baseline", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "delta_from", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "entity_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "pending_full_frame", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "active_spawngroup_handle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "max_spawngroup_creationsequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "last_cmd_number_executed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "last_cmd_number_recv_delta", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 12, name: "server_tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "serialized_entities", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 15, name: "alternate_baselines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_PacketEntities_alternate_baseline_t },
            { no: 16, name: "has_pvs_vis_bits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "cmd_recv_status", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 19, name: "non_transmitted_entities", kind: "message", T: () => CSVCMsg_PacketEntities_non_transmitted_entities_t },
            { no: 20, name: "cq_starved_command_ticks", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "cq_discarded_command_ticks", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 999, name: "dev_padding", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PacketEntities>): CSVCMsg_PacketEntities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.alternateBaselines = [];
        message.cmdRecvStatus = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PacketEntities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PacketEntities): CSVCMsg_PacketEntities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 max_entries */ 1:
                    message.maxEntries = reader.int32();
                    break;
                case /* optional int32 updated_entries */ 2:
                    message.updatedEntries = reader.int32();
                    break;
                case /* optional bool legacy_is_delta */ 3:
                    message.legacyIsDelta = reader.bool();
                    break;
                case /* optional bool update_baseline */ 4:
                    message.updateBaseline = reader.bool();
                    break;
                case /* optional int32 baseline */ 5:
                    message.baseline = reader.int32();
                    break;
                case /* optional int32 delta_from */ 6:
                    message.deltaFrom = reader.int32();
                    break;
                case /* optional bytes entity_data */ 7:
                    message.entityData = reader.bytes();
                    break;
                case /* optional bool pending_full_frame */ 8:
                    message.pendingFullFrame = reader.bool();
                    break;
                case /* optional uint32 active_spawngroup_handle */ 9:
                    message.activeSpawngroupHandle = reader.uint32();
                    break;
                case /* optional uint32 max_spawngroup_creationsequence */ 10:
                    message.maxSpawngroupCreationsequence = reader.uint32();
                    break;
                case /* optional uint32 last_cmd_number_executed */ 11:
                    message.lastCmdNumberExecuted = reader.uint32();
                    break;
                case /* optional sint32 last_cmd_number_recv_delta */ 17:
                    message.lastCmdNumberRecvDelta = reader.sint32();
                    break;
                case /* optional uint32 server_tick */ 12:
                    message.serverTick = reader.uint32();
                    break;
                case /* optional bytes serialized_entities */ 13:
                    message.serializedEntities = reader.bytes();
                    break;
                case /* repeated CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines */ 15:
                    message.alternateBaselines.push(CSVCMsg_PacketEntities_alternate_baseline_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 has_pvs_vis_bits */ 16:
                    message.hasPvsVisBits = reader.uint32();
                    break;
                case /* repeated sint32 cmd_recv_status = 22 [packed = true];*/ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cmdRecvStatus.push(reader.sint32());
                    else
                        message.cmdRecvStatus.push(reader.sint32());
                    break;
                case /* optional CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities */ 19:
                    message.nonTransmittedEntities = CSVCMsg_PacketEntities_non_transmitted_entities_t.internalBinaryRead(reader, reader.uint32(), options, message.nonTransmittedEntities);
                    break;
                case /* optional uint32 cq_starved_command_ticks */ 20:
                    message.cqStarvedCommandTicks = reader.uint32();
                    break;
                case /* optional uint32 cq_discarded_command_ticks */ 21:
                    message.cqDiscardedCommandTicks = reader.uint32();
                    break;
                case /* optional bytes dev_padding */ 999:
                    message.devPadding = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PacketEntities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 max_entries = 1; */
        if (message.maxEntries !== undefined)
            writer.tag(1, WireType.Varint).int32(message.maxEntries);
        /* optional int32 updated_entries = 2; */
        if (message.updatedEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.updatedEntries);
        /* optional bool legacy_is_delta = 3; */
        if (message.legacyIsDelta !== undefined)
            writer.tag(3, WireType.Varint).bool(message.legacyIsDelta);
        /* optional bool update_baseline = 4; */
        if (message.updateBaseline !== undefined)
            writer.tag(4, WireType.Varint).bool(message.updateBaseline);
        /* optional int32 baseline = 5; */
        if (message.baseline !== undefined)
            writer.tag(5, WireType.Varint).int32(message.baseline);
        /* optional int32 delta_from = 6; */
        if (message.deltaFrom !== undefined)
            writer.tag(6, WireType.Varint).int32(message.deltaFrom);
        /* optional bytes entity_data = 7; */
        if (message.entityData !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.entityData);
        /* optional bool pending_full_frame = 8; */
        if (message.pendingFullFrame !== undefined)
            writer.tag(8, WireType.Varint).bool(message.pendingFullFrame);
        /* optional uint32 active_spawngroup_handle = 9; */
        if (message.activeSpawngroupHandle !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.activeSpawngroupHandle);
        /* optional uint32 max_spawngroup_creationsequence = 10; */
        if (message.maxSpawngroupCreationsequence !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.maxSpawngroupCreationsequence);
        /* optional uint32 last_cmd_number_executed = 11; */
        if (message.lastCmdNumberExecuted !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.lastCmdNumberExecuted);
        /* optional sint32 last_cmd_number_recv_delta = 17; */
        if (message.lastCmdNumberRecvDelta !== undefined)
            writer.tag(17, WireType.Varint).sint32(message.lastCmdNumberRecvDelta);
        /* optional uint32 server_tick = 12; */
        if (message.serverTick !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.serverTick);
        /* optional bytes serialized_entities = 13; */
        if (message.serializedEntities !== undefined)
            writer.tag(13, WireType.LengthDelimited).bytes(message.serializedEntities);
        /* repeated CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15; */
        for (let i = 0; i < message.alternateBaselines.length; i++)
            CSVCMsg_PacketEntities_alternate_baseline_t.internalBinaryWrite(message.alternateBaselines[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 has_pvs_vis_bits = 16; */
        if (message.hasPvsVisBits !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.hasPvsVisBits);
        /* repeated sint32 cmd_recv_status = 22 [packed = true]; */
        if (message.cmdRecvStatus.length) {
            writer.tag(22, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cmdRecvStatus.length; i++)
                writer.sint32(message.cmdRecvStatus[i]);
            writer.join();
        }
        /* optional CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19; */
        if (message.nonTransmittedEntities)
            CSVCMsg_PacketEntities_non_transmitted_entities_t.internalBinaryWrite(message.nonTransmittedEntities, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 cq_starved_command_ticks = 20; */
        if (message.cqStarvedCommandTicks !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.cqStarvedCommandTicks);
        /* optional uint32 cq_discarded_command_ticks = 21; */
        if (message.cqDiscardedCommandTicks !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.cqDiscardedCommandTicks);
        /* optional bytes dev_padding = 999; */
        if (message.devPadding !== undefined)
            writer.tag(999, WireType.LengthDelimited).bytes(message.devPadding);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PacketEntities
 */
export const CSVCMsg_PacketEntities = new CSVCMsg_PacketEntities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PacketEntities_alternate_baseline_t$Type extends MessageType<CSVCMsg_PacketEntities_alternate_baseline_t> {
    constructor() {
        super("CSVCMsg_PacketEntities.alternate_baseline_t", [
            { no: 1, name: "entity_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "baseline_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PacketEntities_alternate_baseline_t>): CSVCMsg_PacketEntities_alternate_baseline_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PacketEntities_alternate_baseline_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PacketEntities_alternate_baseline_t): CSVCMsg_PacketEntities_alternate_baseline_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 entity_index */ 1:
                    message.entityIndex = reader.int32();
                    break;
                case /* optional int32 baseline_index */ 2:
                    message.baselineIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PacketEntities_alternate_baseline_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 entity_index = 1; */
        if (message.entityIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.entityIndex);
        /* optional int32 baseline_index = 2; */
        if (message.baselineIndex !== undefined)
            writer.tag(2, WireType.Varint).int32(message.baselineIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PacketEntities.alternate_baseline_t
 */
export const CSVCMsg_PacketEntities_alternate_baseline_t = new CSVCMsg_PacketEntities_alternate_baseline_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PacketEntities_non_transmitted_entities_t$Type extends MessageType<CSVCMsg_PacketEntities_non_transmitted_entities_t> {
    constructor() {
        super("CSVCMsg_PacketEntities.non_transmitted_entities_t", [
            { no: 1, name: "header_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PacketEntities_non_transmitted_entities_t>): CSVCMsg_PacketEntities_non_transmitted_entities_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PacketEntities_non_transmitted_entities_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PacketEntities_non_transmitted_entities_t): CSVCMsg_PacketEntities_non_transmitted_entities_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 header_count */ 1:
                    message.headerCount = reader.int32();
                    break;
                case /* optional bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PacketEntities_non_transmitted_entities_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 header_count = 1; */
        if (message.headerCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.headerCount);
        /* optional bytes data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PacketEntities.non_transmitted_entities_t
 */
export const CSVCMsg_PacketEntities_non_transmitted_entities_t = new CSVCMsg_PacketEntities_non_transmitted_entities_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_TempEntities$Type extends MessageType<CSVCMsg_TempEntities> {
    constructor() {
        super("CSVCMsg_TempEntities", [
            { no: 1, name: "reliable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "num_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "entity_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_TempEntities>): CSVCMsg_TempEntities {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_TempEntities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_TempEntities): CSVCMsg_TempEntities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool reliable */ 1:
                    message.reliable = reader.bool();
                    break;
                case /* optional int32 num_entries */ 2:
                    message.numEntries = reader.int32();
                    break;
                case /* optional bytes entity_data */ 3:
                    message.entityData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_TempEntities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool reliable = 1; */
        if (message.reliable !== undefined)
            writer.tag(1, WireType.Varint).bool(message.reliable);
        /* optional int32 num_entries = 2; */
        if (message.numEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.numEntries);
        /* optional bytes entity_data = 3; */
        if (message.entityData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.entityData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_TempEntities
 */
export const CSVCMsg_TempEntities = new CSVCMsg_TempEntities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CreateStringTable$Type extends MessageType<CSVCMsg_CreateStringTable> {
    constructor() {
        super("CSVCMsg_CreateStringTable", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "user_data_fixed_size", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "user_data_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "user_data_size_bits", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "string_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "uncompressed_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "data_compressed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "using_varint_bitcounts", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CreateStringTable>): CSVCMsg_CreateStringTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CreateStringTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CreateStringTable): CSVCMsg_CreateStringTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 num_entries */ 2:
                    message.numEntries = reader.int32();
                    break;
                case /* optional bool user_data_fixed_size */ 3:
                    message.userDataFixedSize = reader.bool();
                    break;
                case /* optional int32 user_data_size */ 4:
                    message.userDataSize = reader.int32();
                    break;
                case /* optional int32 user_data_size_bits */ 5:
                    message.userDataSizeBits = reader.int32();
                    break;
                case /* optional int32 flags */ 6:
                    message.flags = reader.int32();
                    break;
                case /* optional bytes string_data */ 7:
                    message.stringData = reader.bytes();
                    break;
                case /* optional int32 uncompressed_size */ 8:
                    message.uncompressedSize = reader.int32();
                    break;
                case /* optional bool data_compressed */ 9:
                    message.dataCompressed = reader.bool();
                    break;
                case /* optional bool using_varint_bitcounts */ 10:
                    message.usingVarintBitcounts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CreateStringTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 num_entries = 2; */
        if (message.numEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.numEntries);
        /* optional bool user_data_fixed_size = 3; */
        if (message.userDataFixedSize !== undefined)
            writer.tag(3, WireType.Varint).bool(message.userDataFixedSize);
        /* optional int32 user_data_size = 4; */
        if (message.userDataSize !== undefined)
            writer.tag(4, WireType.Varint).int32(message.userDataSize);
        /* optional int32 user_data_size_bits = 5; */
        if (message.userDataSizeBits !== undefined)
            writer.tag(5, WireType.Varint).int32(message.userDataSizeBits);
        /* optional int32 flags = 6; */
        if (message.flags !== undefined)
            writer.tag(6, WireType.Varint).int32(message.flags);
        /* optional bytes string_data = 7; */
        if (message.stringData !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.stringData);
        /* optional int32 uncompressed_size = 8; */
        if (message.uncompressedSize !== undefined)
            writer.tag(8, WireType.Varint).int32(message.uncompressedSize);
        /* optional bool data_compressed = 9; */
        if (message.dataCompressed !== undefined)
            writer.tag(9, WireType.Varint).bool(message.dataCompressed);
        /* optional bool using_varint_bitcounts = 10; */
        if (message.usingVarintBitcounts !== undefined)
            writer.tag(10, WireType.Varint).bool(message.usingVarintBitcounts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CreateStringTable
 */
export const CSVCMsg_CreateStringTable = new CSVCMsg_CreateStringTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_UpdateStringTable$Type extends MessageType<CSVCMsg_UpdateStringTable> {
    constructor() {
        super("CSVCMsg_UpdateStringTable", [
            { no: 1, name: "table_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "num_changed_entries", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "string_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_UpdateStringTable>): CSVCMsg_UpdateStringTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_UpdateStringTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_UpdateStringTable): CSVCMsg_UpdateStringTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 table_id */ 1:
                    message.tableId = reader.int32();
                    break;
                case /* optional int32 num_changed_entries */ 2:
                    message.numChangedEntries = reader.int32();
                    break;
                case /* optional bytes string_data */ 3:
                    message.stringData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_UpdateStringTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 table_id = 1; */
        if (message.tableId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tableId);
        /* optional int32 num_changed_entries = 2; */
        if (message.numChangedEntries !== undefined)
            writer.tag(2, WireType.Varint).int32(message.numChangedEntries);
        /* optional bytes string_data = 3; */
        if (message.stringData !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.stringData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_UpdateStringTable
 */
export const CSVCMsg_UpdateStringTable = new CSVCMsg_UpdateStringTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_VoiceData$Type extends MessageType<CSVCMsg_VoiceData> {
    constructor() {
        super("CSVCMsg_VoiceData", [
            { no: 1, name: "audio", kind: "message", T: () => CMsgVoiceAudio },
            { no: 2, name: "client", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "proximity", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "xuid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "audible_mask", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "passthrough", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_VoiceData>): CSVCMsg_VoiceData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_VoiceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_VoiceData): CSVCMsg_VoiceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgVoiceAudio audio */ 1:
                    message.audio = CMsgVoiceAudio.internalBinaryRead(reader, reader.uint32(), options, message.audio);
                    break;
                case /* optional int32 client */ 2:
                    message.client = reader.int32();
                    break;
                case /* optional bool proximity */ 3:
                    message.proximity = reader.bool();
                    break;
                case /* optional fixed64 xuid */ 4:
                    message.xuid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 audible_mask */ 5:
                    message.audibleMask = reader.int32();
                    break;
                case /* optional uint32 tick */ 6:
                    message.tick = reader.uint32();
                    break;
                case /* optional int32 passthrough */ 7:
                    message.passthrough = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_VoiceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgVoiceAudio audio = 1; */
        if (message.audio)
            CMsgVoiceAudio.internalBinaryWrite(message.audio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 client = 2; */
        if (message.client !== undefined)
            writer.tag(2, WireType.Varint).int32(message.client);
        /* optional bool proximity = 3; */
        if (message.proximity !== undefined)
            writer.tag(3, WireType.Varint).bool(message.proximity);
        /* optional fixed64 xuid = 4; */
        if (message.xuid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.xuid);
        /* optional int32 audible_mask = 5; */
        if (message.audibleMask !== undefined)
            writer.tag(5, WireType.Varint).int32(message.audibleMask);
        /* optional uint32 tick = 6; */
        if (message.tick !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.tick);
        /* optional int32 passthrough = 7; */
        if (message.passthrough !== undefined)
            writer.tag(7, WireType.Varint).int32(message.passthrough);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_VoiceData
 */
export const CSVCMsg_VoiceData = new CSVCMsg_VoiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PacketReliable$Type extends MessageType<CSVCMsg_PacketReliable> {
    constructor() {
        super("CSVCMsg_PacketReliable", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "messagessize", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "state", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PacketReliable>): CSVCMsg_PacketReliable {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PacketReliable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PacketReliable): CSVCMsg_PacketReliable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 tick */ 1:
                    message.tick = reader.int32();
                    break;
                case /* optional int32 messagessize */ 2:
                    message.messagessize = reader.int32();
                    break;
                case /* optional bool state */ 3:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PacketReliable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tick);
        /* optional int32 messagessize = 2; */
        if (message.messagessize !== undefined)
            writer.tag(2, WireType.Varint).int32(message.messagessize);
        /* optional bool state = 3; */
        if (message.state !== undefined)
            writer.tag(3, WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PacketReliable
 */
export const CSVCMsg_PacketReliable = new CSVCMsg_PacketReliable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_FullFrameSplit$Type extends MessageType<CSVCMsg_FullFrameSplit> {
    constructor() {
        super("CSVCMsg_FullFrameSplit", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "section", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "total", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_FullFrameSplit>): CSVCMsg_FullFrameSplit {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_FullFrameSplit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_FullFrameSplit): CSVCMsg_FullFrameSplit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 tick */ 1:
                    message.tick = reader.int32();
                    break;
                case /* optional int32 section */ 2:
                    message.section = reader.int32();
                    break;
                case /* optional int32 total */ 3:
                    message.total = reader.int32();
                    break;
                case /* optional bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_FullFrameSplit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tick);
        /* optional int32 section = 2; */
        if (message.section !== undefined)
            writer.tag(2, WireType.Varint).int32(message.section);
        /* optional int32 total = 3; */
        if (message.total !== undefined)
            writer.tag(3, WireType.Varint).int32(message.total);
        /* optional bytes data = 4; */
        if (message.data !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_FullFrameSplit
 */
export const CSVCMsg_FullFrameSplit = new CSVCMsg_FullFrameSplit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_HLTVStatus$Type extends MessageType<CSVCMsg_HLTVStatus> {
    constructor() {
        super("CSVCMsg_HLTVStatus", [
            { no: 1, name: "master", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "clients", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "slots", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "proxies", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_HLTVStatus>): CSVCMsg_HLTVStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_HLTVStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_HLTVStatus): CSVCMsg_HLTVStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string master */ 1:
                    message.master = reader.string();
                    break;
                case /* optional int32 clients */ 2:
                    message.clients = reader.int32();
                    break;
                case /* optional int32 slots */ 3:
                    message.slots = reader.int32();
                    break;
                case /* optional int32 proxies */ 4:
                    message.proxies = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_HLTVStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string master = 1; */
        if (message.master !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.master);
        /* optional int32 clients = 2; */
        if (message.clients !== undefined)
            writer.tag(2, WireType.Varint).int32(message.clients);
        /* optional int32 slots = 3; */
        if (message.slots !== undefined)
            writer.tag(3, WireType.Varint).int32(message.slots);
        /* optional int32 proxies = 4; */
        if (message.proxies !== undefined)
            writer.tag(4, WireType.Varint).int32(message.proxies);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_HLTVStatus
 */
export const CSVCMsg_HLTVStatus = new CSVCMsg_HLTVStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ServerSteamID$Type extends MessageType<CSVCMsg_ServerSteamID> {
    constructor() {
        super("CSVCMsg_ServerSteamID", [
            { no: 1, name: "steam_id", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ServerSteamID>): CSVCMsg_ServerSteamID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ServerSteamID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ServerSteamID): CSVCMsg_ServerSteamID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 steam_id */ 1:
                    message.steamId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ServerSteamID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 steam_id = 1; */
        if (message.steamId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.steamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ServerSteamID
 */
export const CSVCMsg_ServerSteamID = new CSVCMsg_ServerSteamID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_CmdKeyValues$Type extends MessageType<CSVCMsg_CmdKeyValues> {
    constructor() {
        super("CSVCMsg_CmdKeyValues", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_CmdKeyValues>): CSVCMsg_CmdKeyValues {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_CmdKeyValues>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_CmdKeyValues): CSVCMsg_CmdKeyValues {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_CmdKeyValues, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_CmdKeyValues
 */
export const CSVCMsg_CmdKeyValues = new CSVCMsg_CmdKeyValues$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_RconServerDetails$Type extends MessageType<CSVCMsg_RconServerDetails> {
    constructor() {
        super("CSVCMsg_RconServerDetails", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "details", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_RconServerDetails>): CSVCMsg_RconServerDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_RconServerDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_RconServerDetails): CSVCMsg_RconServerDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes token */ 1:
                    message.token = reader.bytes();
                    break;
                case /* optional string details */ 2:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_RconServerDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.token);
        /* optional string details = 2; */
        if (message.details !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_RconServerDetails
 */
export const CSVCMsg_RconServerDetails = new CSVCMsg_RconServerDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgIPCAddress$Type extends MessageType<CMsgIPCAddress> {
    constructor() {
        super("CMsgIPCAddress", [
            { no: 1, name: "computer_guid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "process_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgIPCAddress>): CMsgIPCAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgIPCAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgIPCAddress): CMsgIPCAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 computer_guid */ 1:
                    message.computerGuid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 process_id */ 2:
                    message.processId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgIPCAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 computer_guid = 1; */
        if (message.computerGuid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.computerGuid);
        /* optional uint32 process_id = 2; */
        if (message.processId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.processId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgIPCAddress
 */
export const CMsgIPCAddress = new CMsgIPCAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerPeer$Type extends MessageType<CMsgServerPeer> {
    constructor() {
        super("CMsgServerPeer", [
            { no: 1, name: "player_slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "ipc", kind: "message", T: () => CMsgIPCAddress },
            { no: 4, name: "they_hear_you", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "you_hear_them", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_listenserver_host", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgServerPeer>): CMsgServerPeer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgServerPeer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgServerPeer): CMsgServerPeer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 player_slot */ 1:
                    message.playerSlot = reader.int32();
                    break;
                case /* optional fixed64 steamid */ 2:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional CMsgIPCAddress ipc */ 3:
                    message.ipc = CMsgIPCAddress.internalBinaryRead(reader, reader.uint32(), options, message.ipc);
                    break;
                case /* optional bool they_hear_you */ 4:
                    message.theyHearYou = reader.bool();
                    break;
                case /* optional bool you_hear_them */ 5:
                    message.youHearThem = reader.bool();
                    break;
                case /* optional bool is_listenserver_host */ 6:
                    message.isListenserverHost = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgServerPeer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 player_slot = 1; */
        if (message.playerSlot !== undefined)
            writer.tag(1, WireType.Varint).int32(message.playerSlot);
        /* optional fixed64 steamid = 2; */
        if (message.steamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.steamid);
        /* optional CMsgIPCAddress ipc = 3; */
        if (message.ipc)
            CMsgIPCAddress.internalBinaryWrite(message.ipc, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool they_hear_you = 4; */
        if (message.theyHearYou !== undefined)
            writer.tag(4, WireType.Varint).bool(message.theyHearYou);
        /* optional bool you_hear_them = 5; */
        if (message.youHearThem !== undefined)
            writer.tag(5, WireType.Varint).bool(message.youHearThem);
        /* optional bool is_listenserver_host = 6; */
        if (message.isListenserverHost !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isListenserverHost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgServerPeer
 */
export const CMsgServerPeer = new CMsgServerPeer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_PeerList$Type extends MessageType<CSVCMsg_PeerList> {
    constructor() {
        super("CSVCMsg_PeerList", [
            { no: 1, name: "peer", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgServerPeer }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_PeerList>): CSVCMsg_PeerList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.peer = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_PeerList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_PeerList): CSVCMsg_PeerList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgServerPeer peer */ 1:
                    message.peer.push(CMsgServerPeer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_PeerList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgServerPeer peer = 1; */
        for (let i = 0; i < message.peer.length; i++)
            CMsgServerPeer.internalBinaryWrite(message.peer[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_PeerList
 */
export const CSVCMsg_PeerList = new CSVCMsg_PeerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_ClearAllStringTables$Type extends MessageType<CSVCMsg_ClearAllStringTables> {
    constructor() {
        super("CSVCMsg_ClearAllStringTables", [
            { no: 1, name: "mapname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "create_tables_skipped", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_ClearAllStringTables>): CSVCMsg_ClearAllStringTables {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_ClearAllStringTables>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_ClearAllStringTables): CSVCMsg_ClearAllStringTables {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string mapname */ 1:
                    message.mapname = reader.string();
                    break;
                case /* optional bool create_tables_skipped */ 3:
                    message.createTablesSkipped = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_ClearAllStringTables, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string mapname = 1; */
        if (message.mapname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.mapname);
        /* optional bool create_tables_skipped = 3; */
        if (message.createTablesSkipped !== undefined)
            writer.tag(3, WireType.Varint).bool(message.createTablesSkipped);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_ClearAllStringTables
 */
export const CSVCMsg_ClearAllStringTables = new CSVCMsg_ClearAllStringTables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoFlattenedSerializerField_t$Type extends MessageType<ProtoFlattenedSerializerField_t> {
    constructor() {
        super("ProtoFlattenedSerializerField_t", [
            { no: 1, name: "var_type_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "var_name_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bit_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "low_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "high_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "encode_flags", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "field_serializer_name_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "field_serializer_version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "send_node_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "var_encoder_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "polymorphic_types", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProtoFlattenedSerializerField_t_polymorphic_field_t },
            { no: 12, name: "var_serializer_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProtoFlattenedSerializerField_t>): ProtoFlattenedSerializerField_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.polymorphicTypes = [];
        if (value !== undefined)
            reflectionMergePartial<ProtoFlattenedSerializerField_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProtoFlattenedSerializerField_t): ProtoFlattenedSerializerField_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 var_type_sym */ 1:
                    message.varTypeSym = reader.int32();
                    break;
                case /* optional int32 var_name_sym */ 2:
                    message.varNameSym = reader.int32();
                    break;
                case /* optional int32 bit_count */ 3:
                    message.bitCount = reader.int32();
                    break;
                case /* optional float low_value */ 4:
                    message.lowValue = reader.float();
                    break;
                case /* optional float high_value */ 5:
                    message.highValue = reader.float();
                    break;
                case /* optional int32 encode_flags */ 6:
                    message.encodeFlags = reader.int32();
                    break;
                case /* optional int32 field_serializer_name_sym */ 7:
                    message.fieldSerializerNameSym = reader.int32();
                    break;
                case /* optional int32 field_serializer_version */ 8:
                    message.fieldSerializerVersion = reader.int32();
                    break;
                case /* optional int32 send_node_sym */ 9:
                    message.sendNodeSym = reader.int32();
                    break;
                case /* optional int32 var_encoder_sym */ 10:
                    message.varEncoderSym = reader.int32();
                    break;
                case /* repeated ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types */ 11:
                    message.polymorphicTypes.push(ProtoFlattenedSerializerField_t_polymorphic_field_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 var_serializer_sym */ 12:
                    message.varSerializerSym = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProtoFlattenedSerializerField_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 var_type_sym = 1; */
        if (message.varTypeSym !== undefined)
            writer.tag(1, WireType.Varint).int32(message.varTypeSym);
        /* optional int32 var_name_sym = 2; */
        if (message.varNameSym !== undefined)
            writer.tag(2, WireType.Varint).int32(message.varNameSym);
        /* optional int32 bit_count = 3; */
        if (message.bitCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.bitCount);
        /* optional float low_value = 4; */
        if (message.lowValue !== undefined)
            writer.tag(4, WireType.Bit32).float(message.lowValue);
        /* optional float high_value = 5; */
        if (message.highValue !== undefined)
            writer.tag(5, WireType.Bit32).float(message.highValue);
        /* optional int32 encode_flags = 6; */
        if (message.encodeFlags !== undefined)
            writer.tag(6, WireType.Varint).int32(message.encodeFlags);
        /* optional int32 field_serializer_name_sym = 7; */
        if (message.fieldSerializerNameSym !== undefined)
            writer.tag(7, WireType.Varint).int32(message.fieldSerializerNameSym);
        /* optional int32 field_serializer_version = 8; */
        if (message.fieldSerializerVersion !== undefined)
            writer.tag(8, WireType.Varint).int32(message.fieldSerializerVersion);
        /* optional int32 send_node_sym = 9; */
        if (message.sendNodeSym !== undefined)
            writer.tag(9, WireType.Varint).int32(message.sendNodeSym);
        /* optional int32 var_encoder_sym = 10; */
        if (message.varEncoderSym !== undefined)
            writer.tag(10, WireType.Varint).int32(message.varEncoderSym);
        /* repeated ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11; */
        for (let i = 0; i < message.polymorphicTypes.length; i++)
            ProtoFlattenedSerializerField_t_polymorphic_field_t.internalBinaryWrite(message.polymorphicTypes[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 var_serializer_sym = 12; */
        if (message.varSerializerSym !== undefined)
            writer.tag(12, WireType.Varint).int32(message.varSerializerSym);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProtoFlattenedSerializerField_t
 */
export const ProtoFlattenedSerializerField_t = new ProtoFlattenedSerializerField_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoFlattenedSerializerField_t_polymorphic_field_t$Type extends MessageType<ProtoFlattenedSerializerField_t_polymorphic_field_t> {
    constructor() {
        super("ProtoFlattenedSerializerField_t.polymorphic_field_t", [
            { no: 1, name: "polymorphic_field_serializer_name_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "polymorphic_field_serializer_version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProtoFlattenedSerializerField_t_polymorphic_field_t>): ProtoFlattenedSerializerField_t_polymorphic_field_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProtoFlattenedSerializerField_t_polymorphic_field_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProtoFlattenedSerializerField_t_polymorphic_field_t): ProtoFlattenedSerializerField_t_polymorphic_field_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 polymorphic_field_serializer_name_sym */ 1:
                    message.polymorphicFieldSerializerNameSym = reader.int32();
                    break;
                case /* optional int32 polymorphic_field_serializer_version */ 2:
                    message.polymorphicFieldSerializerVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProtoFlattenedSerializerField_t_polymorphic_field_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 polymorphic_field_serializer_name_sym = 1; */
        if (message.polymorphicFieldSerializerNameSym !== undefined)
            writer.tag(1, WireType.Varint).int32(message.polymorphicFieldSerializerNameSym);
        /* optional int32 polymorphic_field_serializer_version = 2; */
        if (message.polymorphicFieldSerializerVersion !== undefined)
            writer.tag(2, WireType.Varint).int32(message.polymorphicFieldSerializerVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProtoFlattenedSerializerField_t.polymorphic_field_t
 */
export const ProtoFlattenedSerializerField_t_polymorphic_field_t = new ProtoFlattenedSerializerField_t_polymorphic_field_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProtoFlattenedSerializer_t$Type extends MessageType<ProtoFlattenedSerializer_t> {
    constructor() {
        super("ProtoFlattenedSerializer_t", [
            { no: 1, name: "serializer_name_sym", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "serializer_version", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fields_index", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProtoFlattenedSerializer_t>): ProtoFlattenedSerializer_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fieldsIndex = [];
        if (value !== undefined)
            reflectionMergePartial<ProtoFlattenedSerializer_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProtoFlattenedSerializer_t): ProtoFlattenedSerializer_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 serializer_name_sym */ 1:
                    message.serializerNameSym = reader.int32();
                    break;
                case /* optional int32 serializer_version */ 2:
                    message.serializerVersion = reader.int32();
                    break;
                case /* repeated int32 fields_index */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fieldsIndex.push(reader.int32());
                    else
                        message.fieldsIndex.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProtoFlattenedSerializer_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 serializer_name_sym = 1; */
        if (message.serializerNameSym !== undefined)
            writer.tag(1, WireType.Varint).int32(message.serializerNameSym);
        /* optional int32 serializer_version = 2; */
        if (message.serializerVersion !== undefined)
            writer.tag(2, WireType.Varint).int32(message.serializerVersion);
        /* repeated int32 fields_index = 3; */
        for (let i = 0; i < message.fieldsIndex.length; i++)
            writer.tag(3, WireType.Varint).int32(message.fieldsIndex[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProtoFlattenedSerializer_t
 */
export const ProtoFlattenedSerializer_t = new ProtoFlattenedSerializer_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_FlattenedSerializer$Type extends MessageType<CSVCMsg_FlattenedSerializer> {
    constructor() {
        super("CSVCMsg_FlattenedSerializer", [
            { no: 1, name: "serializers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProtoFlattenedSerializer_t },
            { no: 2, name: "symbols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProtoFlattenedSerializerField_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_FlattenedSerializer>): CSVCMsg_FlattenedSerializer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serializers = [];
        message.symbols = [];
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_FlattenedSerializer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_FlattenedSerializer): CSVCMsg_FlattenedSerializer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ProtoFlattenedSerializer_t serializers */ 1:
                    message.serializers.push(ProtoFlattenedSerializer_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string symbols */ 2:
                    message.symbols.push(reader.string());
                    break;
                case /* repeated ProtoFlattenedSerializerField_t fields */ 3:
                    message.fields.push(ProtoFlattenedSerializerField_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_FlattenedSerializer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ProtoFlattenedSerializer_t serializers = 1; */
        for (let i = 0; i < message.serializers.length; i++)
            ProtoFlattenedSerializer_t.internalBinaryWrite(message.serializers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string symbols = 2; */
        for (let i = 0; i < message.symbols.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.symbols[i]);
        /* repeated ProtoFlattenedSerializerField_t fields = 3; */
        for (let i = 0; i < message.fields.length; i++)
            ProtoFlattenedSerializerField_t.internalBinaryWrite(message.fields[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_FlattenedSerializer
 */
export const CSVCMsg_FlattenedSerializer = new CSVCMsg_FlattenedSerializer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_StopSound$Type extends MessageType<CSVCMsg_StopSound> {
    constructor() {
        super("CSVCMsg_StopSound", [
            { no: 1, name: "guid", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_StopSound>): CSVCMsg_StopSound {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_StopSound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_StopSound): CSVCMsg_StopSound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 guid */ 1:
                    message.guid = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_StopSound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 guid = 1; */
        if (message.guid !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.guid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_StopSound
 */
export const CSVCMsg_StopSound = new CSVCMsg_StopSound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBidirMsg_RebroadcastGameEvent$Type extends MessageType<CBidirMsg_RebroadcastGameEvent> {
    constructor() {
        super("CBidirMsg_RebroadcastGameEvent", [
            { no: 1, name: "posttoserver", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "buftype", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "clientbitcount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "receivingclients", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CBidirMsg_RebroadcastGameEvent>): CBidirMsg_RebroadcastGameEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CBidirMsg_RebroadcastGameEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CBidirMsg_RebroadcastGameEvent): CBidirMsg_RebroadcastGameEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool posttoserver */ 1:
                    message.posttoserver = reader.bool();
                    break;
                case /* optional int32 buftype */ 2:
                    message.buftype = reader.int32();
                    break;
                case /* optional uint32 clientbitcount */ 3:
                    message.clientbitcount = reader.uint32();
                    break;
                case /* optional uint64 receivingclients */ 4:
                    message.receivingclients = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CBidirMsg_RebroadcastGameEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool posttoserver = 1; */
        if (message.posttoserver !== undefined)
            writer.tag(1, WireType.Varint).bool(message.posttoserver);
        /* optional int32 buftype = 2; */
        if (message.buftype !== undefined)
            writer.tag(2, WireType.Varint).int32(message.buftype);
        /* optional uint32 clientbitcount = 3; */
        if (message.clientbitcount !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.clientbitcount);
        /* optional uint64 receivingclients = 4; */
        if (message.receivingclients !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.receivingclients);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CBidirMsg_RebroadcastGameEvent
 */
export const CBidirMsg_RebroadcastGameEvent = new CBidirMsg_RebroadcastGameEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBidirMsg_RebroadcastSource$Type extends MessageType<CBidirMsg_RebroadcastSource> {
    constructor() {
        super("CBidirMsg_RebroadcastSource", [
            { no: 1, name: "eventsource", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CBidirMsg_RebroadcastSource>): CBidirMsg_RebroadcastSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CBidirMsg_RebroadcastSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CBidirMsg_RebroadcastSource): CBidirMsg_RebroadcastSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 eventsource */ 1:
                    message.eventsource = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CBidirMsg_RebroadcastSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 eventsource = 1; */
        if (message.eventsource !== undefined)
            writer.tag(1, WireType.Varint).int32(message.eventsource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CBidirMsg_RebroadcastSource
 */
export const CBidirMsg_RebroadcastSource = new CBidirMsg_RebroadcastSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerNetworkStats$Type extends MessageType<CMsgServerNetworkStats> {
    constructor() {
        super("CMsgServerNetworkStats", [
            { no: 1, name: "dedicated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cpu_usage", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "memory_used_mb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "memory_free_mb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "uptime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "spawn_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "num_clients", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "num_bots", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "num_spectators", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "num_tv_relays", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "fps", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 17, name: "ports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgServerNetworkStats_Port },
            { no: 18, name: "avg_ping_ms", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "avg_engine_latency_out", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "avg_packets_out", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "avg_packets_in", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "avg_loss_out", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 23, name: "avg_loss_in", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "avg_data_out", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 25, name: "avg_data_in", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "total_data_in", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 27, name: "total_packets_in", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "total_data_out", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 29, name: "total_packets_out", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 30, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgServerNetworkStats_Player }
        ]);
    }
    create(value?: PartialMessage<CMsgServerNetworkStats>): CMsgServerNetworkStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ports = [];
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgServerNetworkStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgServerNetworkStats): CMsgServerNetworkStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool dedicated */ 1:
                    message.dedicated = reader.bool();
                    break;
                case /* optional int32 cpu_usage */ 2:
                    message.cpuUsage = reader.int32();
                    break;
                case /* optional int32 memory_used_mb */ 3:
                    message.memoryUsedMb = reader.int32();
                    break;
                case /* optional int32 memory_free_mb */ 4:
                    message.memoryFreeMb = reader.int32();
                    break;
                case /* optional int32 uptime */ 5:
                    message.uptime = reader.int32();
                    break;
                case /* optional int32 spawn_count */ 6:
                    message.spawnCount = reader.int32();
                    break;
                case /* optional int32 num_clients */ 8:
                    message.numClients = reader.int32();
                    break;
                case /* optional int32 num_bots */ 9:
                    message.numBots = reader.int32();
                    break;
                case /* optional int32 num_spectators */ 10:
                    message.numSpectators = reader.int32();
                    break;
                case /* optional int32 num_tv_relays */ 11:
                    message.numTvRelays = reader.int32();
                    break;
                case /* optional float fps */ 12:
                    message.fps = reader.float();
                    break;
                case /* repeated CMsgServerNetworkStats.Port ports */ 17:
                    message.ports.push(CMsgServerNetworkStats_Port.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float avg_ping_ms */ 18:
                    message.avgPingMs = reader.float();
                    break;
                case /* optional float avg_engine_latency_out */ 19:
                    message.avgEngineLatencyOut = reader.float();
                    break;
                case /* optional float avg_packets_out */ 20:
                    message.avgPacketsOut = reader.float();
                    break;
                case /* optional float avg_packets_in */ 21:
                    message.avgPacketsIn = reader.float();
                    break;
                case /* optional float avg_loss_out */ 22:
                    message.avgLossOut = reader.float();
                    break;
                case /* optional float avg_loss_in */ 23:
                    message.avgLossIn = reader.float();
                    break;
                case /* optional float avg_data_out */ 24:
                    message.avgDataOut = reader.float();
                    break;
                case /* optional float avg_data_in */ 25:
                    message.avgDataIn = reader.float();
                    break;
                case /* optional uint64 total_data_in */ 26:
                    message.totalDataIn = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_packets_in */ 27:
                    message.totalPacketsIn = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_data_out */ 28:
                    message.totalDataOut = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 total_packets_out */ 29:
                    message.totalPacketsOut = reader.uint64().toBigInt();
                    break;
                case /* repeated CMsgServerNetworkStats.Player players */ 30:
                    message.players.push(CMsgServerNetworkStats_Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgServerNetworkStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool dedicated = 1; */
        if (message.dedicated !== undefined)
            writer.tag(1, WireType.Varint).bool(message.dedicated);
        /* optional int32 cpu_usage = 2; */
        if (message.cpuUsage !== undefined)
            writer.tag(2, WireType.Varint).int32(message.cpuUsage);
        /* optional int32 memory_used_mb = 3; */
        if (message.memoryUsedMb !== undefined)
            writer.tag(3, WireType.Varint).int32(message.memoryUsedMb);
        /* optional int32 memory_free_mb = 4; */
        if (message.memoryFreeMb !== undefined)
            writer.tag(4, WireType.Varint).int32(message.memoryFreeMb);
        /* optional int32 uptime = 5; */
        if (message.uptime !== undefined)
            writer.tag(5, WireType.Varint).int32(message.uptime);
        /* optional int32 spawn_count = 6; */
        if (message.spawnCount !== undefined)
            writer.tag(6, WireType.Varint).int32(message.spawnCount);
        /* optional int32 num_clients = 8; */
        if (message.numClients !== undefined)
            writer.tag(8, WireType.Varint).int32(message.numClients);
        /* optional int32 num_bots = 9; */
        if (message.numBots !== undefined)
            writer.tag(9, WireType.Varint).int32(message.numBots);
        /* optional int32 num_spectators = 10; */
        if (message.numSpectators !== undefined)
            writer.tag(10, WireType.Varint).int32(message.numSpectators);
        /* optional int32 num_tv_relays = 11; */
        if (message.numTvRelays !== undefined)
            writer.tag(11, WireType.Varint).int32(message.numTvRelays);
        /* optional float fps = 12; */
        if (message.fps !== undefined)
            writer.tag(12, WireType.Bit32).float(message.fps);
        /* repeated CMsgServerNetworkStats.Port ports = 17; */
        for (let i = 0; i < message.ports.length; i++)
            CMsgServerNetworkStats_Port.internalBinaryWrite(message.ports[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional float avg_ping_ms = 18; */
        if (message.avgPingMs !== undefined)
            writer.tag(18, WireType.Bit32).float(message.avgPingMs);
        /* optional float avg_engine_latency_out = 19; */
        if (message.avgEngineLatencyOut !== undefined)
            writer.tag(19, WireType.Bit32).float(message.avgEngineLatencyOut);
        /* optional float avg_packets_out = 20; */
        if (message.avgPacketsOut !== undefined)
            writer.tag(20, WireType.Bit32).float(message.avgPacketsOut);
        /* optional float avg_packets_in = 21; */
        if (message.avgPacketsIn !== undefined)
            writer.tag(21, WireType.Bit32).float(message.avgPacketsIn);
        /* optional float avg_loss_out = 22; */
        if (message.avgLossOut !== undefined)
            writer.tag(22, WireType.Bit32).float(message.avgLossOut);
        /* optional float avg_loss_in = 23; */
        if (message.avgLossIn !== undefined)
            writer.tag(23, WireType.Bit32).float(message.avgLossIn);
        /* optional float avg_data_out = 24; */
        if (message.avgDataOut !== undefined)
            writer.tag(24, WireType.Bit32).float(message.avgDataOut);
        /* optional float avg_data_in = 25; */
        if (message.avgDataIn !== undefined)
            writer.tag(25, WireType.Bit32).float(message.avgDataIn);
        /* optional uint64 total_data_in = 26; */
        if (message.totalDataIn !== undefined)
            writer.tag(26, WireType.Varint).uint64(message.totalDataIn);
        /* optional uint64 total_packets_in = 27; */
        if (message.totalPacketsIn !== undefined)
            writer.tag(27, WireType.Varint).uint64(message.totalPacketsIn);
        /* optional uint64 total_data_out = 28; */
        if (message.totalDataOut !== undefined)
            writer.tag(28, WireType.Varint).uint64(message.totalDataOut);
        /* optional uint64 total_packets_out = 29; */
        if (message.totalPacketsOut !== undefined)
            writer.tag(29, WireType.Varint).uint64(message.totalPacketsOut);
        /* repeated CMsgServerNetworkStats.Player players = 30; */
        for (let i = 0; i < message.players.length; i++)
            CMsgServerNetworkStats_Player.internalBinaryWrite(message.players[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgServerNetworkStats
 */
export const CMsgServerNetworkStats = new CMsgServerNetworkStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerNetworkStats_Port$Type extends MessageType<CMsgServerNetworkStats_Port> {
    constructor() {
        super("CMsgServerNetworkStats.Port", [
            { no: 1, name: "port", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgServerNetworkStats_Port>): CMsgServerNetworkStats_Port {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgServerNetworkStats_Port>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgServerNetworkStats_Port): CMsgServerNetworkStats_Port {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgServerNetworkStats_Port, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 port = 1; */
        if (message.port !== undefined)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgServerNetworkStats.Port
 */
export const CMsgServerNetworkStats_Port = new CMsgServerNetworkStats_Port$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerNetworkStats_Player$Type extends MessageType<CMsgServerNetworkStats_Player> {
    constructor() {
        super("CMsgServerNetworkStats.Player", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "remote_addr", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ping_avg_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "packet_loss_pct", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "is_bot", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "loss_in", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "loss_out", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "engine_latency_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgServerNetworkStats_Player>): CMsgServerNetworkStats_Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgServerNetworkStats_Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgServerNetworkStats_Player): CMsgServerNetworkStats_Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 steamid */ 1:
                    message.steamid = reader.uint64().toBigInt();
                    break;
                case /* optional string remote_addr */ 2:
                    message.remoteAddr = reader.string();
                    break;
                case /* optional int32 ping_avg_ms */ 4:
                    message.pingAvgMs = reader.int32();
                    break;
                case /* optional float packet_loss_pct */ 5:
                    message.packetLossPct = reader.float();
                    break;
                case /* optional bool is_bot */ 6:
                    message.isBot = reader.bool();
                    break;
                case /* optional float loss_in */ 7:
                    message.lossIn = reader.float();
                    break;
                case /* optional float loss_out */ 8:
                    message.lossOut = reader.float();
                    break;
                case /* optional int32 engine_latency_ms */ 9:
                    message.engineLatencyMs = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgServerNetworkStats_Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.steamid);
        /* optional string remote_addr = 2; */
        if (message.remoteAddr !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.remoteAddr);
        /* optional int32 ping_avg_ms = 4; */
        if (message.pingAvgMs !== undefined)
            writer.tag(4, WireType.Varint).int32(message.pingAvgMs);
        /* optional float packet_loss_pct = 5; */
        if (message.packetLossPct !== undefined)
            writer.tag(5, WireType.Bit32).float(message.packetLossPct);
        /* optional bool is_bot = 6; */
        if (message.isBot !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isBot);
        /* optional float loss_in = 7; */
        if (message.lossIn !== undefined)
            writer.tag(7, WireType.Bit32).float(message.lossIn);
        /* optional float loss_out = 8; */
        if (message.lossOut !== undefined)
            writer.tag(8, WireType.Bit32).float(message.lossOut);
        /* optional int32 engine_latency_ms = 9; */
        if (message.engineLatencyMs !== undefined)
            writer.tag(9, WireType.Varint).int32(message.engineLatencyMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgServerNetworkStats.Player
 */
export const CMsgServerNetworkStats_Player = new CMsgServerNetworkStats_Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_HltvReplay$Type extends MessageType<CSVCMsg_HltvReplay> {
    constructor() {
        super("CSVCMsg_HltvReplay", [
            { no: 1, name: "delay", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "primary_target", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "replay_stop_at", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "replay_start_at", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "replay_slowdown_begin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "replay_slowdown_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "replay_slowdown_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "reason", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_HltvReplay>): CSVCMsg_HltvReplay {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_HltvReplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_HltvReplay): CSVCMsg_HltvReplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 delay */ 1:
                    message.delay = reader.int32();
                    break;
                case /* optional int32 primary_target */ 2:
                    message.primaryTarget = reader.int32();
                    break;
                case /* optional int32 replay_stop_at */ 3:
                    message.replayStopAt = reader.int32();
                    break;
                case /* optional int32 replay_start_at */ 4:
                    message.replayStartAt = reader.int32();
                    break;
                case /* optional int32 replay_slowdown_begin */ 5:
                    message.replaySlowdownBegin = reader.int32();
                    break;
                case /* optional int32 replay_slowdown_end */ 6:
                    message.replaySlowdownEnd = reader.int32();
                    break;
                case /* optional float replay_slowdown_rate */ 7:
                    message.replaySlowdownRate = reader.float();
                    break;
                case /* optional int32 reason */ 8:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_HltvReplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 delay = 1; */
        if (message.delay !== undefined)
            writer.tag(1, WireType.Varint).int32(message.delay);
        /* optional int32 primary_target = 2; */
        if (message.primaryTarget !== undefined)
            writer.tag(2, WireType.Varint).int32(message.primaryTarget);
        /* optional int32 replay_stop_at = 3; */
        if (message.replayStopAt !== undefined)
            writer.tag(3, WireType.Varint).int32(message.replayStopAt);
        /* optional int32 replay_start_at = 4; */
        if (message.replayStartAt !== undefined)
            writer.tag(4, WireType.Varint).int32(message.replayStartAt);
        /* optional int32 replay_slowdown_begin = 5; */
        if (message.replaySlowdownBegin !== undefined)
            writer.tag(5, WireType.Varint).int32(message.replaySlowdownBegin);
        /* optional int32 replay_slowdown_end = 6; */
        if (message.replaySlowdownEnd !== undefined)
            writer.tag(6, WireType.Varint).int32(message.replaySlowdownEnd);
        /* optional float replay_slowdown_rate = 7; */
        if (message.replaySlowdownRate !== undefined)
            writer.tag(7, WireType.Bit32).float(message.replaySlowdownRate);
        /* optional int32 reason = 8; */
        if (message.reason !== undefined)
            writer.tag(8, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_HltvReplay
 */
export const CSVCMsg_HltvReplay = new CSVCMsg_HltvReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_HltvReplay$Type extends MessageType<CCLCMsg_HltvReplay> {
    constructor() {
        super("CCLCMsg_HltvReplay", [
            { no: 1, name: "request", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "slowdown_length", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "slowdown_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "primary_target", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "event_time", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_HltvReplay>): CCLCMsg_HltvReplay {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_HltvReplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_HltvReplay): CCLCMsg_HltvReplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 request */ 1:
                    message.request = reader.int32();
                    break;
                case /* optional float slowdown_length */ 2:
                    message.slowdownLength = reader.float();
                    break;
                case /* optional float slowdown_rate */ 3:
                    message.slowdownRate = reader.float();
                    break;
                case /* optional int32 primary_target */ 4:
                    message.primaryTarget = reader.int32();
                    break;
                case /* optional float event_time */ 5:
                    message.eventTime = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_HltvReplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 request = 1; */
        if (message.request !== undefined)
            writer.tag(1, WireType.Varint).int32(message.request);
        /* optional float slowdown_length = 2; */
        if (message.slowdownLength !== undefined)
            writer.tag(2, WireType.Bit32).float(message.slowdownLength);
        /* optional float slowdown_rate = 3; */
        if (message.slowdownRate !== undefined)
            writer.tag(3, WireType.Bit32).float(message.slowdownRate);
        /* optional int32 primary_target = 4; */
        if (message.primaryTarget !== undefined)
            writer.tag(4, WireType.Varint).int32(message.primaryTarget);
        /* optional float event_time = 5; */
        if (message.eventTime !== undefined)
            writer.tag(5, WireType.Bit32).float(message.eventTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_HltvReplay
 */
export const CCLCMsg_HltvReplay = new CCLCMsg_HltvReplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_Broadcast_Command$Type extends MessageType<CSVCMsg_Broadcast_Command> {
    constructor() {
        super("CSVCMsg_Broadcast_Command", [
            { no: 1, name: "cmd", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_Broadcast_Command>): CSVCMsg_Broadcast_Command {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_Broadcast_Command>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_Broadcast_Command): CSVCMsg_Broadcast_Command {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string cmd */ 1:
                    message.cmd = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_Broadcast_Command, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string cmd = 1; */
        if (message.cmd !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.cmd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_Broadcast_Command
 */
export const CSVCMsg_Broadcast_Command = new CSVCMsg_Broadcast_Command$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCLCMsg_HltvFixupOperatorTick$Type extends MessageType<CCLCMsg_HltvFixupOperatorTick> {
    constructor() {
        super("CCLCMsg_HltvFixupOperatorTick", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "props_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "origin", kind: "message", T: () => CMsgVector },
            { no: 4, name: "eye_angles", kind: "message", T: () => CMsgQAngle },
            { no: 5, name: "observer_mode", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cameraman_scoreboard", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "observer_target", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "view_offset", kind: "message", T: () => CMsgVector }
        ]);
    }
    create(value?: PartialMessage<CCLCMsg_HltvFixupOperatorTick>): CCLCMsg_HltvFixupOperatorTick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCLCMsg_HltvFixupOperatorTick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCLCMsg_HltvFixupOperatorTick): CCLCMsg_HltvFixupOperatorTick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 tick */ 1:
                    message.tick = reader.int32();
                    break;
                case /* optional bytes props_data */ 2:
                    message.propsData = reader.bytes();
                    break;
                case /* optional CMsgVector origin */ 3:
                    message.origin = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* optional CMsgQAngle eye_angles */ 4:
                    message.eyeAngles = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.eyeAngles);
                    break;
                case /* optional int32 observer_mode */ 5:
                    message.observerMode = reader.int32();
                    break;
                case /* optional bool cameraman_scoreboard */ 6:
                    message.cameramanScoreboard = reader.bool();
                    break;
                case /* optional int32 observer_target */ 7:
                    message.observerTarget = reader.int32();
                    break;
                case /* optional CMsgVector view_offset */ 8:
                    message.viewOffset = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.viewOffset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCLCMsg_HltvFixupOperatorTick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tick);
        /* optional bytes props_data = 2; */
        if (message.propsData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.propsData);
        /* optional CMsgVector origin = 3; */
        if (message.origin)
            CMsgVector.internalBinaryWrite(message.origin, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgQAngle eye_angles = 4; */
        if (message.eyeAngles)
            CMsgQAngle.internalBinaryWrite(message.eyeAngles, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 observer_mode = 5; */
        if (message.observerMode !== undefined)
            writer.tag(5, WireType.Varint).int32(message.observerMode);
        /* optional bool cameraman_scoreboard = 6; */
        if (message.cameramanScoreboard !== undefined)
            writer.tag(6, WireType.Varint).bool(message.cameramanScoreboard);
        /* optional int32 observer_target = 7; */
        if (message.observerTarget !== undefined)
            writer.tag(7, WireType.Varint).int32(message.observerTarget);
        /* optional CMsgVector view_offset = 8; */
        if (message.viewOffset)
            CMsgVector.internalBinaryWrite(message.viewOffset, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCLCMsg_HltvFixupOperatorTick
 */
export const CCLCMsg_HltvFixupOperatorTick = new CCLCMsg_HltvFixupOperatorTick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_HltvFixupOperatorStatus$Type extends MessageType<CSVCMsg_HltvFixupOperatorStatus> {
    constructor() {
        super("CSVCMsg_HltvFixupOperatorStatus", [
            { no: 1, name: "mode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "override_operator_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_HltvFixupOperatorStatus>): CSVCMsg_HltvFixupOperatorStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_HltvFixupOperatorStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_HltvFixupOperatorStatus): CSVCMsg_HltvFixupOperatorStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 mode */ 1:
                    message.mode = reader.uint32();
                    break;
                case /* optional string override_operator_name */ 2:
                    message.overrideOperatorName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_HltvFixupOperatorStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 mode = 1; */
        if (message.mode !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.mode);
        /* optional string override_operator_name = 2; */
        if (message.overrideOperatorName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.overrideOperatorName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_HltvFixupOperatorStatus
 */
export const CSVCMsg_HltvFixupOperatorStatus = new CSVCMsg_HltvFixupOperatorStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerUserCmd$Type extends MessageType<CMsgServerUserCmd> {
    constructor() {
        super("CMsgServerUserCmd", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "cmd_number", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "player_slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "server_tick_executed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "client_tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgServerUserCmd>): CMsgServerUserCmd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgServerUserCmd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgServerUserCmd): CMsgServerUserCmd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* optional int32 cmd_number */ 2:
                    message.cmdNumber = reader.int32();
                    break;
                case /* optional int32 player_slot */ 3:
                    message.playerSlot = reader.int32();
                    break;
                case /* optional int32 server_tick_executed */ 4:
                    message.serverTickExecuted = reader.int32();
                    break;
                case /* optional int32 client_tick */ 5:
                    message.clientTick = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgServerUserCmd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* optional int32 cmd_number = 2; */
        if (message.cmdNumber !== undefined)
            writer.tag(2, WireType.Varint).int32(message.cmdNumber);
        /* optional int32 player_slot = 3; */
        if (message.playerSlot !== undefined)
            writer.tag(3, WireType.Varint).int32(message.playerSlot);
        /* optional int32 server_tick_executed = 4; */
        if (message.serverTickExecuted !== undefined)
            writer.tag(4, WireType.Varint).int32(message.serverTickExecuted);
        /* optional int32 client_tick = 5; */
        if (message.clientTick !== undefined)
            writer.tag(5, WireType.Varint).int32(message.clientTick);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgServerUserCmd
 */
export const CMsgServerUserCmd = new CMsgServerUserCmd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_UserCommands$Type extends MessageType<CSVCMsg_UserCommands> {
    constructor() {
        super("CSVCMsg_UserCommands", [
            { no: 1, name: "commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgServerUserCmd }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_UserCommands>): CSVCMsg_UserCommands {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commands = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_UserCommands>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_UserCommands): CSVCMsg_UserCommands {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgServerUserCmd commands */ 1:
                    message.commands.push(CMsgServerUserCmd.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_UserCommands, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgServerUserCmd commands = 1; */
        for (let i = 0; i < message.commands.length; i++)
            CMsgServerUserCmd.internalBinaryWrite(message.commands[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_UserCommands
 */
export const CSVCMsg_UserCommands = new CSVCMsg_UserCommands$Type();

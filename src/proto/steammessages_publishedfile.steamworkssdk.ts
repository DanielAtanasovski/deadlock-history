// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steammessages_publishedfile.steamworkssdk.proto" (syntax proto2)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CPublishedFile_Subscribe_Request
 */
export interface CPublishedFile_Subscribe_Request {
    /**
     * @generated from protobuf field: optional uint64 publishedfileid = 1;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 list_type = 2;
     */
    listType?: number;
    /**
     * @generated from protobuf field: optional int32 appid = 3;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool notify_client = 4;
     */
    notifyClient?: boolean;
}
/**
 * @generated from protobuf message CPublishedFile_Subscribe_Response
 */
export interface CPublishedFile_Subscribe_Response {
}
/**
 * @generated from protobuf message CPublishedFile_Unsubscribe_Request
 */
export interface CPublishedFile_Unsubscribe_Request {
    /**
     * @generated from protobuf field: optional uint64 publishedfileid = 1;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 list_type = 2;
     */
    listType?: number;
    /**
     * @generated from protobuf field: optional int32 appid = 3;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional bool notify_client = 4;
     */
    notifyClient?: boolean;
}
/**
 * @generated from protobuf message CPublishedFile_Unsubscribe_Response
 */
export interface CPublishedFile_Unsubscribe_Response {
}
/**
 * @generated from protobuf message CPublishedFile_Publish_Request
 */
export interface CPublishedFile_Publish_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 consumer_appid = 2;
     */
    consumerAppid?: number;
    /**
     * @generated from protobuf field: optional string cloudfilename = 3;
     */
    cloudfilename?: string;
    /**
     * @generated from protobuf field: optional string preview_cloudfilename = 4;
     */
    previewCloudfilename?: string;
    /**
     * @generated from protobuf field: optional string title = 5;
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string file_description = 6;
     */
    fileDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 file_type = 7;
     */
    fileType?: number;
    /**
     * @generated from protobuf field: optional string consumer_shortcut_name = 8;
     */
    consumerShortcutName?: string;
    /**
     * @generated from protobuf field: optional string youtube_username = 9;
     */
    youtubeUsername?: string;
    /**
     * @generated from protobuf field: optional string youtube_videoid = 10;
     */
    youtubeVideoid?: string;
    /**
     * @generated from protobuf field: optional uint32 visibility = 11;
     */
    visibility?: number;
    /**
     * @generated from protobuf field: optional string redirect_uri = 12;
     */
    redirectUri?: string;
    /**
     * @generated from protobuf field: repeated string tags = 13;
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional string collection_type = 14;
     */
    collectionType?: string;
    /**
     * @generated from protobuf field: optional string game_type = 15;
     */
    gameType?: string;
    /**
     * @generated from protobuf field: optional string url = 16;
     */
    url?: string;
}
/**
 * @generated from protobuf message CPublishedFile_Publish_Response
 */
export interface CPublishedFile_Publish_Response {
    /**
     * @generated from protobuf field: optional uint64 publishedfileid = 1;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional string redirect_uri = 2;
     */
    redirectUri?: string;
}
/**
 * @generated from protobuf message CPublishedFile_GetDetails_Request
 */
export interface CPublishedFile_GetDetails_Request {
    /**
     * @generated from protobuf field: repeated fixed64 publishedfileids = 1;
     */
    publishedfileids: bigint[];
    /**
     * @generated from protobuf field: optional bool includetags = 2;
     */
    includetags?: boolean;
    /**
     * @generated from protobuf field: optional bool includeadditionalpreviews = 3;
     */
    includeadditionalpreviews?: boolean;
    /**
     * @generated from protobuf field: optional bool includechildren = 4;
     */
    includechildren?: boolean;
    /**
     * @generated from protobuf field: optional bool includekvtags = 5;
     */
    includekvtags?: boolean;
    /**
     * @generated from protobuf field: optional bool includevotes = 6;
     */
    includevotes?: boolean;
    /**
     * @generated from protobuf field: optional bool short_description = 8;
     */
    shortDescription?: boolean;
}
/**
 * @generated from protobuf message PublishedFileDetails
 */
export interface PublishedFileDetails {
    /**
     * @generated from protobuf field: optional uint32 result = 1;
     */
    result?: number;
    /**
     * @generated from protobuf field: optional uint64 publishedfileid = 2;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 creator = 3;
     */
    creator?: bigint;
    /**
     * @generated from protobuf field: optional uint32 creator_appid = 4;
     */
    creatorAppid?: number;
    /**
     * @generated from protobuf field: optional uint32 consumer_appid = 5;
     */
    consumerAppid?: number;
    /**
     * @generated from protobuf field: optional uint32 consumer_shortcutid = 6;
     */
    consumerShortcutid?: number;
    /**
     * @generated from protobuf field: optional string filename = 7;
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional uint64 file_size = 8;
     */
    fileSize?: bigint;
    /**
     * @generated from protobuf field: optional uint64 preview_file_size = 9;
     */
    previewFileSize?: bigint;
    /**
     * @generated from protobuf field: optional string file_url = 10;
     */
    fileUrl?: string;
    /**
     * @generated from protobuf field: optional string preview_url = 11;
     */
    previewUrl?: string;
    /**
     * @generated from protobuf field: optional string youtubevideoid = 12;
     */
    youtubevideoid?: string;
    /**
     * @generated from protobuf field: optional string url = 13;
     */
    url?: string;
    /**
     * @generated from protobuf field: optional fixed64 hcontent_file = 14;
     */
    hcontentFile?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 hcontent_preview = 15;
     */
    hcontentPreview?: bigint;
    /**
     * @generated from protobuf field: optional string title = 16;
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string file_description = 17;
     */
    fileDescription?: string;
    /**
     * @generated from protobuf field: optional string short_description = 18;
     */
    shortDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 time_created = 19;
     */
    timeCreated?: number;
    /**
     * @generated from protobuf field: optional uint32 time_updated = 20;
     */
    timeUpdated?: number;
    /**
     * @generated from protobuf field: optional uint32 visibility = 21;
     */
    visibility?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 22;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional bool workshop_file = 23;
     */
    workshopFile?: boolean;
    /**
     * @generated from protobuf field: optional bool workshop_accepted = 24;
     */
    workshopAccepted?: boolean;
    /**
     * @generated from protobuf field: optional bool show_subscribe_all = 25;
     */
    showSubscribeAll?: boolean;
    /**
     * @generated from protobuf field: optional int32 num_comments_developer = 26;
     */
    numCommentsDeveloper?: number;
    /**
     * @generated from protobuf field: optional int32 num_comments_public = 27;
     */
    numCommentsPublic?: number;
    /**
     * @generated from protobuf field: optional bool banned = 28;
     */
    banned?: boolean;
    /**
     * @generated from protobuf field: optional string ban_reason = 29;
     */
    banReason?: string;
    /**
     * @generated from protobuf field: optional fixed64 banner = 30;
     */
    banner?: bigint;
    /**
     * @generated from protobuf field: optional bool can_be_deleted = 31;
     */
    canBeDeleted?: boolean;
    /**
     * @generated from protobuf field: optional bool incompatible = 32;
     */
    incompatible?: boolean;
    /**
     * @generated from protobuf field: optional string app_name = 33;
     */
    appName?: string;
    /**
     * @generated from protobuf field: optional uint32 file_type = 34;
     */
    fileType?: number;
    /**
     * @generated from protobuf field: optional bool can_subscribe = 35;
     */
    canSubscribe?: boolean;
    /**
     * @generated from protobuf field: optional uint32 subscriptions = 36;
     */
    subscriptions?: number;
    /**
     * @generated from protobuf field: optional uint32 favorited = 37;
     */
    favorited?: number;
    /**
     * @generated from protobuf field: optional uint32 followers = 38;
     */
    followers?: number;
    /**
     * @generated from protobuf field: optional uint32 lifetime_subscriptions = 39;
     */
    lifetimeSubscriptions?: number;
    /**
     * @generated from protobuf field: optional uint32 lifetime_favorited = 40;
     */
    lifetimeFavorited?: number;
    /**
     * @generated from protobuf field: optional uint32 lifetime_followers = 41;
     */
    lifetimeFollowers?: number;
    /**
     * @generated from protobuf field: optional uint32 views = 42;
     */
    views?: number;
    /**
     * @generated from protobuf field: optional uint32 image_width = 43;
     */
    imageWidth?: number;
    /**
     * @generated from protobuf field: optional uint32 image_height = 44;
     */
    imageHeight?: number;
    /**
     * @generated from protobuf field: optional string image_url = 45;
     */
    imageUrl?: string;
    /**
     * @generated from protobuf field: optional bool spoiler_tag = 46;
     */
    spoilerTag?: boolean;
    /**
     * @generated from protobuf field: optional uint32 shortcutid = 47;
     */
    shortcutid?: number;
    /**
     * @generated from protobuf field: optional string shortcutname = 48;
     */
    shortcutname?: string;
    /**
     * @generated from protobuf field: optional uint32 num_children = 49;
     */
    numChildren?: number;
    /**
     * @generated from protobuf field: optional uint32 num_reports = 50;
     */
    numReports?: number;
    /**
     * @generated from protobuf field: repeated PublishedFileDetails.Preview previews = 51;
     */
    previews: PublishedFileDetails_Preview[];
    /**
     * @generated from protobuf field: repeated PublishedFileDetails.Tag tags = 52;
     */
    tags: PublishedFileDetails_Tag[];
    /**
     * @generated from protobuf field: repeated PublishedFileDetails.Child children = 53;
     */
    children: PublishedFileDetails_Child[];
    /**
     * @generated from protobuf field: repeated PublishedFileDetails.KVTag kvtags = 54;
     */
    kvtags: PublishedFileDetails_KVTag[];
    /**
     * @generated from protobuf field: optional PublishedFileDetails.VoteData vote_data = 55;
     */
    voteData?: PublishedFileDetails_VoteData;
    /**
     * @generated from protobuf field: optional uint32 time_subscribed = 56;
     */
    timeSubscribed?: number;
}
/**
 * @generated from protobuf message PublishedFileDetails.Tag
 */
export interface PublishedFileDetails_Tag {
    /**
     * @generated from protobuf field: optional string tag = 1;
     */
    tag?: string;
    /**
     * @generated from protobuf field: optional bool adminonly = 2;
     */
    adminonly?: boolean;
}
/**
 * @generated from protobuf message PublishedFileDetails.Preview
 */
export interface PublishedFileDetails_Preview {
    /**
     * @generated from protobuf field: optional uint64 previewid = 1;
     */
    previewid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 sortorder = 2;
     */
    sortorder?: number;
    /**
     * @generated from protobuf field: optional string url = 3;
     */
    url?: string;
    /**
     * @generated from protobuf field: optional uint32 size = 4;
     */
    size?: number;
    /**
     * @generated from protobuf field: optional string filename = 5;
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional string youtubevideoid = 6;
     */
    youtubevideoid?: string;
}
/**
 * @generated from protobuf message PublishedFileDetails.Child
 */
export interface PublishedFileDetails_Child {
    /**
     * @generated from protobuf field: optional uint64 publishedfileid = 1;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 sortorder = 2;
     */
    sortorder?: number;
    /**
     * @generated from protobuf field: optional uint32 file_type = 3;
     */
    fileType?: number;
}
/**
 * @generated from protobuf message PublishedFileDetails.KVTag
 */
export interface PublishedFileDetails_KVTag {
    /**
     * @generated from protobuf field: optional string key = 1;
     */
    key?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message PublishedFileDetails.VoteData
 */
export interface PublishedFileDetails_VoteData {
    /**
     * @generated from protobuf field: optional float score = 1;
     */
    score?: number;
    /**
     * @generated from protobuf field: optional uint32 votes_up = 2;
     */
    votesUp?: number;
    /**
     * @generated from protobuf field: optional uint32 votes_down = 3;
     */
    votesDown?: number;
}
/**
 * @generated from protobuf message CPublishedFile_GetDetails_Response
 */
export interface CPublishedFile_GetDetails_Response {
    /**
     * @generated from protobuf field: repeated PublishedFileDetails publishedfiledetails = 1;
     */
    publishedfiledetails: PublishedFileDetails[];
}
/**
 * @generated from protobuf message CPublishedFile_GetUserFiles_Request
 */
export interface CPublishedFile_GetUserFiles_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 page = 3;
     */
    page?: number;
    /**
     * @generated from protobuf field: optional uint32 numperpage = 4;
     */
    numperpage?: number;
    /**
     * @generated from protobuf field: optional string sortmethod = 6;
     */
    sortmethod?: string;
    /**
     * @generated from protobuf field: optional bool totalonly = 7;
     */
    totalonly?: boolean;
    /**
     * @generated from protobuf field: optional uint32 privacy = 9;
     */
    privacy?: number;
    /**
     * @generated from protobuf field: optional bool ids_only = 10;
     */
    idsOnly?: boolean;
    /**
     * @generated from protobuf field: repeated string requiredtags = 11;
     */
    requiredtags: string[];
    /**
     * @generated from protobuf field: repeated string excludedtags = 12;
     */
    excludedtags: string[];
}
/**
 * @generated from protobuf message CPublishedFile_GetUserFiles_Response
 */
export interface CPublishedFile_GetUserFiles_Response {
    /**
     * @generated from protobuf field: optional uint32 total = 1;
     */
    total?: number;
    /**
     * @generated from protobuf field: optional uint32 startindex = 2;
     */
    startindex?: number;
    /**
     * @generated from protobuf field: repeated PublishedFileDetails publishedfiledetails = 3;
     */
    publishedfiledetails: PublishedFileDetails[];
    /**
     * @generated from protobuf field: repeated CPublishedFile_GetUserFiles_Response.App apps = 4;
     */
    apps: CPublishedFile_GetUserFiles_Response_App[];
}
/**
 * @generated from protobuf message CPublishedFile_GetUserFiles_Response.App
 */
export interface CPublishedFile_GetUserFiles_Response_App {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 shortcutid = 3;
     */
    shortcutid?: number;
    /**
     * @generated from protobuf field: optional bool private = 4;
     */
    private?: boolean;
}
/**
 * @generated from protobuf message CPublishedFile_Update_Request
 */
export interface CPublishedFile_Update_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional fixed64 publishedfileid = 2;
     */
    publishedfileid?: bigint;
    /**
     * @generated from protobuf field: optional string title = 3;
     */
    title?: string;
    /**
     * @generated from protobuf field: optional string file_description = 4;
     */
    fileDescription?: string;
    /**
     * @generated from protobuf field: optional uint32 visibility = 5;
     */
    visibility?: number;
    /**
     * @generated from protobuf field: repeated string tags = 6;
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional string filename = 7;
     */
    filename?: string;
    /**
     * @generated from protobuf field: optional string preview_filename = 8;
     */
    previewFilename?: string;
}
/**
 * @generated from protobuf message CPublishedFile_Update_Response
 */
export interface CPublishedFile_Update_Response {
}
/**
 * @generated from protobuf message CPublishedFile_RefreshVotingQueue_Request
 */
export interface CPublishedFile_RefreshVotingQueue_Request {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 matching_file_type = 2;
     */
    matchingFileType?: number;
    /**
     * @generated from protobuf field: repeated string tags = 3;
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional bool match_all_tags = 4;
     */
    matchAllTags?: boolean;
    /**
     * @generated from protobuf field: repeated string excluded_tags = 5;
     */
    excludedTags: string[];
    /**
     * @generated from protobuf field: optional uint32 desired_queue_size = 6;
     */
    desiredQueueSize?: number;
}
/**
 * @generated from protobuf message CPublishedFile_RefreshVotingQueue_Response
 */
export interface CPublishedFile_RefreshVotingQueue_Response {
}
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Subscribe_Request$Type extends MessageType<CPublishedFile_Subscribe_Request> {
    constructor() {
        super("CPublishedFile_Subscribe_Request", [
            { no: 1, name: "publishedfileid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "list_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "appid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "notify_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_Subscribe_Request>): CPublishedFile_Subscribe_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Subscribe_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Subscribe_Request): CPublishedFile_Subscribe_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 publishedfileid */ 1:
                    message.publishedfileid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 list_type */ 2:
                    message.listType = reader.uint32();
                    break;
                case /* optional int32 appid */ 3:
                    message.appid = reader.int32();
                    break;
                case /* optional bool notify_client */ 4:
                    message.notifyClient = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_Subscribe_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 publishedfileid = 1; */
        if (message.publishedfileid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.publishedfileid);
        /* optional uint32 list_type = 2; */
        if (message.listType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.listType);
        /* optional int32 appid = 3; */
        if (message.appid !== undefined)
            writer.tag(3, WireType.Varint).int32(message.appid);
        /* optional bool notify_client = 4; */
        if (message.notifyClient !== undefined)
            writer.tag(4, WireType.Varint).bool(message.notifyClient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Subscribe_Request
 */
export const CPublishedFile_Subscribe_Request = new CPublishedFile_Subscribe_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Subscribe_Response$Type extends MessageType<CPublishedFile_Subscribe_Response> {
    constructor() {
        super("CPublishedFile_Subscribe_Response", []);
    }
    create(value?: PartialMessage<CPublishedFile_Subscribe_Response>): CPublishedFile_Subscribe_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Subscribe_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Subscribe_Response): CPublishedFile_Subscribe_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CPublishedFile_Subscribe_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Subscribe_Response
 */
export const CPublishedFile_Subscribe_Response = new CPublishedFile_Subscribe_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Unsubscribe_Request$Type extends MessageType<CPublishedFile_Unsubscribe_Request> {
    constructor() {
        super("CPublishedFile_Unsubscribe_Request", [
            { no: 1, name: "publishedfileid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "list_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "appid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "notify_client", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_Unsubscribe_Request>): CPublishedFile_Unsubscribe_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Unsubscribe_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Unsubscribe_Request): CPublishedFile_Unsubscribe_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 publishedfileid */ 1:
                    message.publishedfileid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 list_type */ 2:
                    message.listType = reader.uint32();
                    break;
                case /* optional int32 appid */ 3:
                    message.appid = reader.int32();
                    break;
                case /* optional bool notify_client */ 4:
                    message.notifyClient = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_Unsubscribe_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 publishedfileid = 1; */
        if (message.publishedfileid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.publishedfileid);
        /* optional uint32 list_type = 2; */
        if (message.listType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.listType);
        /* optional int32 appid = 3; */
        if (message.appid !== undefined)
            writer.tag(3, WireType.Varint).int32(message.appid);
        /* optional bool notify_client = 4; */
        if (message.notifyClient !== undefined)
            writer.tag(4, WireType.Varint).bool(message.notifyClient);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Unsubscribe_Request
 */
export const CPublishedFile_Unsubscribe_Request = new CPublishedFile_Unsubscribe_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Unsubscribe_Response$Type extends MessageType<CPublishedFile_Unsubscribe_Response> {
    constructor() {
        super("CPublishedFile_Unsubscribe_Response", []);
    }
    create(value?: PartialMessage<CPublishedFile_Unsubscribe_Response>): CPublishedFile_Unsubscribe_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Unsubscribe_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Unsubscribe_Response): CPublishedFile_Unsubscribe_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CPublishedFile_Unsubscribe_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Unsubscribe_Response
 */
export const CPublishedFile_Unsubscribe_Response = new CPublishedFile_Unsubscribe_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Publish_Request$Type extends MessageType<CPublishedFile_Publish_Request> {
    constructor() {
        super("CPublishedFile_Publish_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "App Id this file is being published FROM." } },
            { no: 2, name: "consumer_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "App Id this file is being published TO." } },
            { no: 3, name: "cloudfilename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "Name of the file to publish in the user's cloud." } },
            { no: 4, name: "preview_cloudfilename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "Name of the file to use as the published file's preview." } },
            { no: 5, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "Text title for the published file." } },
            { no: 6, name: "file_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "Text description for the published file." } },
            { no: 7, name: "file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(EWorkshopFileType) Type of Workshop file to publish." } },
            { no: 8, name: "consumer_shortcut_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "Shortcut name for the published file." } },
            { no: 9, name: "youtube_username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) User's YouTube account username." } },
            { no: 10, name: "youtube_videoid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Video Id of a YouTube video for this published file." } },
            { no: 11, name: "visibility", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(ERemoteStoragePublishedFileVisibility) Visibility of the published file (private, friends, public, etc.)" } },
            { no: 12, name: "redirect_uri", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) If supplied, the resulting published file's Id is appended to the URI." } },
            { no: 13, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "Array of text tags to apply to the published file." } },
            { no: 14, name: "collection_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Type of collection the published file represents." } },
            { no: 15, name: "game_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Type of game the published file represents." } },
            { no: 16, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) If this represents a game, this is the URL to that game's page." } }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_Publish_Request>): CPublishedFile_Publish_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Publish_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Publish_Request): CPublishedFile_Publish_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 consumer_appid */ 2:
                    message.consumerAppid = reader.uint32();
                    break;
                case /* optional string cloudfilename */ 3:
                    message.cloudfilename = reader.string();
                    break;
                case /* optional string preview_cloudfilename */ 4:
                    message.previewCloudfilename = reader.string();
                    break;
                case /* optional string title */ 5:
                    message.title = reader.string();
                    break;
                case /* optional string file_description */ 6:
                    message.fileDescription = reader.string();
                    break;
                case /* optional uint32 file_type */ 7:
                    message.fileType = reader.uint32();
                    break;
                case /* optional string consumer_shortcut_name */ 8:
                    message.consumerShortcutName = reader.string();
                    break;
                case /* optional string youtube_username */ 9:
                    message.youtubeUsername = reader.string();
                    break;
                case /* optional string youtube_videoid */ 10:
                    message.youtubeVideoid = reader.string();
                    break;
                case /* optional uint32 visibility */ 11:
                    message.visibility = reader.uint32();
                    break;
                case /* optional string redirect_uri */ 12:
                    message.redirectUri = reader.string();
                    break;
                case /* repeated string tags */ 13:
                    message.tags.push(reader.string());
                    break;
                case /* optional string collection_type */ 14:
                    message.collectionType = reader.string();
                    break;
                case /* optional string game_type */ 15:
                    message.gameType = reader.string();
                    break;
                case /* optional string url */ 16:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_Publish_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 consumer_appid = 2; */
        if (message.consumerAppid !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.consumerAppid);
        /* optional string cloudfilename = 3; */
        if (message.cloudfilename !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.cloudfilename);
        /* optional string preview_cloudfilename = 4; */
        if (message.previewCloudfilename !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.previewCloudfilename);
        /* optional string title = 5; */
        if (message.title !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        /* optional string file_description = 6; */
        if (message.fileDescription !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.fileDescription);
        /* optional uint32 file_type = 7; */
        if (message.fileType !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.fileType);
        /* optional string consumer_shortcut_name = 8; */
        if (message.consumerShortcutName !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.consumerShortcutName);
        /* optional string youtube_username = 9; */
        if (message.youtubeUsername !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.youtubeUsername);
        /* optional string youtube_videoid = 10; */
        if (message.youtubeVideoid !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.youtubeVideoid);
        /* optional uint32 visibility = 11; */
        if (message.visibility !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.visibility);
        /* optional string redirect_uri = 12; */
        if (message.redirectUri !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.redirectUri);
        /* repeated string tags = 13; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.tags[i]);
        /* optional string collection_type = 14; */
        if (message.collectionType !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.collectionType);
        /* optional string game_type = 15; */
        if (message.gameType !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.gameType);
        /* optional string url = 16; */
        if (message.url !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Publish_Request
 */
export const CPublishedFile_Publish_Request = new CPublishedFile_Publish_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Publish_Response$Type extends MessageType<CPublishedFile_Publish_Response> {
    constructor() {
        super("CPublishedFile_Publish_Response", [
            { no: 1, name: "publishedfileid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "redirect_uri", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_Publish_Response>): CPublishedFile_Publish_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Publish_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Publish_Response): CPublishedFile_Publish_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 publishedfileid */ 1:
                    message.publishedfileid = reader.uint64().toBigInt();
                    break;
                case /* optional string redirect_uri */ 2:
                    message.redirectUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_Publish_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 publishedfileid = 1; */
        if (message.publishedfileid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.publishedfileid);
        /* optional string redirect_uri = 2; */
        if (message.redirectUri !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.redirectUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Publish_Response
 */
export const CPublishedFile_Publish_Response = new CPublishedFile_Publish_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_GetDetails_Request$Type extends MessageType<CPublishedFile_GetDetails_Request> {
    constructor() {
        super("CPublishedFile_GetDetails_Request", [
            { no: 1, name: "publishedfileids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { description: "Set of published file Ids to retrieve details for." } },
            { no: 2, name: "includetags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return tag information in the returned details." } },
            { no: 3, name: "includeadditionalpreviews", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return preview information in the returned details." } },
            { no: 4, name: "includechildren", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return children in the returned details." } },
            { no: 5, name: "includekvtags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return key value tags in the returned details." } },
            { no: 6, name: "includevotes", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return vote data in the returned details." } },
            { no: 8, name: "short_description", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, return a short description instead of the full description." } }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_GetDetails_Request>): CPublishedFile_GetDetails_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedfileids = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_GetDetails_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_GetDetails_Request): CPublishedFile_GetDetails_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 publishedfileids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.publishedfileids.push(reader.fixed64().toBigInt());
                    else
                        message.publishedfileids.push(reader.fixed64().toBigInt());
                    break;
                case /* optional bool includetags */ 2:
                    message.includetags = reader.bool();
                    break;
                case /* optional bool includeadditionalpreviews */ 3:
                    message.includeadditionalpreviews = reader.bool();
                    break;
                case /* optional bool includechildren */ 4:
                    message.includechildren = reader.bool();
                    break;
                case /* optional bool includekvtags */ 5:
                    message.includekvtags = reader.bool();
                    break;
                case /* optional bool includevotes */ 6:
                    message.includevotes = reader.bool();
                    break;
                case /* optional bool short_description */ 8:
                    message.shortDescription = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_GetDetails_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 publishedfileids = 1; */
        for (let i = 0; i < message.publishedfileids.length; i++)
            writer.tag(1, WireType.Bit64).fixed64(message.publishedfileids[i]);
        /* optional bool includetags = 2; */
        if (message.includetags !== undefined)
            writer.tag(2, WireType.Varint).bool(message.includetags);
        /* optional bool includeadditionalpreviews = 3; */
        if (message.includeadditionalpreviews !== undefined)
            writer.tag(3, WireType.Varint).bool(message.includeadditionalpreviews);
        /* optional bool includechildren = 4; */
        if (message.includechildren !== undefined)
            writer.tag(4, WireType.Varint).bool(message.includechildren);
        /* optional bool includekvtags = 5; */
        if (message.includekvtags !== undefined)
            writer.tag(5, WireType.Varint).bool(message.includekvtags);
        /* optional bool includevotes = 6; */
        if (message.includevotes !== undefined)
            writer.tag(6, WireType.Varint).bool(message.includevotes);
        /* optional bool short_description = 8; */
        if (message.shortDescription !== undefined)
            writer.tag(8, WireType.Varint).bool(message.shortDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_GetDetails_Request
 */
export const CPublishedFile_GetDetails_Request = new CPublishedFile_GetDetails_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails$Type extends MessageType<PublishedFileDetails> {
    constructor() {
        super("PublishedFileDetails", [
            { no: 1, name: "result", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "publishedfileid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "creator", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "creator_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "consumer_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "consumer_shortcutid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "file_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "preview_file_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "file_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "preview_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "youtubevideoid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "hcontent_file", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "hcontent_preview", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "file_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "short_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "time_created", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "time_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "visibility", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "workshop_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "workshop_accepted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "show_subscribe_all", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "num_comments_developer", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "num_comments_public", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "banned", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "ban_reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "banner", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 31, name: "can_be_deleted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "incompatible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "app_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 35, name: "can_subscribe", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 36, name: "subscriptions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 37, name: "favorited", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 38, name: "followers", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 39, name: "lifetime_subscriptions", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 40, name: "lifetime_favorited", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "lifetime_followers", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 42, name: "views", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 43, name: "image_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 44, name: "image_height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 45, name: "image_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 46, name: "spoiler_tag", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 47, name: "shortcutid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 48, name: "shortcutname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 49, name: "num_children", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 50, name: "num_reports", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 51, name: "previews", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails_Preview },
            { no: 52, name: "tags", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails_Tag },
            { no: 53, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails_Child },
            { no: 54, name: "kvtags", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails_KVTag },
            { no: 55, name: "vote_data", kind: "message", T: () => PublishedFileDetails_VoteData },
            { no: 56, name: "time_subscribed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "Only valid in PublishedFile.GetUserFiles and not normal PublishedFile.GetDetail calls" } }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails>): PublishedFileDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.previews = [];
        message.tags = [];
        message.children = [];
        message.kvtags = [];
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails): PublishedFileDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 result */ 1:
                    message.result = reader.uint32();
                    break;
                case /* optional uint64 publishedfileid */ 2:
                    message.publishedfileid = reader.uint64().toBigInt();
                    break;
                case /* optional fixed64 creator */ 3:
                    message.creator = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 creator_appid */ 4:
                    message.creatorAppid = reader.uint32();
                    break;
                case /* optional uint32 consumer_appid */ 5:
                    message.consumerAppid = reader.uint32();
                    break;
                case /* optional uint32 consumer_shortcutid */ 6:
                    message.consumerShortcutid = reader.uint32();
                    break;
                case /* optional string filename */ 7:
                    message.filename = reader.string();
                    break;
                case /* optional uint64 file_size */ 8:
                    message.fileSize = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 preview_file_size */ 9:
                    message.previewFileSize = reader.uint64().toBigInt();
                    break;
                case /* optional string file_url */ 10:
                    message.fileUrl = reader.string();
                    break;
                case /* optional string preview_url */ 11:
                    message.previewUrl = reader.string();
                    break;
                case /* optional string youtubevideoid */ 12:
                    message.youtubevideoid = reader.string();
                    break;
                case /* optional string url */ 13:
                    message.url = reader.string();
                    break;
                case /* optional fixed64 hcontent_file */ 14:
                    message.hcontentFile = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 hcontent_preview */ 15:
                    message.hcontentPreview = reader.fixed64().toBigInt();
                    break;
                case /* optional string title */ 16:
                    message.title = reader.string();
                    break;
                case /* optional string file_description */ 17:
                    message.fileDescription = reader.string();
                    break;
                case /* optional string short_description */ 18:
                    message.shortDescription = reader.string();
                    break;
                case /* optional uint32 time_created */ 19:
                    message.timeCreated = reader.uint32();
                    break;
                case /* optional uint32 time_updated */ 20:
                    message.timeUpdated = reader.uint32();
                    break;
                case /* optional uint32 visibility */ 21:
                    message.visibility = reader.uint32();
                    break;
                case /* optional uint32 flags */ 22:
                    message.flags = reader.uint32();
                    break;
                case /* optional bool workshop_file */ 23:
                    message.workshopFile = reader.bool();
                    break;
                case /* optional bool workshop_accepted */ 24:
                    message.workshopAccepted = reader.bool();
                    break;
                case /* optional bool show_subscribe_all */ 25:
                    message.showSubscribeAll = reader.bool();
                    break;
                case /* optional int32 num_comments_developer */ 26:
                    message.numCommentsDeveloper = reader.int32();
                    break;
                case /* optional int32 num_comments_public */ 27:
                    message.numCommentsPublic = reader.int32();
                    break;
                case /* optional bool banned */ 28:
                    message.banned = reader.bool();
                    break;
                case /* optional string ban_reason */ 29:
                    message.banReason = reader.string();
                    break;
                case /* optional fixed64 banner */ 30:
                    message.banner = reader.fixed64().toBigInt();
                    break;
                case /* optional bool can_be_deleted */ 31:
                    message.canBeDeleted = reader.bool();
                    break;
                case /* optional bool incompatible */ 32:
                    message.incompatible = reader.bool();
                    break;
                case /* optional string app_name */ 33:
                    message.appName = reader.string();
                    break;
                case /* optional uint32 file_type */ 34:
                    message.fileType = reader.uint32();
                    break;
                case /* optional bool can_subscribe */ 35:
                    message.canSubscribe = reader.bool();
                    break;
                case /* optional uint32 subscriptions */ 36:
                    message.subscriptions = reader.uint32();
                    break;
                case /* optional uint32 favorited */ 37:
                    message.favorited = reader.uint32();
                    break;
                case /* optional uint32 followers */ 38:
                    message.followers = reader.uint32();
                    break;
                case /* optional uint32 lifetime_subscriptions */ 39:
                    message.lifetimeSubscriptions = reader.uint32();
                    break;
                case /* optional uint32 lifetime_favorited */ 40:
                    message.lifetimeFavorited = reader.uint32();
                    break;
                case /* optional uint32 lifetime_followers */ 41:
                    message.lifetimeFollowers = reader.uint32();
                    break;
                case /* optional uint32 views */ 42:
                    message.views = reader.uint32();
                    break;
                case /* optional uint32 image_width */ 43:
                    message.imageWidth = reader.uint32();
                    break;
                case /* optional uint32 image_height */ 44:
                    message.imageHeight = reader.uint32();
                    break;
                case /* optional string image_url */ 45:
                    message.imageUrl = reader.string();
                    break;
                case /* optional bool spoiler_tag */ 46:
                    message.spoilerTag = reader.bool();
                    break;
                case /* optional uint32 shortcutid */ 47:
                    message.shortcutid = reader.uint32();
                    break;
                case /* optional string shortcutname */ 48:
                    message.shortcutname = reader.string();
                    break;
                case /* optional uint32 num_children */ 49:
                    message.numChildren = reader.uint32();
                    break;
                case /* optional uint32 num_reports */ 50:
                    message.numReports = reader.uint32();
                    break;
                case /* repeated PublishedFileDetails.Preview previews */ 51:
                    message.previews.push(PublishedFileDetails_Preview.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated PublishedFileDetails.Tag tags */ 52:
                    message.tags.push(PublishedFileDetails_Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated PublishedFileDetails.Child children */ 53:
                    message.children.push(PublishedFileDetails_Child.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated PublishedFileDetails.KVTag kvtags */ 54:
                    message.kvtags.push(PublishedFileDetails_KVTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional PublishedFileDetails.VoteData vote_data */ 55:
                    message.voteData = PublishedFileDetails_VoteData.internalBinaryRead(reader, reader.uint32(), options, message.voteData);
                    break;
                case /* optional uint32 time_subscribed */ 56:
                    message.timeSubscribed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 result = 1; */
        if (message.result !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.result);
        /* optional uint64 publishedfileid = 2; */
        if (message.publishedfileid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.publishedfileid);
        /* optional fixed64 creator = 3; */
        if (message.creator !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.creator);
        /* optional uint32 creator_appid = 4; */
        if (message.creatorAppid !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.creatorAppid);
        /* optional uint32 consumer_appid = 5; */
        if (message.consumerAppid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.consumerAppid);
        /* optional uint32 consumer_shortcutid = 6; */
        if (message.consumerShortcutid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.consumerShortcutid);
        /* optional string filename = 7; */
        if (message.filename !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.filename);
        /* optional uint64 file_size = 8; */
        if (message.fileSize !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.fileSize);
        /* optional uint64 preview_file_size = 9; */
        if (message.previewFileSize !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.previewFileSize);
        /* optional string file_url = 10; */
        if (message.fileUrl !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.fileUrl);
        /* optional string preview_url = 11; */
        if (message.previewUrl !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.previewUrl);
        /* optional string youtubevideoid = 12; */
        if (message.youtubevideoid !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.youtubevideoid);
        /* optional string url = 13; */
        if (message.url !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.url);
        /* optional fixed64 hcontent_file = 14; */
        if (message.hcontentFile !== undefined)
            writer.tag(14, WireType.Bit64).fixed64(message.hcontentFile);
        /* optional fixed64 hcontent_preview = 15; */
        if (message.hcontentPreview !== undefined)
            writer.tag(15, WireType.Bit64).fixed64(message.hcontentPreview);
        /* optional string title = 16; */
        if (message.title !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.title);
        /* optional string file_description = 17; */
        if (message.fileDescription !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.fileDescription);
        /* optional string short_description = 18; */
        if (message.shortDescription !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.shortDescription);
        /* optional uint32 time_created = 19; */
        if (message.timeCreated !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.timeCreated);
        /* optional uint32 time_updated = 20; */
        if (message.timeUpdated !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.timeUpdated);
        /* optional uint32 visibility = 21; */
        if (message.visibility !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.visibility);
        /* optional uint32 flags = 22; */
        if (message.flags !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.flags);
        /* optional bool workshop_file = 23; */
        if (message.workshopFile !== undefined)
            writer.tag(23, WireType.Varint).bool(message.workshopFile);
        /* optional bool workshop_accepted = 24; */
        if (message.workshopAccepted !== undefined)
            writer.tag(24, WireType.Varint).bool(message.workshopAccepted);
        /* optional bool show_subscribe_all = 25; */
        if (message.showSubscribeAll !== undefined)
            writer.tag(25, WireType.Varint).bool(message.showSubscribeAll);
        /* optional int32 num_comments_developer = 26; */
        if (message.numCommentsDeveloper !== undefined)
            writer.tag(26, WireType.Varint).int32(message.numCommentsDeveloper);
        /* optional int32 num_comments_public = 27; */
        if (message.numCommentsPublic !== undefined)
            writer.tag(27, WireType.Varint).int32(message.numCommentsPublic);
        /* optional bool banned = 28; */
        if (message.banned !== undefined)
            writer.tag(28, WireType.Varint).bool(message.banned);
        /* optional string ban_reason = 29; */
        if (message.banReason !== undefined)
            writer.tag(29, WireType.LengthDelimited).string(message.banReason);
        /* optional fixed64 banner = 30; */
        if (message.banner !== undefined)
            writer.tag(30, WireType.Bit64).fixed64(message.banner);
        /* optional bool can_be_deleted = 31; */
        if (message.canBeDeleted !== undefined)
            writer.tag(31, WireType.Varint).bool(message.canBeDeleted);
        /* optional bool incompatible = 32; */
        if (message.incompatible !== undefined)
            writer.tag(32, WireType.Varint).bool(message.incompatible);
        /* optional string app_name = 33; */
        if (message.appName !== undefined)
            writer.tag(33, WireType.LengthDelimited).string(message.appName);
        /* optional uint32 file_type = 34; */
        if (message.fileType !== undefined)
            writer.tag(34, WireType.Varint).uint32(message.fileType);
        /* optional bool can_subscribe = 35; */
        if (message.canSubscribe !== undefined)
            writer.tag(35, WireType.Varint).bool(message.canSubscribe);
        /* optional uint32 subscriptions = 36; */
        if (message.subscriptions !== undefined)
            writer.tag(36, WireType.Varint).uint32(message.subscriptions);
        /* optional uint32 favorited = 37; */
        if (message.favorited !== undefined)
            writer.tag(37, WireType.Varint).uint32(message.favorited);
        /* optional uint32 followers = 38; */
        if (message.followers !== undefined)
            writer.tag(38, WireType.Varint).uint32(message.followers);
        /* optional uint32 lifetime_subscriptions = 39; */
        if (message.lifetimeSubscriptions !== undefined)
            writer.tag(39, WireType.Varint).uint32(message.lifetimeSubscriptions);
        /* optional uint32 lifetime_favorited = 40; */
        if (message.lifetimeFavorited !== undefined)
            writer.tag(40, WireType.Varint).uint32(message.lifetimeFavorited);
        /* optional uint32 lifetime_followers = 41; */
        if (message.lifetimeFollowers !== undefined)
            writer.tag(41, WireType.Varint).uint32(message.lifetimeFollowers);
        /* optional uint32 views = 42; */
        if (message.views !== undefined)
            writer.tag(42, WireType.Varint).uint32(message.views);
        /* optional uint32 image_width = 43; */
        if (message.imageWidth !== undefined)
            writer.tag(43, WireType.Varint).uint32(message.imageWidth);
        /* optional uint32 image_height = 44; */
        if (message.imageHeight !== undefined)
            writer.tag(44, WireType.Varint).uint32(message.imageHeight);
        /* optional string image_url = 45; */
        if (message.imageUrl !== undefined)
            writer.tag(45, WireType.LengthDelimited).string(message.imageUrl);
        /* optional bool spoiler_tag = 46; */
        if (message.spoilerTag !== undefined)
            writer.tag(46, WireType.Varint).bool(message.spoilerTag);
        /* optional uint32 shortcutid = 47; */
        if (message.shortcutid !== undefined)
            writer.tag(47, WireType.Varint).uint32(message.shortcutid);
        /* optional string shortcutname = 48; */
        if (message.shortcutname !== undefined)
            writer.tag(48, WireType.LengthDelimited).string(message.shortcutname);
        /* optional uint32 num_children = 49; */
        if (message.numChildren !== undefined)
            writer.tag(49, WireType.Varint).uint32(message.numChildren);
        /* optional uint32 num_reports = 50; */
        if (message.numReports !== undefined)
            writer.tag(50, WireType.Varint).uint32(message.numReports);
        /* repeated PublishedFileDetails.Preview previews = 51; */
        for (let i = 0; i < message.previews.length; i++)
            PublishedFileDetails_Preview.internalBinaryWrite(message.previews[i], writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* repeated PublishedFileDetails.Tag tags = 52; */
        for (let i = 0; i < message.tags.length; i++)
            PublishedFileDetails_Tag.internalBinaryWrite(message.tags[i], writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* repeated PublishedFileDetails.Child children = 53; */
        for (let i = 0; i < message.children.length; i++)
            PublishedFileDetails_Child.internalBinaryWrite(message.children[i], writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* repeated PublishedFileDetails.KVTag kvtags = 54; */
        for (let i = 0; i < message.kvtags.length; i++)
            PublishedFileDetails_KVTag.internalBinaryWrite(message.kvtags[i], writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* optional PublishedFileDetails.VoteData vote_data = 55; */
        if (message.voteData)
            PublishedFileDetails_VoteData.internalBinaryWrite(message.voteData, writer.tag(55, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 time_subscribed = 56; */
        if (message.timeSubscribed !== undefined)
            writer.tag(56, WireType.Varint).uint32(message.timeSubscribed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails
 */
export const PublishedFileDetails = new PublishedFileDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails_Tag$Type extends MessageType<PublishedFileDetails_Tag> {
    constructor() {
        super("PublishedFileDetails.Tag", [
            { no: 1, name: "tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "adminonly", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails_Tag>): PublishedFileDetails_Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails_Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails_Tag): PublishedFileDetails_Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string tag */ 1:
                    message.tag = reader.string();
                    break;
                case /* optional bool adminonly */ 2:
                    message.adminonly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails_Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string tag = 1; */
        if (message.tag !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.tag);
        /* optional bool adminonly = 2; */
        if (message.adminonly !== undefined)
            writer.tag(2, WireType.Varint).bool(message.adminonly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails.Tag
 */
export const PublishedFileDetails_Tag = new PublishedFileDetails_Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails_Preview$Type extends MessageType<PublishedFileDetails_Preview> {
    constructor() {
        super("PublishedFileDetails.Preview", [
            { no: 1, name: "previewid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sortorder", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "youtubevideoid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails_Preview>): PublishedFileDetails_Preview {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails_Preview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails_Preview): PublishedFileDetails_Preview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 previewid */ 1:
                    message.previewid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 sortorder */ 2:
                    message.sortorder = reader.uint32();
                    break;
                case /* optional string url */ 3:
                    message.url = reader.string();
                    break;
                case /* optional uint32 size */ 4:
                    message.size = reader.uint32();
                    break;
                case /* optional string filename */ 5:
                    message.filename = reader.string();
                    break;
                case /* optional string youtubevideoid */ 6:
                    message.youtubevideoid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails_Preview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 previewid = 1; */
        if (message.previewid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.previewid);
        /* optional uint32 sortorder = 2; */
        if (message.sortorder !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sortorder);
        /* optional string url = 3; */
        if (message.url !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* optional uint32 size = 4; */
        if (message.size !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.size);
        /* optional string filename = 5; */
        if (message.filename !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.filename);
        /* optional string youtubevideoid = 6; */
        if (message.youtubevideoid !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.youtubevideoid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails.Preview
 */
export const PublishedFileDetails_Preview = new PublishedFileDetails_Preview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails_Child$Type extends MessageType<PublishedFileDetails_Child> {
    constructor() {
        super("PublishedFileDetails.Child", [
            { no: 1, name: "publishedfileid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sortorder", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails_Child>): PublishedFileDetails_Child {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails_Child>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails_Child): PublishedFileDetails_Child {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 publishedfileid */ 1:
                    message.publishedfileid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 sortorder */ 2:
                    message.sortorder = reader.uint32();
                    break;
                case /* optional uint32 file_type */ 3:
                    message.fileType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails_Child, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 publishedfileid = 1; */
        if (message.publishedfileid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.publishedfileid);
        /* optional uint32 sortorder = 2; */
        if (message.sortorder !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.sortorder);
        /* optional uint32 file_type = 3; */
        if (message.fileType !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails.Child
 */
export const PublishedFileDetails_Child = new PublishedFileDetails_Child$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails_KVTag$Type extends MessageType<PublishedFileDetails_KVTag> {
    constructor() {
        super("PublishedFileDetails.KVTag", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails_KVTag>): PublishedFileDetails_KVTag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails_KVTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails_KVTag): PublishedFileDetails_KVTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string key */ 1:
                    message.key = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails_KVTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails.KVTag
 */
export const PublishedFileDetails_KVTag = new PublishedFileDetails_KVTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishedFileDetails_VoteData$Type extends MessageType<PublishedFileDetails_VoteData> {
    constructor() {
        super("PublishedFileDetails.VoteData", [
            { no: 1, name: "score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "votes_up", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "votes_down", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PublishedFileDetails_VoteData>): PublishedFileDetails_VoteData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishedFileDetails_VoteData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishedFileDetails_VoteData): PublishedFileDetails_VoteData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float score */ 1:
                    message.score = reader.float();
                    break;
                case /* optional uint32 votes_up */ 2:
                    message.votesUp = reader.uint32();
                    break;
                case /* optional uint32 votes_down */ 3:
                    message.votesDown = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishedFileDetails_VoteData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float score = 1; */
        if (message.score !== undefined)
            writer.tag(1, WireType.Bit32).float(message.score);
        /* optional uint32 votes_up = 2; */
        if (message.votesUp !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.votesUp);
        /* optional uint32 votes_down = 3; */
        if (message.votesDown !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.votesDown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PublishedFileDetails.VoteData
 */
export const PublishedFileDetails_VoteData = new PublishedFileDetails_VoteData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_GetDetails_Response$Type extends MessageType<CPublishedFile_GetDetails_Response> {
    constructor() {
        super("CPublishedFile_GetDetails_Response", [
            { no: 1, name: "publishedfiledetails", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_GetDetails_Response>): CPublishedFile_GetDetails_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedfiledetails = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_GetDetails_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_GetDetails_Response): CPublishedFile_GetDetails_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated PublishedFileDetails publishedfiledetails */ 1:
                    message.publishedfiledetails.push(PublishedFileDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_GetDetails_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated PublishedFileDetails publishedfiledetails = 1; */
        for (let i = 0; i < message.publishedfiledetails.length; i++)
            PublishedFileDetails.internalBinaryWrite(message.publishedfiledetails[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_GetDetails_Response
 */
export const CPublishedFile_GetDetails_Response = new CPublishedFile_GetDetails_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_GetUserFiles_Request$Type extends MessageType<CPublishedFile_GetUserFiles_Request> {
    constructor() {
        super("CPublishedFile_GetUserFiles_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "App Id to retrieve published files from." } },
            { no: 3, name: "page", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(Optional) Starting page for results." } },
            { no: 4, name: "numperpage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(Optional) The number of results, per page to return." } },
            { no: 6, name: "sortmethod", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Sorting method to use on returned values." } },
            { no: 7, name: "totalonly", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "(Optional) If true, only return the total number of files that satisfy this query." } },
            { no: 9, name: "privacy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(optional) Filter by privacy settings." } },
            { no: 10, name: "ids_only", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "(Optional) If true, only return the published file ids of files that satisfy this query." } },
            { no: 11, name: "requiredtags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Tags that must be present on a published file to satisfy the query." } },
            { no: 12, name: "excludedtags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Tags that must NOT be present on a published file to satisfy the query." } }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_GetUserFiles_Request>): CPublishedFile_GetUserFiles_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiredtags = [];
        message.excludedtags = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_GetUserFiles_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_GetUserFiles_Request): CPublishedFile_GetUserFiles_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 page */ 3:
                    message.page = reader.uint32();
                    break;
                case /* optional uint32 numperpage */ 4:
                    message.numperpage = reader.uint32();
                    break;
                case /* optional string sortmethod */ 6:
                    message.sortmethod = reader.string();
                    break;
                case /* optional bool totalonly */ 7:
                    message.totalonly = reader.bool();
                    break;
                case /* optional uint32 privacy */ 9:
                    message.privacy = reader.uint32();
                    break;
                case /* optional bool ids_only */ 10:
                    message.idsOnly = reader.bool();
                    break;
                case /* repeated string requiredtags */ 11:
                    message.requiredtags.push(reader.string());
                    break;
                case /* repeated string excludedtags */ 12:
                    message.excludedtags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_GetUserFiles_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 page = 3; */
        if (message.page !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.page);
        /* optional uint32 numperpage = 4; */
        if (message.numperpage !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.numperpage);
        /* optional string sortmethod = 6; */
        if (message.sortmethod !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.sortmethod);
        /* optional bool totalonly = 7; */
        if (message.totalonly !== undefined)
            writer.tag(7, WireType.Varint).bool(message.totalonly);
        /* optional uint32 privacy = 9; */
        if (message.privacy !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.privacy);
        /* optional bool ids_only = 10; */
        if (message.idsOnly !== undefined)
            writer.tag(10, WireType.Varint).bool(message.idsOnly);
        /* repeated string requiredtags = 11; */
        for (let i = 0; i < message.requiredtags.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.requiredtags[i]);
        /* repeated string excludedtags = 12; */
        for (let i = 0; i < message.excludedtags.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.excludedtags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_GetUserFiles_Request
 */
export const CPublishedFile_GetUserFiles_Request = new CPublishedFile_GetUserFiles_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_GetUserFiles_Response$Type extends MessageType<CPublishedFile_GetUserFiles_Response> {
    constructor() {
        super("CPublishedFile_GetUserFiles_Response", [
            { no: 1, name: "total", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "startindex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "publishedfiledetails", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishedFileDetails },
            { no: 4, name: "apps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CPublishedFile_GetUserFiles_Response_App }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_GetUserFiles_Response>): CPublishedFile_GetUserFiles_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishedfiledetails = [];
        message.apps = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_GetUserFiles_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_GetUserFiles_Response): CPublishedFile_GetUserFiles_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* optional uint32 startindex */ 2:
                    message.startindex = reader.uint32();
                    break;
                case /* repeated PublishedFileDetails publishedfiledetails */ 3:
                    message.publishedfiledetails.push(PublishedFileDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CPublishedFile_GetUserFiles_Response.App apps */ 4:
                    message.apps.push(CPublishedFile_GetUserFiles_Response_App.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_GetUserFiles_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 total = 1; */
        if (message.total !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* optional uint32 startindex = 2; */
        if (message.startindex !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.startindex);
        /* repeated PublishedFileDetails publishedfiledetails = 3; */
        for (let i = 0; i < message.publishedfiledetails.length; i++)
            PublishedFileDetails.internalBinaryWrite(message.publishedfiledetails[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated CPublishedFile_GetUserFiles_Response.App apps = 4; */
        for (let i = 0; i < message.apps.length; i++)
            CPublishedFile_GetUserFiles_Response_App.internalBinaryWrite(message.apps[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_GetUserFiles_Response
 */
export const CPublishedFile_GetUserFiles_Response = new CPublishedFile_GetUserFiles_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_GetUserFiles_Response_App$Type extends MessageType<CPublishedFile_GetUserFiles_Response_App> {
    constructor() {
        super("CPublishedFile_GetUserFiles_Response.App", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shortcutid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "private", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_GetUserFiles_Response_App>): CPublishedFile_GetUserFiles_Response_App {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_GetUserFiles_Response_App>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_GetUserFiles_Response_App): CPublishedFile_GetUserFiles_Response_App {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint32 shortcutid */ 3:
                    message.shortcutid = reader.uint32();
                    break;
                case /* optional bool private */ 4:
                    message.private = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_GetUserFiles_Response_App, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional uint32 shortcutid = 3; */
        if (message.shortcutid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.shortcutid);
        /* optional bool private = 4; */
        if (message.private !== undefined)
            writer.tag(4, WireType.Varint).bool(message.private);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_GetUserFiles_Response.App
 */
export const CPublishedFile_GetUserFiles_Response_App = new CPublishedFile_GetUserFiles_Response_App$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Update_Request$Type extends MessageType<CPublishedFile_Update_Request> {
    constructor() {
        super("CPublishedFile_Update_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "App Id this published file belongs to." } },
            { no: 2, name: "publishedfileid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/, options: { description: "Published file id of the file we'd like update." } },
            { no: 3, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Title of the published file." } },
            { no: 4, name: "file_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Description of the published file." } },
            { no: 5, name: "visibility", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "(Optional) Visibility of the published file." } },
            { no: 6, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Set of tags for the published file." } },
            { no: 7, name: "filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Filename for the published file." } },
            { no: 8, name: "preview_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { description: "(Optional) Preview filename for the published file." } }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_Update_Request>): CPublishedFile_Update_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Update_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Update_Request): CPublishedFile_Update_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional fixed64 publishedfileid */ 2:
                    message.publishedfileid = reader.fixed64().toBigInt();
                    break;
                case /* optional string title */ 3:
                    message.title = reader.string();
                    break;
                case /* optional string file_description */ 4:
                    message.fileDescription = reader.string();
                    break;
                case /* optional uint32 visibility */ 5:
                    message.visibility = reader.uint32();
                    break;
                case /* repeated string tags */ 6:
                    message.tags.push(reader.string());
                    break;
                case /* optional string filename */ 7:
                    message.filename = reader.string();
                    break;
                case /* optional string preview_filename */ 8:
                    message.previewFilename = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_Update_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional fixed64 publishedfileid = 2; */
        if (message.publishedfileid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.publishedfileid);
        /* optional string title = 3; */
        if (message.title !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.title);
        /* optional string file_description = 4; */
        if (message.fileDescription !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.fileDescription);
        /* optional uint32 visibility = 5; */
        if (message.visibility !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.visibility);
        /* repeated string tags = 6; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.tags[i]);
        /* optional string filename = 7; */
        if (message.filename !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.filename);
        /* optional string preview_filename = 8; */
        if (message.previewFilename !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.previewFilename);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Update_Request
 */
export const CPublishedFile_Update_Request = new CPublishedFile_Update_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_Update_Response$Type extends MessageType<CPublishedFile_Update_Response> {
    constructor() {
        super("CPublishedFile_Update_Response", []);
    }
    create(value?: PartialMessage<CPublishedFile_Update_Response>): CPublishedFile_Update_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_Update_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_Update_Response): CPublishedFile_Update_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CPublishedFile_Update_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_Update_Response
 */
export const CPublishedFile_Update_Response = new CPublishedFile_Update_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_RefreshVotingQueue_Request$Type extends MessageType<CPublishedFile_RefreshVotingQueue_Request> {
    constructor() {
        super("CPublishedFile_RefreshVotingQueue_Request", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "matching_file_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "EPublishedFileInfoMatchingFileType" } },
            { no: 3, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "Include files that have all the tags or any of the tags if match_all_tags is set to false." } },
            { no: 4, name: "match_all_tags", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/, options: { description: "If true, then files must have all the tags specified.  If false, then must have at least one of the tags specified." } },
            { no: 5, name: "excluded_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { description: "Exclude any files that have any of these tags." } },
            { no: 6, name: "desired_queue_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/, options: { description: "Desired number of items in the voting queue.  May be clamped by the server" } }
        ]);
    }
    create(value?: PartialMessage<CPublishedFile_RefreshVotingQueue_Request>): CPublishedFile_RefreshVotingQueue_Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        message.excludedTags = [];
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_RefreshVotingQueue_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_RefreshVotingQueue_Request): CPublishedFile_RefreshVotingQueue_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 matching_file_type */ 2:
                    message.matchingFileType = reader.uint32();
                    break;
                case /* repeated string tags */ 3:
                    message.tags.push(reader.string());
                    break;
                case /* optional bool match_all_tags */ 4:
                    message.matchAllTags = reader.bool();
                    break;
                case /* repeated string excluded_tags */ 5:
                    message.excludedTags.push(reader.string());
                    break;
                case /* optional uint32 desired_queue_size */ 6:
                    message.desiredQueueSize = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPublishedFile_RefreshVotingQueue_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional uint32 matching_file_type = 2; */
        if (message.matchingFileType !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.matchingFileType);
        /* repeated string tags = 3; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tags[i]);
        /* optional bool match_all_tags = 4; */
        if (message.matchAllTags !== undefined)
            writer.tag(4, WireType.Varint).bool(message.matchAllTags);
        /* repeated string excluded_tags = 5; */
        for (let i = 0; i < message.excludedTags.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.excludedTags[i]);
        /* optional uint32 desired_queue_size = 6; */
        if (message.desiredQueueSize !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.desiredQueueSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_RefreshVotingQueue_Request
 */
export const CPublishedFile_RefreshVotingQueue_Request = new CPublishedFile_RefreshVotingQueue_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPublishedFile_RefreshVotingQueue_Response$Type extends MessageType<CPublishedFile_RefreshVotingQueue_Response> {
    constructor() {
        super("CPublishedFile_RefreshVotingQueue_Response", []);
    }
    create(value?: PartialMessage<CPublishedFile_RefreshVotingQueue_Response>): CPublishedFile_RefreshVotingQueue_Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPublishedFile_RefreshVotingQueue_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPublishedFile_RefreshVotingQueue_Response): CPublishedFile_RefreshVotingQueue_Response {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CPublishedFile_RefreshVotingQueue_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPublishedFile_RefreshVotingQueue_Response
 */
export const CPublishedFile_RefreshVotingQueue_Response = new CPublishedFile_RefreshVotingQueue_Response$Type();
/**
 * @generated ServiceType for protobuf service PublishedFile
 */
export const PublishedFile = new ServiceType("PublishedFile", [
    { name: "Subscribe", options: { method_description: "Subscribes the user to the published file" }, I: CPublishedFile_Subscribe_Request, O: CPublishedFile_Subscribe_Response },
    { name: "Unsubscribe", options: { method_description: "Unsubscribes the user from the published file" }, I: CPublishedFile_Unsubscribe_Request, O: CPublishedFile_Unsubscribe_Response },
    { name: "Publish", options: { method_description: "Publishes a clouded user file to the Workshop." }, I: CPublishedFile_Publish_Request, O: CPublishedFile_Publish_Response },
    { name: "GetDetails", options: { method_description: "Retrieves information about a set of published files." }, I: CPublishedFile_GetDetails_Request, O: CPublishedFile_GetDetails_Response },
    { name: "GetUserFiles", options: { method_description: "Retrieves files published by a user." }, I: CPublishedFile_GetUserFiles_Request, O: CPublishedFile_GetUserFiles_Response },
    { name: "Update", options: { method_description: "Updates information about a published file." }, I: CPublishedFile_Update_Request, O: CPublishedFile_Update_Response },
    { name: "RefreshVotingQueue", options: { method_description: "Refresh the voting queue for the user" }, I: CPublishedFile_RefreshVotingQueue_Request, O: CPublishedFile_RefreshVotingQueue_Response }
], { service_description: "A service to access published file data" });

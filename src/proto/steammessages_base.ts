// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steammessages_base.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgIPAddress
 */
export interface CMsgIPAddress {
    /**
     * @generated from protobuf oneof: ip
     */
    ip: {
        oneofKind: "v4";
        /**
         * @generated from protobuf field: fixed32 v4 = 1;
         */
        v4: number;
    } | {
        oneofKind: "v6";
        /**
         * @generated from protobuf field: bytes v6 = 2;
         */
        v6: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message CMsgIPAddressBucket
 */
export interface CMsgIPAddressBucket {
    /**
     * @generated from protobuf field: optional CMsgIPAddress original_ip_address = 1;
     */
    originalIpAddress?: CMsgIPAddress;
    /**
     * @generated from protobuf field: optional fixed64 bucket = 2;
     */
    bucket?: bigint;
}
/**
 * @generated from protobuf message CMsgProtoBufHeader
 */
export interface CMsgProtoBufHeader {
    /**
     * @generated from protobuf field: optional fixed64 steamid = 1;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional int32 client_sessionid = 2;
     */
    clientSessionid?: number;
    /**
     * @generated from protobuf field: optional uint32 routing_appid = 3;
     */
    routingAppid?: number;
    /**
     * @generated from protobuf field: optional fixed64 jobid_source = 10;
     */
    jobidSource?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 jobid_target = 11;
     */
    jobidTarget?: bigint;
    /**
     * @generated from protobuf field: optional string target_job_name = 12;
     */
    targetJobName?: string;
    /**
     * @generated from protobuf field: optional int32 seq_num = 24;
     */
    seqNum?: number;
    /**
     * @generated from protobuf field: optional int32 eresult = 13;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional string error_message = 14;
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: optional uint32 auth_account_flags = 16;
     */
    authAccountFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 token_source = 22;
     */
    tokenSource?: number;
    /**
     * @generated from protobuf field: optional bool admin_spoofing_user = 23;
     */
    adminSpoofingUser?: boolean;
    /**
     * @generated from protobuf field: optional int32 transport_error = 17;
     */
    transportError?: number;
    /**
     * @generated from protobuf field: optional uint64 messageid = 18;
     */
    messageid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 publisher_group_id = 19;
     */
    publisherGroupId?: number;
    /**
     * @generated from protobuf field: optional uint32 sysid = 20;
     */
    sysid?: number;
    /**
     * @generated from protobuf field: optional uint64 trace_tag = 21;
     */
    traceTag?: bigint;
    /**
     * @generated from protobuf field: optional uint32 webapi_key_id = 25;
     */
    webapiKeyId?: number;
    /**
     * @generated from protobuf field: optional bool is_from_external_source = 26;
     */
    isFromExternalSource?: boolean;
    /**
     * @generated from protobuf field: repeated uint32 forward_to_sysid = 27;
     */
    forwardToSysid: number[];
    /**
     * @generated from protobuf field: optional uint32 cm_sysid = 28;
     */
    cmSysid?: number;
    /**
     * @generated from protobuf field: optional uint32 launcher_type = 31;
     */
    launcherType?: number;
    /**
     * @generated from protobuf field: optional uint32 realm = 32;
     */
    realm?: number;
    /**
     * @generated from protobuf field: optional int32 timeout_ms = 33;
     */
    timeoutMs?: number;
    /**
     * @generated from protobuf field: optional string debug_source = 34;
     */
    debugSource?: string;
    /**
     * @generated from protobuf oneof: ip_addr
     */
    ipAddr: {
        oneofKind: "ip";
        /**
         * @generated from protobuf field: uint32 ip = 15;
         */
        ip: number;
    } | {
        oneofKind: "ipV6";
        /**
         * @generated from protobuf field: bytes ip_v6 = 29;
         */
        ipV6: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message CMsgMulti
 */
export interface CMsgMulti {
    /**
     * @generated from protobuf field: optional uint32 size_unzipped = 1;
     */
    sizeUnzipped?: number;
    /**
     * @generated from protobuf field: optional bytes message_body = 2;
     */
    messageBody?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgProtobufWrapped
 */
export interface CMsgProtobufWrapped {
    /**
     * @generated from protobuf field: optional bytes message_body = 1;
     */
    messageBody?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgAuthTicket
 */
export interface CMsgAuthTicket {
    /**
     * @generated from protobuf field: optional uint32 estate = 1;
     */
    estate?: number;
    /**
     * @generated from protobuf field: optional uint32 eresult = 2;
     */
    eresult?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 3;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 gameid = 4;
     */
    gameid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 h_steam_pipe = 5;
     */
    hSteamPipe?: number;
    /**
     * @generated from protobuf field: optional uint32 ticket_crc = 6;
     */
    ticketCrc?: number;
    /**
     * @generated from protobuf field: optional bytes ticket = 7;
     */
    ticket?: Uint8Array;
}
/**
 * @generated from protobuf message CCDDBAppDetailCommon
 */
export interface CCDDBAppDetailCommon {
    /**
     * @generated from protobuf field: optional uint32 appid = 1;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string icon = 3;
     */
    icon?: string;
    /**
     * @generated from protobuf field: optional bool tool = 6;
     */
    tool?: boolean;
    /**
     * @generated from protobuf field: optional bool demo = 7;
     */
    demo?: boolean;
    /**
     * @generated from protobuf field: optional bool media = 8;
     */
    media?: boolean;
    /**
     * @generated from protobuf field: optional bool community_visible_stats = 9;
     */
    communityVisibleStats?: boolean;
    /**
     * @generated from protobuf field: optional string friendly_name = 10;
     */
    friendlyName?: string;
    /**
     * @generated from protobuf field: optional string propagation = 11;
     */
    propagation?: string;
    /**
     * @generated from protobuf field: optional bool has_adult_content = 12;
     */
    hasAdultContent?: boolean;
    /**
     * @generated from protobuf field: optional bool is_visible_in_steam_china = 13;
     */
    isVisibleInSteamChina?: boolean;
    /**
     * @generated from protobuf field: optional uint32 app_type = 14;
     */
    appType?: number;
}
/**
 * @generated from protobuf message CMsgAppRights
 */
export interface CMsgAppRights {
    /**
     * @generated from protobuf field: optional bool edit_info = 1;
     */
    editInfo?: boolean;
    /**
     * @generated from protobuf field: optional bool publish = 2;
     */
    publish?: boolean;
    /**
     * @generated from protobuf field: optional bool view_error_data = 3;
     */
    viewErrorData?: boolean;
    /**
     * @generated from protobuf field: optional bool download = 4;
     */
    download?: boolean;
    /**
     * @generated from protobuf field: optional bool upload_cdkeys = 5;
     */
    uploadCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool generate_cdkeys = 6;
     */
    generateCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool view_financials = 7;
     */
    viewFinancials?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_ceg = 8;
     */
    manageCeg?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_signing = 9;
     */
    manageSigning?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_cdkeys = 10;
     */
    manageCdkeys?: boolean;
    /**
     * @generated from protobuf field: optional bool edit_marketing = 11;
     */
    editMarketing?: boolean;
    /**
     * @generated from protobuf field: optional bool economy_support = 12;
     */
    economySupport?: boolean;
    /**
     * @generated from protobuf field: optional bool economy_support_supervisor = 13;
     */
    economySupportSupervisor?: boolean;
    /**
     * @generated from protobuf field: optional bool manage_pricing = 14;
     */
    managePricing?: boolean;
    /**
     * @generated from protobuf field: optional bool broadcast_live = 15;
     */
    broadcastLive?: boolean;
    /**
     * @generated from protobuf field: optional bool view_marketing_traffic = 16;
     */
    viewMarketingTraffic?: boolean;
    /**
     * @generated from protobuf field: optional bool edit_store_display_content = 17;
     */
    editStoreDisplayContent?: boolean;
}
/**
 * @generated from protobuf message CCuratorPreferences
 */
export interface CCuratorPreferences {
    /**
     * @generated from protobuf field: optional uint32 supported_languages = 1;
     */
    supportedLanguages?: number;
    /**
     * @generated from protobuf field: optional bool platform_windows = 2;
     */
    platformWindows?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_mac = 3;
     */
    platformMac?: boolean;
    /**
     * @generated from protobuf field: optional bool platform_linux = 4;
     */
    platformLinux?: boolean;
    /**
     * @generated from protobuf field: optional bool vr_content = 5;
     */
    vrContent?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_content_violence = 6;
     */
    adultContentViolence?: boolean;
    /**
     * @generated from protobuf field: optional bool adult_content_sex = 7;
     */
    adultContentSex?: boolean;
    /**
     * @generated from protobuf field: optional uint32 timestamp_updated = 8;
     */
    timestampUpdated?: number;
    /**
     * @generated from protobuf field: repeated uint32 tagids_curated = 9;
     */
    tagidsCurated: number[];
    /**
     * @generated from protobuf field: repeated uint32 tagids_filtered = 10;
     */
    tagidsFiltered: number[];
    /**
     * @generated from protobuf field: optional string website_title = 11;
     */
    websiteTitle?: string;
    /**
     * @generated from protobuf field: optional string website_url = 12;
     */
    websiteUrl?: string;
    /**
     * @generated from protobuf field: optional string discussion_url = 13;
     */
    discussionUrl?: string;
    /**
     * @generated from protobuf field: optional bool show_broadcast = 14;
     */
    showBroadcast?: boolean;
}
/**
 * @generated from protobuf message CLocalizationToken
 */
export interface CLocalizationToken {
    /**
     * @generated from protobuf field: optional uint32 language = 1;
     */
    language?: number;
    /**
     * @generated from protobuf field: optional string localized_string = 2;
     */
    localizedString?: string;
}
/**
 * @generated from protobuf message CClanEventUserNewsTuple
 */
export interface CClanEventUserNewsTuple {
    /**
     * @generated from protobuf field: optional uint32 clanid = 1;
     */
    clanid?: number;
    /**
     * @generated from protobuf field: optional fixed64 event_gid = 2;
     */
    eventGid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 announcement_gid = 3;
     */
    announcementGid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rtime_start = 4;
     */
    rtimeStart?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime_end = 5;
     */
    rtimeEnd?: number;
    /**
     * @generated from protobuf field: optional uint32 priority_score = 6;
     */
    priorityScore?: number;
    /**
     * @generated from protobuf field: optional uint32 type = 7;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional uint32 clamp_range_slot = 8;
     */
    clampRangeSlot?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 9;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime32_last_modified = 10;
     */
    rtime32LastModified?: number;
}
/**
 * @generated from protobuf message CClanMatchEventByRange
 */
export interface CClanMatchEventByRange {
    /**
     * @generated from protobuf field: optional uint32 rtime_before = 1;
     */
    rtimeBefore?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime_after = 2;
     */
    rtimeAfter?: number;
    /**
     * @generated from protobuf field: optional uint32 qualified = 3;
     */
    qualified?: number;
    /**
     * @generated from protobuf field: repeated CClanEventUserNewsTuple events = 4;
     */
    events: CClanEventUserNewsTuple[];
}
/**
 * @generated from protobuf message CCommunity_ClanAnnouncementInfo
 */
export interface CCommunity_ClanAnnouncementInfo {
    /**
     * @generated from protobuf field: optional uint64 gid = 1;
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 clanid = 2;
     */
    clanid?: bigint;
    /**
     * @generated from protobuf field: optional uint64 posterid = 3;
     */
    posterid?: bigint;
    /**
     * @generated from protobuf field: optional string headline = 4;
     */
    headline?: string;
    /**
     * @generated from protobuf field: optional uint32 posttime = 5;
     */
    posttime?: number;
    /**
     * @generated from protobuf field: optional uint32 updatetime = 6;
     */
    updatetime?: number;
    /**
     * @generated from protobuf field: optional string body = 7;
     */
    body?: string;
    /**
     * @generated from protobuf field: optional int32 commentcount = 8;
     */
    commentcount?: number;
    /**
     * @generated from protobuf field: repeated string tags = 9;
     */
    tags: string[];
    /**
     * @generated from protobuf field: optional int32 language = 10;
     */
    language?: number;
    /**
     * @generated from protobuf field: optional bool hidden = 11;
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: optional fixed64 forum_topic_id = 12;
     */
    forumTopicId?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 event_gid = 13;
     */
    eventGid?: bigint;
    /**
     * @generated from protobuf field: optional int32 voteupcount = 14;
     */
    voteupcount?: number;
    /**
     * @generated from protobuf field: optional int32 votedowncount = 15;
     */
    votedowncount?: number;
    /**
     * @generated from protobuf field: optional EBanContentCheckResult ban_check_result = 16;
     */
    banCheckResult?: EBanContentCheckResult;
}
/**
 * @generated from protobuf message CClanEventData
 */
export interface CClanEventData {
    /**
     * @generated from protobuf field: optional fixed64 gid = 1;
     */
    gid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 clan_steamid = 2;
     */
    clanSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string event_name = 3;
     */
    eventName?: string;
    /**
     * @generated from protobuf field: optional EProtoClanEventType event_type = 4;
     */
    eventType?: EProtoClanEventType;
    /**
     * @generated from protobuf field: optional uint32 appid = 5;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional string server_address = 6;
     */
    serverAddress?: string;
    /**
     * @generated from protobuf field: optional string server_password = 7;
     */
    serverPassword?: string;
    /**
     * @generated from protobuf field: optional uint32 rtime32_start_time = 8;
     */
    rtime32StartTime?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime32_end_time = 9;
     */
    rtime32EndTime?: number;
    /**
     * @generated from protobuf field: optional int32 comment_count = 10;
     */
    commentCount?: number;
    /**
     * @generated from protobuf field: optional fixed64 creator_steamid = 11;
     */
    creatorSteamid?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 last_update_steamid = 12;
     */
    lastUpdateSteamid?: bigint;
    /**
     * @generated from protobuf field: optional string event_notes = 13;
     */
    eventNotes?: string;
    /**
     * @generated from protobuf field: optional string jsondata = 14;
     */
    jsondata?: string;
    /**
     * @generated from protobuf field: optional CCommunity_ClanAnnouncementInfo announcement_body = 15;
     */
    announcementBody?: CCommunity_ClanAnnouncementInfo;
    /**
     * @generated from protobuf field: optional bool published = 16;
     */
    published?: boolean;
    /**
     * @generated from protobuf field: optional bool hidden = 17;
     */
    hidden?: boolean;
    /**
     * @generated from protobuf field: optional uint32 rtime32_visibility_start = 18;
     */
    rtime32VisibilityStart?: number;
    /**
     * @generated from protobuf field: optional uint32 rtime32_visibility_end = 19;
     */
    rtime32VisibilityEnd?: number;
    /**
     * @generated from protobuf field: optional uint32 broadcaster_accountid = 20;
     */
    broadcasterAccountid?: number;
    /**
     * @generated from protobuf field: optional uint32 follower_count = 21;
     */
    followerCount?: number;
    /**
     * @generated from protobuf field: optional uint32 ignore_count = 22;
     */
    ignoreCount?: number;
    /**
     * @generated from protobuf field: optional fixed64 forum_topic_id = 23;
     */
    forumTopicId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rtime32_last_modified = 24;
     */
    rtime32LastModified?: number;
    /**
     * @generated from protobuf field: optional fixed64 news_post_gid = 25;
     */
    newsPostGid?: bigint;
    /**
     * @generated from protobuf field: optional uint32 rtime_mod_reviewed = 26;
     */
    rtimeModReviewed?: number;
    /**
     * @generated from protobuf field: optional uint32 featured_app_tagid = 27;
     */
    featuredAppTagid?: number;
    /**
     * @generated from protobuf field: repeated uint32 referenced_appids = 28;
     */
    referencedAppids: number[];
    /**
     * @generated from protobuf field: optional uint32 build_id = 29;
     */
    buildId?: number;
    /**
     * @generated from protobuf field: optional string build_branch = 30;
     */
    buildBranch?: string;
}
/**
 * @generated from protobuf message CBilling_Address
 */
export interface CBilling_Address {
    /**
     * @generated from protobuf field: optional string first_name = 1;
     */
    firstName?: string;
    /**
     * @generated from protobuf field: optional string last_name = 2;
     */
    lastName?: string;
    /**
     * @generated from protobuf field: optional string address1 = 3;
     */
    address1?: string;
    /**
     * @generated from protobuf field: optional string address2 = 4;
     */
    address2?: string;
    /**
     * @generated from protobuf field: optional string city = 5;
     */
    city?: string;
    /**
     * @generated from protobuf field: optional string us_state = 6;
     */
    usState?: string;
    /**
     * @generated from protobuf field: optional string country_code = 7;
     */
    countryCode?: string;
    /**
     * @generated from protobuf field: optional string postcode = 8;
     */
    postcode?: string;
    /**
     * @generated from protobuf field: optional int32 zip_plus4 = 9;
     */
    zipPlus4?: number;
    /**
     * @generated from protobuf field: optional string phone = 10;
     */
    phone?: string;
}
/**
 * @generated from protobuf message CPackageReservationStatus
 */
export interface CPackageReservationStatus {
    /**
     * @generated from protobuf field: optional uint32 packageid = 1;
     */
    packageid?: number;
    /**
     * @generated from protobuf field: optional int32 reservation_state = 2;
     */
    reservationState?: number;
    /**
     * @generated from protobuf field: optional int32 queue_position = 3;
     */
    queuePosition?: number;
    /**
     * @generated from protobuf field: optional int32 total_queue_size = 4;
     */
    totalQueueSize?: number;
    /**
     * @generated from protobuf field: optional string reservation_country_code = 5;
     */
    reservationCountryCode?: string;
    /**
     * @generated from protobuf field: optional bool expired = 6;
     */
    expired?: boolean;
    /**
     * @generated from protobuf field: optional uint32 time_expires = 7;
     */
    timeExpires?: number;
    /**
     * @generated from protobuf field: optional uint32 time_reserved = 8;
     */
    timeReserved?: number;
}
/**
 * @generated from protobuf message CMsgKeyValuePair
 */
export interface CMsgKeyValuePair {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CMsgKeyValueSet
 */
export interface CMsgKeyValueSet {
    /**
     * @generated from protobuf field: repeated CMsgKeyValuePair pairs = 1;
     */
    pairs: CMsgKeyValuePair[];
}
/**
 * @generated from protobuf enum EBanContentCheckResult
 */
export enum EBanContentCheckResult {
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_NotScanned = 0;
     */
    k_EBanContentCheckResult_NotScanned = 0,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_Reset = 1;
     */
    k_EBanContentCheckResult_Reset = 1,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_NeedsChecking = 2;
     */
    k_EBanContentCheckResult_NeedsChecking = 2,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_VeryUnlikely = 5;
     */
    k_EBanContentCheckResult_VeryUnlikely = 5,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_Unlikely = 30;
     */
    k_EBanContentCheckResult_Unlikely = 30,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_Possible = 50;
     */
    k_EBanContentCheckResult_Possible = 50,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_Likely = 75;
     */
    k_EBanContentCheckResult_Likely = 75,
    /**
     * @generated from protobuf enum value: k_EBanContentCheckResult_VeryLikely = 100;
     */
    k_EBanContentCheckResult_VeryLikely = 100
}
/**
 * @generated from protobuf enum EProtoClanEventType
 */
export enum EProtoClanEventType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: k_EClanOtherEvent = 1;
     */
    k_EClanOtherEvent = 1,
    /**
     * @generated from protobuf enum value: k_EClanGameEvent = 2;
     */
    k_EClanGameEvent = 2,
    /**
     * @generated from protobuf enum value: k_EClanPartyEvent = 3;
     */
    k_EClanPartyEvent = 3,
    /**
     * @generated from protobuf enum value: k_EClanMeetingEvent = 4;
     */
    k_EClanMeetingEvent = 4,
    /**
     * @generated from protobuf enum value: k_EClanSpecialCauseEvent = 5;
     */
    k_EClanSpecialCauseEvent = 5,
    /**
     * @generated from protobuf enum value: k_EClanMusicAndArtsEvent = 6;
     */
    k_EClanMusicAndArtsEvent = 6,
    /**
     * @generated from protobuf enum value: k_EClanSportsEvent = 7;
     */
    k_EClanSportsEvent = 7,
    /**
     * @generated from protobuf enum value: k_EClanTripEvent = 8;
     */
    k_EClanTripEvent = 8,
    /**
     * @generated from protobuf enum value: k_EClanChatEvent = 9;
     */
    k_EClanChatEvent = 9,
    /**
     * @generated from protobuf enum value: k_EClanGameReleaseEvent = 10;
     */
    k_EClanGameReleaseEvent = 10,
    /**
     * @generated from protobuf enum value: k_EClanBroadcastEvent = 11;
     */
    k_EClanBroadcastEvent = 11,
    /**
     * @generated from protobuf enum value: k_EClanSmallUpdateEvent = 12;
     */
    k_EClanSmallUpdateEvent = 12,
    /**
     * @generated from protobuf enum value: k_EClanPreAnnounceMajorUpdateEvent = 13;
     */
    k_EClanPreAnnounceMajorUpdateEvent = 13,
    /**
     * @generated from protobuf enum value: k_EClanMajorUpdateEvent = 14;
     */
    k_EClanMajorUpdateEvent = 14,
    /**
     * @generated from protobuf enum value: k_EClanDLCReleaseEvent = 15;
     */
    k_EClanDLCReleaseEvent = 15,
    /**
     * @generated from protobuf enum value: k_EClanFutureReleaseEvent = 16;
     */
    k_EClanFutureReleaseEvent = 16,
    /**
     * @generated from protobuf enum value: k_EClanESportTournamentStreamEvent = 17;
     */
    k_EClanESportTournamentStreamEvent = 17,
    /**
     * @generated from protobuf enum value: k_EClanDevStreamEvent = 18;
     */
    k_EClanDevStreamEvent = 18,
    /**
     * @generated from protobuf enum value: k_EClanFamousStreamEvent = 19;
     */
    k_EClanFamousStreamEvent = 19,
    /**
     * @generated from protobuf enum value: k_EClanGameSalesEvent = 20;
     */
    k_EClanGameSalesEvent = 20,
    /**
     * @generated from protobuf enum value: k_EClanGameItemSalesEvent = 21;
     */
    k_EClanGameItemSalesEvent = 21,
    /**
     * @generated from protobuf enum value: k_EClanInGameBonusXPEvent = 22;
     */
    k_EClanInGameBonusXPEvent = 22,
    /**
     * @generated from protobuf enum value: k_EClanInGameLootEvent = 23;
     */
    k_EClanInGameLootEvent = 23,
    /**
     * @generated from protobuf enum value: k_EClanInGamePerksEvent = 24;
     */
    k_EClanInGamePerksEvent = 24,
    /**
     * @generated from protobuf enum value: k_EClanInGameChallengeEvent = 25;
     */
    k_EClanInGameChallengeEvent = 25,
    /**
     * @generated from protobuf enum value: k_EClanInGameContestEvent = 26;
     */
    k_EClanInGameContestEvent = 26,
    /**
     * @generated from protobuf enum value: k_EClanIRLEvent = 27;
     */
    k_EClanIRLEvent = 27,
    /**
     * @generated from protobuf enum value: k_EClanNewsEvent = 28;
     */
    k_EClanNewsEvent = 28,
    /**
     * @generated from protobuf enum value: k_EClanBetaReleaseEvent = 29;
     */
    k_EClanBetaReleaseEvent = 29,
    /**
     * @generated from protobuf enum value: k_EClanInGameContentReleaseEvent = 30;
     */
    k_EClanInGameContentReleaseEvent = 30,
    /**
     * @generated from protobuf enum value: k_EClanFreeTrial = 31;
     */
    k_EClanFreeTrial = 31,
    /**
     * @generated from protobuf enum value: k_EClanSeasonRelease = 32;
     */
    k_EClanSeasonRelease = 32,
    /**
     * @generated from protobuf enum value: k_EClanSeasonUpdate = 33;
     */
    k_EClanSeasonUpdate = 33,
    /**
     * @generated from protobuf enum value: k_EClanCrosspostEvent = 34;
     */
    k_EClanCrosspostEvent = 34,
    /**
     * @generated from protobuf enum value: k_EClanInGameEventGeneral = 35;
     */
    k_EClanInGameEventGeneral = 35
}
/**
 * @generated from protobuf enum PartnerEventNotificationType
 */
export enum PartnerEventNotificationType {
    /**
     * @generated from protobuf enum value: k_EEventStart = 0;
     */
    k_EEventStart = 0,
    /**
     * @generated from protobuf enum value: k_EEventBroadcastStart = 1;
     */
    k_EEventBroadcastStart = 1,
    /**
     * @generated from protobuf enum value: k_EEventMatchStart = 2;
     */
    k_EEventMatchStart = 2,
    /**
     * @generated from protobuf enum value: k_EEventPartnerMaxType = 3;
     */
    k_EEventPartnerMaxType = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgIPAddress$Type extends MessageType<CMsgIPAddress> {
    constructor() {
        super("CMsgIPAddress", [
            { no: 1, name: "v4", kind: "scalar", oneof: "ip", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "v6", kind: "scalar", oneof: "ip", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgIPAddress>): CMsgIPAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CMsgIPAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgIPAddress): CMsgIPAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 v4 */ 1:
                    message.ip = {
                        oneofKind: "v4",
                        v4: reader.fixed32()
                    };
                    break;
                case /* bytes v6 */ 2:
                    message.ip = {
                        oneofKind: "v6",
                        v6: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgIPAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 v4 = 1; */
        if (message.ip.oneofKind === "v4")
            writer.tag(1, WireType.Bit32).fixed32(message.ip.v4);
        /* bytes v6 = 2; */
        if (message.ip.oneofKind === "v6")
            writer.tag(2, WireType.LengthDelimited).bytes(message.ip.v6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgIPAddress
 */
export const CMsgIPAddress = new CMsgIPAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgIPAddressBucket$Type extends MessageType<CMsgIPAddressBucket> {
    constructor() {
        super("CMsgIPAddressBucket", [
            { no: 1, name: "original_ip_address", kind: "message", T: () => CMsgIPAddress },
            { no: 2, name: "bucket", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgIPAddressBucket>): CMsgIPAddressBucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgIPAddressBucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgIPAddressBucket): CMsgIPAddressBucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgIPAddress original_ip_address */ 1:
                    message.originalIpAddress = CMsgIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.originalIpAddress);
                    break;
                case /* optional fixed64 bucket */ 2:
                    message.bucket = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgIPAddressBucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgIPAddress original_ip_address = 1; */
        if (message.originalIpAddress)
            CMsgIPAddress.internalBinaryWrite(message.originalIpAddress, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 bucket = 2; */
        if (message.bucket !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.bucket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgIPAddressBucket
 */
export const CMsgIPAddressBucket = new CMsgIPAddressBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgProtoBufHeader$Type extends MessageType<CMsgProtoBufHeader> {
    constructor() {
        super("CMsgProtoBufHeader", [
            { no: 1, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "client_sessionid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "routing_appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "jobid_source", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "jobid_target", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "target_job_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "seq_num", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "eresult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "auth_account_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "token_source", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "admin_spoofing_user", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "transport_error", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "messageid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "publisher_group_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "sysid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "trace_tag", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 25, name: "webapi_key_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "is_from_external_source", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "forward_to_sysid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "cm_sysid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "launcher_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "realm", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "timeout_ms", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "debug_source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "ip", kind: "scalar", oneof: "ipAddr", T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "ip_v6", kind: "scalar", oneof: "ipAddr", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgProtoBufHeader>): CMsgProtoBufHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardToSysid = [];
        message.ipAddr = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CMsgProtoBufHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgProtoBufHeader): CMsgProtoBufHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 steamid */ 1:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 client_sessionid */ 2:
                    message.clientSessionid = reader.int32();
                    break;
                case /* optional uint32 routing_appid */ 3:
                    message.routingAppid = reader.uint32();
                    break;
                case /* optional fixed64 jobid_source */ 10:
                    message.jobidSource = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 jobid_target */ 11:
                    message.jobidTarget = reader.fixed64().toBigInt();
                    break;
                case /* optional string target_job_name */ 12:
                    message.targetJobName = reader.string();
                    break;
                case /* optional int32 seq_num */ 24:
                    message.seqNum = reader.int32();
                    break;
                case /* optional int32 eresult */ 13:
                    message.eresult = reader.int32();
                    break;
                case /* optional string error_message */ 14:
                    message.errorMessage = reader.string();
                    break;
                case /* optional uint32 auth_account_flags */ 16:
                    message.authAccountFlags = reader.uint32();
                    break;
                case /* optional uint32 token_source */ 22:
                    message.tokenSource = reader.uint32();
                    break;
                case /* optional bool admin_spoofing_user */ 23:
                    message.adminSpoofingUser = reader.bool();
                    break;
                case /* optional int32 transport_error */ 17:
                    message.transportError = reader.int32();
                    break;
                case /* optional uint64 messageid */ 18:
                    message.messageid = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 publisher_group_id */ 19:
                    message.publisherGroupId = reader.uint32();
                    break;
                case /* optional uint32 sysid */ 20:
                    message.sysid = reader.uint32();
                    break;
                case /* optional uint64 trace_tag */ 21:
                    message.traceTag = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 webapi_key_id */ 25:
                    message.webapiKeyId = reader.uint32();
                    break;
                case /* optional bool is_from_external_source */ 26:
                    message.isFromExternalSource = reader.bool();
                    break;
                case /* repeated uint32 forward_to_sysid */ 27:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.forwardToSysid.push(reader.uint32());
                    else
                        message.forwardToSysid.push(reader.uint32());
                    break;
                case /* optional uint32 cm_sysid */ 28:
                    message.cmSysid = reader.uint32();
                    break;
                case /* optional uint32 launcher_type */ 31:
                    message.launcherType = reader.uint32();
                    break;
                case /* optional uint32 realm */ 32:
                    message.realm = reader.uint32();
                    break;
                case /* optional int32 timeout_ms */ 33:
                    message.timeoutMs = reader.int32();
                    break;
                case /* optional string debug_source */ 34:
                    message.debugSource = reader.string();
                    break;
                case /* uint32 ip */ 15:
                    message.ipAddr = {
                        oneofKind: "ip",
                        ip: reader.uint32()
                    };
                    break;
                case /* bytes ip_v6 */ 29:
                    message.ipAddr = {
                        oneofKind: "ipV6",
                        ipV6: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgProtoBufHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 steamid = 1; */
        if (message.steamid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.steamid);
        /* optional int32 client_sessionid = 2; */
        if (message.clientSessionid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.clientSessionid);
        /* optional uint32 routing_appid = 3; */
        if (message.routingAppid !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.routingAppid);
        /* optional fixed64 jobid_source = 10; */
        if (message.jobidSource !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.jobidSource);
        /* optional fixed64 jobid_target = 11; */
        if (message.jobidTarget !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.jobidTarget);
        /* optional string target_job_name = 12; */
        if (message.targetJobName !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.targetJobName);
        /* optional int32 seq_num = 24; */
        if (message.seqNum !== undefined)
            writer.tag(24, WireType.Varint).int32(message.seqNum);
        /* optional int32 eresult = 13; */
        if (message.eresult !== undefined)
            writer.tag(13, WireType.Varint).int32(message.eresult);
        /* optional string error_message = 14; */
        if (message.errorMessage !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.errorMessage);
        /* optional uint32 auth_account_flags = 16; */
        if (message.authAccountFlags !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.authAccountFlags);
        /* optional uint32 token_source = 22; */
        if (message.tokenSource !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.tokenSource);
        /* optional bool admin_spoofing_user = 23; */
        if (message.adminSpoofingUser !== undefined)
            writer.tag(23, WireType.Varint).bool(message.adminSpoofingUser);
        /* optional int32 transport_error = 17; */
        if (message.transportError !== undefined)
            writer.tag(17, WireType.Varint).int32(message.transportError);
        /* optional uint64 messageid = 18; */
        if (message.messageid !== undefined)
            writer.tag(18, WireType.Varint).uint64(message.messageid);
        /* optional uint32 publisher_group_id = 19; */
        if (message.publisherGroupId !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.publisherGroupId);
        /* optional uint32 sysid = 20; */
        if (message.sysid !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.sysid);
        /* optional uint64 trace_tag = 21; */
        if (message.traceTag !== undefined)
            writer.tag(21, WireType.Varint).uint64(message.traceTag);
        /* optional uint32 webapi_key_id = 25; */
        if (message.webapiKeyId !== undefined)
            writer.tag(25, WireType.Varint).uint32(message.webapiKeyId);
        /* optional bool is_from_external_source = 26; */
        if (message.isFromExternalSource !== undefined)
            writer.tag(26, WireType.Varint).bool(message.isFromExternalSource);
        /* repeated uint32 forward_to_sysid = 27; */
        for (let i = 0; i < message.forwardToSysid.length; i++)
            writer.tag(27, WireType.Varint).uint32(message.forwardToSysid[i]);
        /* optional uint32 cm_sysid = 28; */
        if (message.cmSysid !== undefined)
            writer.tag(28, WireType.Varint).uint32(message.cmSysid);
        /* optional uint32 launcher_type = 31; */
        if (message.launcherType !== undefined)
            writer.tag(31, WireType.Varint).uint32(message.launcherType);
        /* optional uint32 realm = 32; */
        if (message.realm !== undefined)
            writer.tag(32, WireType.Varint).uint32(message.realm);
        /* optional int32 timeout_ms = 33; */
        if (message.timeoutMs !== undefined)
            writer.tag(33, WireType.Varint).int32(message.timeoutMs);
        /* optional string debug_source = 34; */
        if (message.debugSource !== undefined)
            writer.tag(34, WireType.LengthDelimited).string(message.debugSource);
        /* uint32 ip = 15; */
        if (message.ipAddr.oneofKind === "ip")
            writer.tag(15, WireType.Varint).uint32(message.ipAddr.ip);
        /* bytes ip_v6 = 29; */
        if (message.ipAddr.oneofKind === "ipV6")
            writer.tag(29, WireType.LengthDelimited).bytes(message.ipAddr.ipV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgProtoBufHeader
 */
export const CMsgProtoBufHeader = new CMsgProtoBufHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgMulti$Type extends MessageType<CMsgMulti> {
    constructor() {
        super("CMsgMulti", [
            { no: 1, name: "size_unzipped", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message_body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgMulti>): CMsgMulti {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgMulti>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgMulti): CMsgMulti {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 size_unzipped */ 1:
                    message.sizeUnzipped = reader.uint32();
                    break;
                case /* optional bytes message_body */ 2:
                    message.messageBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgMulti, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 size_unzipped = 1; */
        if (message.sizeUnzipped !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.sizeUnzipped);
        /* optional bytes message_body = 2; */
        if (message.messageBody !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.messageBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgMulti
 */
export const CMsgMulti = new CMsgMulti$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgProtobufWrapped$Type extends MessageType<CMsgProtobufWrapped> {
    constructor() {
        super("CMsgProtobufWrapped", [
            { no: 1, name: "message_body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgProtobufWrapped>): CMsgProtobufWrapped {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgProtobufWrapped>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgProtobufWrapped): CMsgProtobufWrapped {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes message_body */ 1:
                    message.messageBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgProtobufWrapped, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes message_body = 1; */
        if (message.messageBody !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.messageBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgProtobufWrapped
 */
export const CMsgProtobufWrapped = new CMsgProtobufWrapped$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAuthTicket$Type extends MessageType<CMsgAuthTicket> {
    constructor() {
        super("CMsgAuthTicket", [
            { no: 1, name: "estate", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "eresult", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gameid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "h_steam_pipe", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "ticket_crc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAuthTicket>): CMsgAuthTicket {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAuthTicket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAuthTicket): CMsgAuthTicket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 estate */ 1:
                    message.estate = reader.uint32();
                    break;
                case /* optional uint32 eresult */ 2:
                    message.eresult = reader.uint32();
                    break;
                case /* optional fixed64 steamid */ 3:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 gameid */ 4:
                    message.gameid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 h_steam_pipe */ 5:
                    message.hSteamPipe = reader.uint32();
                    break;
                case /* optional uint32 ticket_crc */ 6:
                    message.ticketCrc = reader.uint32();
                    break;
                case /* optional bytes ticket */ 7:
                    message.ticket = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAuthTicket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 estate = 1; */
        if (message.estate !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.estate);
        /* optional uint32 eresult = 2; */
        if (message.eresult !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.eresult);
        /* optional fixed64 steamid = 3; */
        if (message.steamid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.steamid);
        /* optional fixed64 gameid = 4; */
        if (message.gameid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.gameid);
        /* optional uint32 h_steam_pipe = 5; */
        if (message.hSteamPipe !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.hSteamPipe);
        /* optional uint32 ticket_crc = 6; */
        if (message.ticketCrc !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.ticketCrc);
        /* optional bytes ticket = 7; */
        if (message.ticket !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.ticket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAuthTicket
 */
export const CMsgAuthTicket = new CMsgAuthTicket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCDDBAppDetailCommon$Type extends MessageType<CCDDBAppDetailCommon> {
    constructor() {
        super("CCDDBAppDetailCommon", [
            { no: 1, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "demo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "media", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "community_visible_stats", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "friendly_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "propagation", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "has_adult_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "is_visible_in_steam_china", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "app_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CCDDBAppDetailCommon>): CCDDBAppDetailCommon {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CCDDBAppDetailCommon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCDDBAppDetailCommon): CCDDBAppDetailCommon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 appid */ 1:
                    message.appid = reader.uint32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string icon */ 3:
                    message.icon = reader.string();
                    break;
                case /* optional bool tool */ 6:
                    message.tool = reader.bool();
                    break;
                case /* optional bool demo */ 7:
                    message.demo = reader.bool();
                    break;
                case /* optional bool media */ 8:
                    message.media = reader.bool();
                    break;
                case /* optional bool community_visible_stats */ 9:
                    message.communityVisibleStats = reader.bool();
                    break;
                case /* optional string friendly_name */ 10:
                    message.friendlyName = reader.string();
                    break;
                case /* optional string propagation */ 11:
                    message.propagation = reader.string();
                    break;
                case /* optional bool has_adult_content */ 12:
                    message.hasAdultContent = reader.bool();
                    break;
                case /* optional bool is_visible_in_steam_china */ 13:
                    message.isVisibleInSteamChina = reader.bool();
                    break;
                case /* optional uint32 app_type */ 14:
                    message.appType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCDDBAppDetailCommon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 appid = 1; */
        if (message.appid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.appid);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string icon = 3; */
        if (message.icon !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.icon);
        /* optional bool tool = 6; */
        if (message.tool !== undefined)
            writer.tag(6, WireType.Varint).bool(message.tool);
        /* optional bool demo = 7; */
        if (message.demo !== undefined)
            writer.tag(7, WireType.Varint).bool(message.demo);
        /* optional bool media = 8; */
        if (message.media !== undefined)
            writer.tag(8, WireType.Varint).bool(message.media);
        /* optional bool community_visible_stats = 9; */
        if (message.communityVisibleStats !== undefined)
            writer.tag(9, WireType.Varint).bool(message.communityVisibleStats);
        /* optional string friendly_name = 10; */
        if (message.friendlyName !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.friendlyName);
        /* optional string propagation = 11; */
        if (message.propagation !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.propagation);
        /* optional bool has_adult_content = 12; */
        if (message.hasAdultContent !== undefined)
            writer.tag(12, WireType.Varint).bool(message.hasAdultContent);
        /* optional bool is_visible_in_steam_china = 13; */
        if (message.isVisibleInSteamChina !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isVisibleInSteamChina);
        /* optional uint32 app_type = 14; */
        if (message.appType !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.appType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCDDBAppDetailCommon
 */
export const CCDDBAppDetailCommon = new CCDDBAppDetailCommon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgAppRights$Type extends MessageType<CMsgAppRights> {
    constructor() {
        super("CMsgAppRights", [
            { no: 1, name: "edit_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "publish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "view_error_data", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "download", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "upload_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "generate_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "view_financials", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "manage_ceg", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "manage_signing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "manage_cdkeys", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "edit_marketing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "economy_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "economy_support_supervisor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "manage_pricing", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "broadcast_live", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "view_marketing_traffic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "edit_store_display_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgAppRights>): CMsgAppRights {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgAppRights>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgAppRights): CMsgAppRights {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool edit_info */ 1:
                    message.editInfo = reader.bool();
                    break;
                case /* optional bool publish */ 2:
                    message.publish = reader.bool();
                    break;
                case /* optional bool view_error_data */ 3:
                    message.viewErrorData = reader.bool();
                    break;
                case /* optional bool download */ 4:
                    message.download = reader.bool();
                    break;
                case /* optional bool upload_cdkeys */ 5:
                    message.uploadCdkeys = reader.bool();
                    break;
                case /* optional bool generate_cdkeys */ 6:
                    message.generateCdkeys = reader.bool();
                    break;
                case /* optional bool view_financials */ 7:
                    message.viewFinancials = reader.bool();
                    break;
                case /* optional bool manage_ceg */ 8:
                    message.manageCeg = reader.bool();
                    break;
                case /* optional bool manage_signing */ 9:
                    message.manageSigning = reader.bool();
                    break;
                case /* optional bool manage_cdkeys */ 10:
                    message.manageCdkeys = reader.bool();
                    break;
                case /* optional bool edit_marketing */ 11:
                    message.editMarketing = reader.bool();
                    break;
                case /* optional bool economy_support */ 12:
                    message.economySupport = reader.bool();
                    break;
                case /* optional bool economy_support_supervisor */ 13:
                    message.economySupportSupervisor = reader.bool();
                    break;
                case /* optional bool manage_pricing */ 14:
                    message.managePricing = reader.bool();
                    break;
                case /* optional bool broadcast_live */ 15:
                    message.broadcastLive = reader.bool();
                    break;
                case /* optional bool view_marketing_traffic */ 16:
                    message.viewMarketingTraffic = reader.bool();
                    break;
                case /* optional bool edit_store_display_content */ 17:
                    message.editStoreDisplayContent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgAppRights, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool edit_info = 1; */
        if (message.editInfo !== undefined)
            writer.tag(1, WireType.Varint).bool(message.editInfo);
        /* optional bool publish = 2; */
        if (message.publish !== undefined)
            writer.tag(2, WireType.Varint).bool(message.publish);
        /* optional bool view_error_data = 3; */
        if (message.viewErrorData !== undefined)
            writer.tag(3, WireType.Varint).bool(message.viewErrorData);
        /* optional bool download = 4; */
        if (message.download !== undefined)
            writer.tag(4, WireType.Varint).bool(message.download);
        /* optional bool upload_cdkeys = 5; */
        if (message.uploadCdkeys !== undefined)
            writer.tag(5, WireType.Varint).bool(message.uploadCdkeys);
        /* optional bool generate_cdkeys = 6; */
        if (message.generateCdkeys !== undefined)
            writer.tag(6, WireType.Varint).bool(message.generateCdkeys);
        /* optional bool view_financials = 7; */
        if (message.viewFinancials !== undefined)
            writer.tag(7, WireType.Varint).bool(message.viewFinancials);
        /* optional bool manage_ceg = 8; */
        if (message.manageCeg !== undefined)
            writer.tag(8, WireType.Varint).bool(message.manageCeg);
        /* optional bool manage_signing = 9; */
        if (message.manageSigning !== undefined)
            writer.tag(9, WireType.Varint).bool(message.manageSigning);
        /* optional bool manage_cdkeys = 10; */
        if (message.manageCdkeys !== undefined)
            writer.tag(10, WireType.Varint).bool(message.manageCdkeys);
        /* optional bool edit_marketing = 11; */
        if (message.editMarketing !== undefined)
            writer.tag(11, WireType.Varint).bool(message.editMarketing);
        /* optional bool economy_support = 12; */
        if (message.economySupport !== undefined)
            writer.tag(12, WireType.Varint).bool(message.economySupport);
        /* optional bool economy_support_supervisor = 13; */
        if (message.economySupportSupervisor !== undefined)
            writer.tag(13, WireType.Varint).bool(message.economySupportSupervisor);
        /* optional bool manage_pricing = 14; */
        if (message.managePricing !== undefined)
            writer.tag(14, WireType.Varint).bool(message.managePricing);
        /* optional bool broadcast_live = 15; */
        if (message.broadcastLive !== undefined)
            writer.tag(15, WireType.Varint).bool(message.broadcastLive);
        /* optional bool view_marketing_traffic = 16; */
        if (message.viewMarketingTraffic !== undefined)
            writer.tag(16, WireType.Varint).bool(message.viewMarketingTraffic);
        /* optional bool edit_store_display_content = 17; */
        if (message.editStoreDisplayContent !== undefined)
            writer.tag(17, WireType.Varint).bool(message.editStoreDisplayContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgAppRights
 */
export const CMsgAppRights = new CMsgAppRights$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCuratorPreferences$Type extends MessageType<CCuratorPreferences> {
    constructor() {
        super("CCuratorPreferences", [
            { no: 1, name: "supported_languages", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "platform_windows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "platform_mac", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "platform_linux", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "vr_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "adult_content_violence", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "adult_content_sex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "timestamp_updated", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "tagids_curated", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tagids_filtered", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "website_title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "website_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "discussion_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "show_broadcast", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CCuratorPreferences>): CCuratorPreferences {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagidsCurated = [];
        message.tagidsFiltered = [];
        if (value !== undefined)
            reflectionMergePartial<CCuratorPreferences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCuratorPreferences): CCuratorPreferences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 supported_languages */ 1:
                    message.supportedLanguages = reader.uint32();
                    break;
                case /* optional bool platform_windows */ 2:
                    message.platformWindows = reader.bool();
                    break;
                case /* optional bool platform_mac */ 3:
                    message.platformMac = reader.bool();
                    break;
                case /* optional bool platform_linux */ 4:
                    message.platformLinux = reader.bool();
                    break;
                case /* optional bool vr_content */ 5:
                    message.vrContent = reader.bool();
                    break;
                case /* optional bool adult_content_violence */ 6:
                    message.adultContentViolence = reader.bool();
                    break;
                case /* optional bool adult_content_sex */ 7:
                    message.adultContentSex = reader.bool();
                    break;
                case /* optional uint32 timestamp_updated */ 8:
                    message.timestampUpdated = reader.uint32();
                    break;
                case /* repeated uint32 tagids_curated */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagidsCurated.push(reader.uint32());
                    else
                        message.tagidsCurated.push(reader.uint32());
                    break;
                case /* repeated uint32 tagids_filtered */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagidsFiltered.push(reader.uint32());
                    else
                        message.tagidsFiltered.push(reader.uint32());
                    break;
                case /* optional string website_title */ 11:
                    message.websiteTitle = reader.string();
                    break;
                case /* optional string website_url */ 12:
                    message.websiteUrl = reader.string();
                    break;
                case /* optional string discussion_url */ 13:
                    message.discussionUrl = reader.string();
                    break;
                case /* optional bool show_broadcast */ 14:
                    message.showBroadcast = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCuratorPreferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 supported_languages = 1; */
        if (message.supportedLanguages !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.supportedLanguages);
        /* optional bool platform_windows = 2; */
        if (message.platformWindows !== undefined)
            writer.tag(2, WireType.Varint).bool(message.platformWindows);
        /* optional bool platform_mac = 3; */
        if (message.platformMac !== undefined)
            writer.tag(3, WireType.Varint).bool(message.platformMac);
        /* optional bool platform_linux = 4; */
        if (message.platformLinux !== undefined)
            writer.tag(4, WireType.Varint).bool(message.platformLinux);
        /* optional bool vr_content = 5; */
        if (message.vrContent !== undefined)
            writer.tag(5, WireType.Varint).bool(message.vrContent);
        /* optional bool adult_content_violence = 6; */
        if (message.adultContentViolence !== undefined)
            writer.tag(6, WireType.Varint).bool(message.adultContentViolence);
        /* optional bool adult_content_sex = 7; */
        if (message.adultContentSex !== undefined)
            writer.tag(7, WireType.Varint).bool(message.adultContentSex);
        /* optional uint32 timestamp_updated = 8; */
        if (message.timestampUpdated !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.timestampUpdated);
        /* repeated uint32 tagids_curated = 9; */
        for (let i = 0; i < message.tagidsCurated.length; i++)
            writer.tag(9, WireType.Varint).uint32(message.tagidsCurated[i]);
        /* repeated uint32 tagids_filtered = 10; */
        for (let i = 0; i < message.tagidsFiltered.length; i++)
            writer.tag(10, WireType.Varint).uint32(message.tagidsFiltered[i]);
        /* optional string website_title = 11; */
        if (message.websiteTitle !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.websiteTitle);
        /* optional string website_url = 12; */
        if (message.websiteUrl !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.websiteUrl);
        /* optional string discussion_url = 13; */
        if (message.discussionUrl !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.discussionUrl);
        /* optional bool show_broadcast = 14; */
        if (message.showBroadcast !== undefined)
            writer.tag(14, WireType.Varint).bool(message.showBroadcast);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCuratorPreferences
 */
export const CCuratorPreferences = new CCuratorPreferences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CLocalizationToken$Type extends MessageType<CLocalizationToken> {
    constructor() {
        super("CLocalizationToken", [
            { no: 1, name: "language", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "localized_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CLocalizationToken>): CLocalizationToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CLocalizationToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CLocalizationToken): CLocalizationToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 language */ 1:
                    message.language = reader.uint32();
                    break;
                case /* optional string localized_string */ 2:
                    message.localizedString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CLocalizationToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 language = 1; */
        if (message.language !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.language);
        /* optional string localized_string = 2; */
        if (message.localizedString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.localizedString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CLocalizationToken
 */
export const CLocalizationToken = new CLocalizationToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClanEventUserNewsTuple$Type extends MessageType<CClanEventUserNewsTuple> {
    constructor() {
        super("CClanEventUserNewsTuple", [
            { no: 1, name: "clanid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "event_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "announcement_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "rtime_start", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "rtime_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "priority_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "clamp_range_slot", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "rtime32_last_modified", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CClanEventUserNewsTuple>): CClanEventUserNewsTuple {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CClanEventUserNewsTuple>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClanEventUserNewsTuple): CClanEventUserNewsTuple {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 clanid */ 1:
                    message.clanid = reader.uint32();
                    break;
                case /* optional fixed64 event_gid */ 2:
                    message.eventGid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 announcement_gid */ 3:
                    message.announcementGid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 rtime_start */ 4:
                    message.rtimeStart = reader.uint32();
                    break;
                case /* optional uint32 rtime_end */ 5:
                    message.rtimeEnd = reader.uint32();
                    break;
                case /* optional uint32 priority_score */ 6:
                    message.priorityScore = reader.uint32();
                    break;
                case /* optional uint32 type */ 7:
                    message.type = reader.uint32();
                    break;
                case /* optional uint32 clamp_range_slot */ 8:
                    message.clampRangeSlot = reader.uint32();
                    break;
                case /* optional uint32 appid */ 9:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 rtime32_last_modified */ 10:
                    message.rtime32LastModified = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClanEventUserNewsTuple, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 clanid = 1; */
        if (message.clanid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.clanid);
        /* optional fixed64 event_gid = 2; */
        if (message.eventGid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.eventGid);
        /* optional fixed64 announcement_gid = 3; */
        if (message.announcementGid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.announcementGid);
        /* optional uint32 rtime_start = 4; */
        if (message.rtimeStart !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.rtimeStart);
        /* optional uint32 rtime_end = 5; */
        if (message.rtimeEnd !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.rtimeEnd);
        /* optional uint32 priority_score = 6; */
        if (message.priorityScore !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.priorityScore);
        /* optional uint32 type = 7; */
        if (message.type !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.type);
        /* optional uint32 clamp_range_slot = 8; */
        if (message.clampRangeSlot !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.clampRangeSlot);
        /* optional uint32 appid = 9; */
        if (message.appid !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.appid);
        /* optional uint32 rtime32_last_modified = 10; */
        if (message.rtime32LastModified !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.rtime32LastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClanEventUserNewsTuple
 */
export const CClanEventUserNewsTuple = new CClanEventUserNewsTuple$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClanMatchEventByRange$Type extends MessageType<CClanMatchEventByRange> {
    constructor() {
        super("CClanMatchEventByRange", [
            { no: 1, name: "rtime_before", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rtime_after", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "qualified", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CClanEventUserNewsTuple }
        ]);
    }
    create(value?: PartialMessage<CClanMatchEventByRange>): CClanMatchEventByRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<CClanMatchEventByRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClanMatchEventByRange): CClanMatchEventByRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 rtime_before */ 1:
                    message.rtimeBefore = reader.uint32();
                    break;
                case /* optional uint32 rtime_after */ 2:
                    message.rtimeAfter = reader.uint32();
                    break;
                case /* optional uint32 qualified */ 3:
                    message.qualified = reader.uint32();
                    break;
                case /* repeated CClanEventUserNewsTuple events */ 4:
                    message.events.push(CClanEventUserNewsTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClanMatchEventByRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 rtime_before = 1; */
        if (message.rtimeBefore !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.rtimeBefore);
        /* optional uint32 rtime_after = 2; */
        if (message.rtimeAfter !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.rtimeAfter);
        /* optional uint32 qualified = 3; */
        if (message.qualified !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.qualified);
        /* repeated CClanEventUserNewsTuple events = 4; */
        for (let i = 0; i < message.events.length; i++)
            CClanEventUserNewsTuple.internalBinaryWrite(message.events[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClanMatchEventByRange
 */
export const CClanMatchEventByRange = new CClanMatchEventByRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CCommunity_ClanAnnouncementInfo$Type extends MessageType<CCommunity_ClanAnnouncementInfo> {
    constructor() {
        super("CCommunity_ClanAnnouncementInfo", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clanid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "posterid", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "headline", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "posttime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "updatetime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "body", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "commentcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "language", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "forum_topic_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "event_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "voteupcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "votedowncount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "ban_check_result", kind: "enum", opt: true, T: () => ["EBanContentCheckResult", EBanContentCheckResult] }
        ]);
    }
    create(value?: PartialMessage<CCommunity_ClanAnnouncementInfo>): CCommunity_ClanAnnouncementInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<CCommunity_ClanAnnouncementInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CCommunity_ClanAnnouncementInfo): CCommunity_ClanAnnouncementInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 gid */ 1:
                    message.gid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 clanid */ 2:
                    message.clanid = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 posterid */ 3:
                    message.posterid = reader.uint64().toBigInt();
                    break;
                case /* optional string headline */ 4:
                    message.headline = reader.string();
                    break;
                case /* optional uint32 posttime */ 5:
                    message.posttime = reader.uint32();
                    break;
                case /* optional uint32 updatetime */ 6:
                    message.updatetime = reader.uint32();
                    break;
                case /* optional string body */ 7:
                    message.body = reader.string();
                    break;
                case /* optional int32 commentcount */ 8:
                    message.commentcount = reader.int32();
                    break;
                case /* repeated string tags */ 9:
                    message.tags.push(reader.string());
                    break;
                case /* optional int32 language */ 10:
                    message.language = reader.int32();
                    break;
                case /* optional bool hidden */ 11:
                    message.hidden = reader.bool();
                    break;
                case /* optional fixed64 forum_topic_id */ 12:
                    message.forumTopicId = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 event_gid */ 13:
                    message.eventGid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 voteupcount */ 14:
                    message.voteupcount = reader.int32();
                    break;
                case /* optional int32 votedowncount */ 15:
                    message.votedowncount = reader.int32();
                    break;
                case /* optional EBanContentCheckResult ban_check_result */ 16:
                    message.banCheckResult = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CCommunity_ClanAnnouncementInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.gid);
        /* optional uint64 clanid = 2; */
        if (message.clanid !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.clanid);
        /* optional uint64 posterid = 3; */
        if (message.posterid !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.posterid);
        /* optional string headline = 4; */
        if (message.headline !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.headline);
        /* optional uint32 posttime = 5; */
        if (message.posttime !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.posttime);
        /* optional uint32 updatetime = 6; */
        if (message.updatetime !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.updatetime);
        /* optional string body = 7; */
        if (message.body !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.body);
        /* optional int32 commentcount = 8; */
        if (message.commentcount !== undefined)
            writer.tag(8, WireType.Varint).int32(message.commentcount);
        /* repeated string tags = 9; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.tags[i]);
        /* optional int32 language = 10; */
        if (message.language !== undefined)
            writer.tag(10, WireType.Varint).int32(message.language);
        /* optional bool hidden = 11; */
        if (message.hidden !== undefined)
            writer.tag(11, WireType.Varint).bool(message.hidden);
        /* optional fixed64 forum_topic_id = 12; */
        if (message.forumTopicId !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.forumTopicId);
        /* optional fixed64 event_gid = 13; */
        if (message.eventGid !== undefined)
            writer.tag(13, WireType.Bit64).fixed64(message.eventGid);
        /* optional int32 voteupcount = 14; */
        if (message.voteupcount !== undefined)
            writer.tag(14, WireType.Varint).int32(message.voteupcount);
        /* optional int32 votedowncount = 15; */
        if (message.votedowncount !== undefined)
            writer.tag(15, WireType.Varint).int32(message.votedowncount);
        /* optional EBanContentCheckResult ban_check_result = 16; */
        if (message.banCheckResult !== undefined)
            writer.tag(16, WireType.Varint).int32(message.banCheckResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CCommunity_ClanAnnouncementInfo
 */
export const CCommunity_ClanAnnouncementInfo = new CCommunity_ClanAnnouncementInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CClanEventData$Type extends MessageType<CClanEventData> {
    constructor() {
        super("CClanEventData", [
            { no: 1, name: "gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clan_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "event_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event_type", kind: "enum", opt: true, T: () => ["EProtoClanEventType", EProtoClanEventType] },
            { no: 5, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "server_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "server_password", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "rtime32_start_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "rtime32_end_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "comment_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "creator_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "last_update_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "event_notes", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "jsondata", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "announcement_body", kind: "message", T: () => CCommunity_ClanAnnouncementInfo },
            { no: 16, name: "published", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "rtime32_visibility_start", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "rtime32_visibility_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "broadcaster_accountid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "follower_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "ignore_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "forum_topic_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 24, name: "rtime32_last_modified", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "news_post_gid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 26, name: "rtime_mod_reviewed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "featured_app_tagid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "referenced_appids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "build_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "build_branch", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CClanEventData>): CClanEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.referencedAppids = [];
        if (value !== undefined)
            reflectionMergePartial<CClanEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CClanEventData): CClanEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed64 gid */ 1:
                    message.gid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 clan_steamid */ 2:
                    message.clanSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string event_name */ 3:
                    message.eventName = reader.string();
                    break;
                case /* optional EProtoClanEventType event_type */ 4:
                    message.eventType = reader.int32();
                    break;
                case /* optional uint32 appid */ 5:
                    message.appid = reader.uint32();
                    break;
                case /* optional string server_address */ 6:
                    message.serverAddress = reader.string();
                    break;
                case /* optional string server_password */ 7:
                    message.serverPassword = reader.string();
                    break;
                case /* optional uint32 rtime32_start_time */ 8:
                    message.rtime32StartTime = reader.uint32();
                    break;
                case /* optional uint32 rtime32_end_time */ 9:
                    message.rtime32EndTime = reader.uint32();
                    break;
                case /* optional int32 comment_count */ 10:
                    message.commentCount = reader.int32();
                    break;
                case /* optional fixed64 creator_steamid */ 11:
                    message.creatorSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 last_update_steamid */ 12:
                    message.lastUpdateSteamid = reader.fixed64().toBigInt();
                    break;
                case /* optional string event_notes */ 13:
                    message.eventNotes = reader.string();
                    break;
                case /* optional string jsondata */ 14:
                    message.jsondata = reader.string();
                    break;
                case /* optional CCommunity_ClanAnnouncementInfo announcement_body */ 15:
                    message.announcementBody = CCommunity_ClanAnnouncementInfo.internalBinaryRead(reader, reader.uint32(), options, message.announcementBody);
                    break;
                case /* optional bool published */ 16:
                    message.published = reader.bool();
                    break;
                case /* optional bool hidden */ 17:
                    message.hidden = reader.bool();
                    break;
                case /* optional uint32 rtime32_visibility_start */ 18:
                    message.rtime32VisibilityStart = reader.uint32();
                    break;
                case /* optional uint32 rtime32_visibility_end */ 19:
                    message.rtime32VisibilityEnd = reader.uint32();
                    break;
                case /* optional uint32 broadcaster_accountid */ 20:
                    message.broadcasterAccountid = reader.uint32();
                    break;
                case /* optional uint32 follower_count */ 21:
                    message.followerCount = reader.uint32();
                    break;
                case /* optional uint32 ignore_count */ 22:
                    message.ignoreCount = reader.uint32();
                    break;
                case /* optional fixed64 forum_topic_id */ 23:
                    message.forumTopicId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 rtime32_last_modified */ 24:
                    message.rtime32LastModified = reader.uint32();
                    break;
                case /* optional fixed64 news_post_gid */ 25:
                    message.newsPostGid = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 rtime_mod_reviewed */ 26:
                    message.rtimeModReviewed = reader.uint32();
                    break;
                case /* optional uint32 featured_app_tagid */ 27:
                    message.featuredAppTagid = reader.uint32();
                    break;
                case /* repeated uint32 referenced_appids */ 28:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.referencedAppids.push(reader.uint32());
                    else
                        message.referencedAppids.push(reader.uint32());
                    break;
                case /* optional uint32 build_id */ 29:
                    message.buildId = reader.uint32();
                    break;
                case /* optional string build_branch */ 30:
                    message.buildBranch = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CClanEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed64 gid = 1; */
        if (message.gid !== undefined)
            writer.tag(1, WireType.Bit64).fixed64(message.gid);
        /* optional fixed64 clan_steamid = 2; */
        if (message.clanSteamid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.clanSteamid);
        /* optional string event_name = 3; */
        if (message.eventName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.eventName);
        /* optional EProtoClanEventType event_type = 4; */
        if (message.eventType !== undefined)
            writer.tag(4, WireType.Varint).int32(message.eventType);
        /* optional uint32 appid = 5; */
        if (message.appid !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.appid);
        /* optional string server_address = 6; */
        if (message.serverAddress !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.serverAddress);
        /* optional string server_password = 7; */
        if (message.serverPassword !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.serverPassword);
        /* optional uint32 rtime32_start_time = 8; */
        if (message.rtime32StartTime !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.rtime32StartTime);
        /* optional uint32 rtime32_end_time = 9; */
        if (message.rtime32EndTime !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.rtime32EndTime);
        /* optional int32 comment_count = 10; */
        if (message.commentCount !== undefined)
            writer.tag(10, WireType.Varint).int32(message.commentCount);
        /* optional fixed64 creator_steamid = 11; */
        if (message.creatorSteamid !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.creatorSteamid);
        /* optional fixed64 last_update_steamid = 12; */
        if (message.lastUpdateSteamid !== undefined)
            writer.tag(12, WireType.Bit64).fixed64(message.lastUpdateSteamid);
        /* optional string event_notes = 13; */
        if (message.eventNotes !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.eventNotes);
        /* optional string jsondata = 14; */
        if (message.jsondata !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.jsondata);
        /* optional CCommunity_ClanAnnouncementInfo announcement_body = 15; */
        if (message.announcementBody)
            CCommunity_ClanAnnouncementInfo.internalBinaryWrite(message.announcementBody, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional bool published = 16; */
        if (message.published !== undefined)
            writer.tag(16, WireType.Varint).bool(message.published);
        /* optional bool hidden = 17; */
        if (message.hidden !== undefined)
            writer.tag(17, WireType.Varint).bool(message.hidden);
        /* optional uint32 rtime32_visibility_start = 18; */
        if (message.rtime32VisibilityStart !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.rtime32VisibilityStart);
        /* optional uint32 rtime32_visibility_end = 19; */
        if (message.rtime32VisibilityEnd !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.rtime32VisibilityEnd);
        /* optional uint32 broadcaster_accountid = 20; */
        if (message.broadcasterAccountid !== undefined)
            writer.tag(20, WireType.Varint).uint32(message.broadcasterAccountid);
        /* optional uint32 follower_count = 21; */
        if (message.followerCount !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.followerCount);
        /* optional uint32 ignore_count = 22; */
        if (message.ignoreCount !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.ignoreCount);
        /* optional fixed64 forum_topic_id = 23; */
        if (message.forumTopicId !== undefined)
            writer.tag(23, WireType.Bit64).fixed64(message.forumTopicId);
        /* optional uint32 rtime32_last_modified = 24; */
        if (message.rtime32LastModified !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.rtime32LastModified);
        /* optional fixed64 news_post_gid = 25; */
        if (message.newsPostGid !== undefined)
            writer.tag(25, WireType.Bit64).fixed64(message.newsPostGid);
        /* optional uint32 rtime_mod_reviewed = 26; */
        if (message.rtimeModReviewed !== undefined)
            writer.tag(26, WireType.Varint).uint32(message.rtimeModReviewed);
        /* optional uint32 featured_app_tagid = 27; */
        if (message.featuredAppTagid !== undefined)
            writer.tag(27, WireType.Varint).uint32(message.featuredAppTagid);
        /* repeated uint32 referenced_appids = 28; */
        for (let i = 0; i < message.referencedAppids.length; i++)
            writer.tag(28, WireType.Varint).uint32(message.referencedAppids[i]);
        /* optional uint32 build_id = 29; */
        if (message.buildId !== undefined)
            writer.tag(29, WireType.Varint).uint32(message.buildId);
        /* optional string build_branch = 30; */
        if (message.buildBranch !== undefined)
            writer.tag(30, WireType.LengthDelimited).string(message.buildBranch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CClanEventData
 */
export const CClanEventData = new CClanEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CBilling_Address$Type extends MessageType<CBilling_Address> {
    constructor() {
        super("CBilling_Address", [
            { no: 1, name: "first_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "address2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "city", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "us_state", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "postcode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "zip_plus4", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "phone", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CBilling_Address>): CBilling_Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CBilling_Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CBilling_Address): CBilling_Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string first_name */ 1:
                    message.firstName = reader.string();
                    break;
                case /* optional string last_name */ 2:
                    message.lastName = reader.string();
                    break;
                case /* optional string address1 */ 3:
                    message.address1 = reader.string();
                    break;
                case /* optional string address2 */ 4:
                    message.address2 = reader.string();
                    break;
                case /* optional string city */ 5:
                    message.city = reader.string();
                    break;
                case /* optional string us_state */ 6:
                    message.usState = reader.string();
                    break;
                case /* optional string country_code */ 7:
                    message.countryCode = reader.string();
                    break;
                case /* optional string postcode */ 8:
                    message.postcode = reader.string();
                    break;
                case /* optional int32 zip_plus4 */ 9:
                    message.zipPlus4 = reader.int32();
                    break;
                case /* optional string phone */ 10:
                    message.phone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CBilling_Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string first_name = 1; */
        if (message.firstName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.firstName);
        /* optional string last_name = 2; */
        if (message.lastName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.lastName);
        /* optional string address1 = 3; */
        if (message.address1 !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.address1);
        /* optional string address2 = 4; */
        if (message.address2 !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.address2);
        /* optional string city = 5; */
        if (message.city !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.city);
        /* optional string us_state = 6; */
        if (message.usState !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.usState);
        /* optional string country_code = 7; */
        if (message.countryCode !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.countryCode);
        /* optional string postcode = 8; */
        if (message.postcode !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.postcode);
        /* optional int32 zip_plus4 = 9; */
        if (message.zipPlus4 !== undefined)
            writer.tag(9, WireType.Varint).int32(message.zipPlus4);
        /* optional string phone = 10; */
        if (message.phone !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.phone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CBilling_Address
 */
export const CBilling_Address = new CBilling_Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CPackageReservationStatus$Type extends MessageType<CPackageReservationStatus> {
    constructor() {
        super("CPackageReservationStatus", [
            { no: 1, name: "packageid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "reservation_state", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "queue_position", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "total_queue_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "reservation_country_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "expired", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "time_expires", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "time_reserved", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CPackageReservationStatus>): CPackageReservationStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CPackageReservationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CPackageReservationStatus): CPackageReservationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 packageid */ 1:
                    message.packageid = reader.uint32();
                    break;
                case /* optional int32 reservation_state */ 2:
                    message.reservationState = reader.int32();
                    break;
                case /* optional int32 queue_position */ 3:
                    message.queuePosition = reader.int32();
                    break;
                case /* optional int32 total_queue_size */ 4:
                    message.totalQueueSize = reader.int32();
                    break;
                case /* optional string reservation_country_code */ 5:
                    message.reservationCountryCode = reader.string();
                    break;
                case /* optional bool expired */ 6:
                    message.expired = reader.bool();
                    break;
                case /* optional uint32 time_expires */ 7:
                    message.timeExpires = reader.uint32();
                    break;
                case /* optional uint32 time_reserved */ 8:
                    message.timeReserved = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CPackageReservationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 packageid = 1; */
        if (message.packageid !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.packageid);
        /* optional int32 reservation_state = 2; */
        if (message.reservationState !== undefined)
            writer.tag(2, WireType.Varint).int32(message.reservationState);
        /* optional int32 queue_position = 3; */
        if (message.queuePosition !== undefined)
            writer.tag(3, WireType.Varint).int32(message.queuePosition);
        /* optional int32 total_queue_size = 4; */
        if (message.totalQueueSize !== undefined)
            writer.tag(4, WireType.Varint).int32(message.totalQueueSize);
        /* optional string reservation_country_code = 5; */
        if (message.reservationCountryCode !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.reservationCountryCode);
        /* optional bool expired = 6; */
        if (message.expired !== undefined)
            writer.tag(6, WireType.Varint).bool(message.expired);
        /* optional uint32 time_expires = 7; */
        if (message.timeExpires !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.timeExpires);
        /* optional uint32 time_reserved = 8; */
        if (message.timeReserved !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.timeReserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CPackageReservationStatus
 */
export const CPackageReservationStatus = new CPackageReservationStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgKeyValuePair$Type extends MessageType<CMsgKeyValuePair> {
    constructor() {
        super("CMsgKeyValuePair", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgKeyValuePair>): CMsgKeyValuePair {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgKeyValuePair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgKeyValuePair): CMsgKeyValuePair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgKeyValuePair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgKeyValuePair
 */
export const CMsgKeyValuePair = new CMsgKeyValuePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgKeyValueSet$Type extends MessageType<CMsgKeyValueSet> {
    constructor() {
        super("CMsgKeyValueSet", [
            { no: 1, name: "pairs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgKeyValuePair }
        ]);
    }
    create(value?: PartialMessage<CMsgKeyValueSet>): CMsgKeyValueSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pairs = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgKeyValueSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgKeyValueSet): CMsgKeyValueSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgKeyValuePair pairs */ 1:
                    message.pairs.push(CMsgKeyValuePair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgKeyValueSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgKeyValuePair pairs = 1; */
        for (let i = 0; i < message.pairs.length; i++)
            CMsgKeyValuePair.internalBinaryWrite(message.pairs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgKeyValueSet
 */
export const CMsgKeyValueSet = new CMsgKeyValueSet$Type();

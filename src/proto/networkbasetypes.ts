// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "networkbasetypes.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message CMsgVector
 */
export interface CMsgVector {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
    /**
     * @generated from protobuf field: optional float w = 4;
     */
    w?: number;
}
/**
 * @generated from protobuf message CMsgVector2D
 */
export interface CMsgVector2D {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
}
/**
 * @generated from protobuf message CMsgQAngle
 */
export interface CMsgQAngle {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
}
/**
 * @generated from protobuf message CMsgQuaternion
 */
export interface CMsgQuaternion {
    /**
     * @generated from protobuf field: optional float x = 1;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional float y = 2;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional float z = 3;
     */
    z?: number;
    /**
     * @generated from protobuf field: optional float w = 4;
     */
    w?: number;
}
/**
 * @generated from protobuf message CMsgTransform
 */
export interface CMsgTransform {
    /**
     * @generated from protobuf field: optional CMsgVector position = 1;
     */
    position?: CMsgVector;
    /**
     * @generated from protobuf field: optional float scale = 2;
     */
    scale?: number;
    /**
     * @generated from protobuf field: optional CMsgQuaternion orientation = 3;
     */
    orientation?: CMsgQuaternion;
}
/**
 * @generated from protobuf message CMsgRGBA
 */
export interface CMsgRGBA {
    /**
     * @generated from protobuf field: optional int32 r = 1;
     */
    r?: number;
    /**
     * @generated from protobuf field: optional int32 g = 2;
     */
    g?: number;
    /**
     * @generated from protobuf field: optional int32 b = 3;
     */
    b?: number;
    /**
     * @generated from protobuf field: optional int32 a = 4;
     */
    a?: number;
}
/**
 * @generated from protobuf message CMsgPlayerInfo
 */
export interface CMsgPlayerInfo {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional fixed64 xuid = 2;
     */
    xuid?: bigint;
    /**
     * @generated from protobuf field: optional int32 userid = 3;
     */
    userid?: number;
    /**
     * @generated from protobuf field: optional fixed64 steamid = 4;
     */
    steamid?: bigint;
    /**
     * @generated from protobuf field: optional bool fakeplayer = 5;
     */
    fakeplayer?: boolean;
    /**
     * @generated from protobuf field: optional bool ishltv = 6;
     */
    ishltv?: boolean;
}
/**
 * @generated from protobuf message CEntityMsg
 */
export interface CEntityMsg {
    /**
     * @generated from protobuf field: optional uint32 target_entity = 1;
     */
    targetEntity?: number;
}
/**
 * @generated from protobuf message CMsg_CVars
 */
export interface CMsg_CVars {
    /**
     * @generated from protobuf field: repeated CMsg_CVars.CVar cvars = 1;
     */
    cvars: CMsg_CVars_CVar[];
}
/**
 * @generated from protobuf message CMsg_CVars.CVar
 */
export interface CMsg_CVars_CVar {
    /**
     * @generated from protobuf field: optional string name = 1;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string value = 2;
     */
    value?: string;
}
/**
 * @generated from protobuf message CNETMsg_NOP
 */
export interface CNETMsg_NOP {
}
/**
 * @generated from protobuf message CNETMsg_SplitScreenUser
 */
export interface CNETMsg_SplitScreenUser {
    /**
     * @generated from protobuf field: optional int32 slot = 1;
     */
    slot?: number;
}
/**
 * @generated from protobuf message CNETMsg_Tick
 */
export interface CNETMsg_Tick {
    /**
     * @generated from protobuf field: optional uint32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional uint32 host_frametime = 2;
     */
    hostFrametime?: number;
    /**
     * @generated from protobuf field: optional uint32 host_frametime_std_deviation = 3;
     */
    hostFrametimeStdDeviation?: number;
    /**
     * @generated from protobuf field: optional uint32 host_computationtime = 4;
     */
    hostComputationtime?: number;
    /**
     * @generated from protobuf field: optional uint32 host_computationtime_std_deviation = 5;
     */
    hostComputationtimeStdDeviation?: number;
    /**
     * @generated from protobuf field: optional uint32 host_framestarttime_std_deviation = 6;
     */
    hostFramestarttimeStdDeviation?: number;
    /**
     * @generated from protobuf field: optional uint32 host_loss = 7;
     */
    hostLoss?: number;
    /**
     * @generated from protobuf field: optional uint32 host_unfiltered_frametime = 8;
     */
    hostUnfilteredFrametime?: number;
    /**
     * @generated from protobuf field: optional uint32 hltv_replay_flags = 9;
     */
    hltvReplayFlags?: number;
    /**
     * @generated from protobuf field: optional uint32 expected_long_tick = 10;
     */
    expectedLongTick?: number;
    /**
     * @generated from protobuf field: optional string expected_long_tick_reason = 11;
     */
    expectedLongTickReason?: string;
    /**
     * @generated from protobuf field: optional uint32 jitter = 12;
     */
    jitter?: number;
}
/**
 * @generated from protobuf message CNETMsg_StringCmd
 */
export interface CNETMsg_StringCmd {
    /**
     * @generated from protobuf field: optional string command = 1;
     */
    command?: string;
    /**
     * @generated from protobuf field: optional uint32 prediction_sync = 2;
     */
    predictionSync?: number;
}
/**
 * @generated from protobuf message CNETMsg_SetConVar
 */
export interface CNETMsg_SetConVar {
    /**
     * @generated from protobuf field: optional CMsg_CVars convars = 1;
     */
    convars?: CMsg_CVars;
}
/**
 * @generated from protobuf message CNETMsg_SignonState
 */
export interface CNETMsg_SignonState {
    /**
     * @generated from protobuf field: optional SignonState_t signon_state = 1;
     */
    signonState?: SignonState_t;
    /**
     * @generated from protobuf field: optional uint32 spawn_count = 2;
     */
    spawnCount?: number;
    /**
     * @generated from protobuf field: optional uint32 num_server_players = 3;
     */
    numServerPlayers?: number;
    /**
     * @generated from protobuf field: repeated string players_networkids = 4;
     */
    playersNetworkids: string[];
    /**
     * @generated from protobuf field: optional string map_name = 5;
     */
    mapName?: string;
    /**
     * @generated from protobuf field: optional string addons = 6;
     */
    addons?: string;
}
/**
 * @generated from protobuf message CSVCMsg_GameEvent
 */
export interface CSVCMsg_GameEvent {
    /**
     * @generated from protobuf field: optional string event_name = 1;
     */
    eventName?: string;
    /**
     * @generated from protobuf field: optional int32 eventid = 2;
     */
    eventid?: number;
    /**
     * @generated from protobuf field: repeated CSVCMsg_GameEvent.key_t keys = 3;
     */
    keys: CSVCMsg_GameEvent_key_t[];
}
/**
 * @generated from protobuf message CSVCMsg_GameEvent.key_t
 */
export interface CSVCMsg_GameEvent_key_t {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional string val_string = 2;
     */
    valString?: string;
    /**
     * @generated from protobuf field: optional float val_float = 3;
     */
    valFloat?: number;
    /**
     * @generated from protobuf field: optional int32 val_long = 4;
     */
    valLong?: number;
    /**
     * @generated from protobuf field: optional int32 val_short = 5;
     */
    valShort?: number;
    /**
     * @generated from protobuf field: optional int32 val_byte = 6;
     */
    valByte?: number;
    /**
     * @generated from protobuf field: optional bool val_bool = 7;
     */
    valBool?: boolean;
    /**
     * @generated from protobuf field: optional uint64 val_uint64 = 8;
     */
    valUint64?: bigint;
}
/**
 * @generated from protobuf message CSVCMsgList_GameEvents
 */
export interface CSVCMsgList_GameEvents {
    /**
     * @generated from protobuf field: repeated CSVCMsgList_GameEvents.event_t events = 1;
     */
    events: CSVCMsgList_GameEvents_event_t[];
}
/**
 * @generated from protobuf message CSVCMsgList_GameEvents.event_t
 */
export interface CSVCMsgList_GameEvents_event_t {
    /**
     * @generated from protobuf field: optional int32 tick = 1;
     */
    tick?: number;
    /**
     * @generated from protobuf field: optional CSVCMsg_GameEvent event = 2;
     */
    event?: CSVCMsg_GameEvent;
}
/**
 * @generated from protobuf message CNETMsg_SpawnGroup_Load
 */
export interface CNETMsg_SpawnGroup_Load {
    /**
     * @generated from protobuf field: optional string worldname = 1;
     */
    worldname?: string;
    /**
     * @generated from protobuf field: optional string entitylumpname = 2;
     */
    entitylumpname?: string;
    /**
     * @generated from protobuf field: optional string entityfiltername = 3;
     */
    entityfiltername?: string;
    /**
     * @generated from protobuf field: optional uint32 spawngrouphandle = 4;
     */
    spawngrouphandle?: number;
    /**
     * @generated from protobuf field: optional uint32 spawngroupownerhandle = 5;
     */
    spawngroupownerhandle?: number;
    /**
     * @generated from protobuf field: optional CMsgVector world_offset_pos = 6;
     */
    worldOffsetPos?: CMsgVector;
    /**
     * @generated from protobuf field: optional CMsgQAngle world_offset_angle = 7;
     */
    worldOffsetAngle?: CMsgQAngle;
    /**
     * @generated from protobuf field: optional bytes spawngroupmanifest = 8;
     */
    spawngroupmanifest?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 flags = 9;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional int32 tickcount = 10;
     */
    tickcount?: number;
    /**
     * @generated from protobuf field: optional bool manifestincomplete = 11;
     */
    manifestincomplete?: boolean;
    /**
     * @generated from protobuf field: optional string localnamefixup = 12;
     */
    localnamefixup?: string;
    /**
     * @generated from protobuf field: optional string parentnamefixup = 13;
     */
    parentnamefixup?: string;
    /**
     * @generated from protobuf field: optional int32 manifestloadpriority = 14;
     */
    manifestloadpriority?: number;
    /**
     * @generated from protobuf field: optional uint32 worldgroupid = 15;
     */
    worldgroupid?: number;
    /**
     * @generated from protobuf field: optional uint32 creationsequence = 16;
     */
    creationsequence?: number;
    /**
     * @generated from protobuf field: optional string savegamefilename = 17;
     */
    savegamefilename?: string;
    /**
     * @generated from protobuf field: optional uint32 spawngroupparenthandle = 18;
     */
    spawngroupparenthandle?: number;
    /**
     * @generated from protobuf field: optional bool leveltransition = 19;
     */
    leveltransition?: boolean;
    /**
     * @generated from protobuf field: optional string worldgroupname = 20;
     */
    worldgroupname?: string;
}
/**
 * @generated from protobuf message CNETMsg_SpawnGroup_ManifestUpdate
 */
export interface CNETMsg_SpawnGroup_ManifestUpdate {
    /**
     * @generated from protobuf field: optional uint32 spawngrouphandle = 1;
     */
    spawngrouphandle?: number;
    /**
     * @generated from protobuf field: optional bytes spawngroupmanifest = 2;
     */
    spawngroupmanifest?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool manifestincomplete = 3;
     */
    manifestincomplete?: boolean;
}
/**
 * @generated from protobuf message CNETMsg_SpawnGroup_SetCreationTick
 */
export interface CNETMsg_SpawnGroup_SetCreationTick {
    /**
     * @generated from protobuf field: optional uint32 spawngrouphandle = 1;
     */
    spawngrouphandle?: number;
    /**
     * @generated from protobuf field: optional int32 tickcount = 2;
     */
    tickcount?: number;
    /**
     * @generated from protobuf field: optional uint32 creationsequence = 3;
     */
    creationsequence?: number;
}
/**
 * @generated from protobuf message CNETMsg_SpawnGroup_Unload
 */
export interface CNETMsg_SpawnGroup_Unload {
    /**
     * @generated from protobuf field: optional uint32 spawngrouphandle = 1;
     */
    spawngrouphandle?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 2;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional int32 tickcount = 3;
     */
    tickcount?: number;
}
/**
 * @generated from protobuf message CNETMsg_SpawnGroup_LoadCompleted
 */
export interface CNETMsg_SpawnGroup_LoadCompleted {
    /**
     * @generated from protobuf field: optional uint32 spawngrouphandle = 1;
     */
    spawngrouphandle?: number;
}
/**
 * @generated from protobuf message CSVCMsg_GameSessionConfiguration
 */
export interface CSVCMsg_GameSessionConfiguration {
    /**
     * @generated from protobuf field: optional bool is_multiplayer = 1;
     */
    isMultiplayer?: boolean;
    /**
     * @generated from protobuf field: optional bool is_loadsavegame = 2;
     */
    isLoadsavegame?: boolean;
    /**
     * @generated from protobuf field: optional bool is_background_map = 3;
     */
    isBackgroundMap?: boolean;
    /**
     * @generated from protobuf field: optional bool is_headless = 4;
     */
    isHeadless?: boolean;
    /**
     * @generated from protobuf field: optional uint32 min_client_limit = 5;
     */
    minClientLimit?: number;
    /**
     * @generated from protobuf field: optional uint32 max_client_limit = 6;
     */
    maxClientLimit?: number;
    /**
     * @generated from protobuf field: optional uint32 max_clients = 7;
     */
    maxClients?: number;
    /**
     * @generated from protobuf field: optional fixed32 tick_interval = 8;
     */
    tickInterval?: number;
    /**
     * @generated from protobuf field: optional string hostname = 9;
     */
    hostname?: string;
    /**
     * @generated from protobuf field: optional string savegamename = 10;
     */
    savegamename?: string;
    /**
     * @generated from protobuf field: optional string s1_mapname = 11;
     */
    s1Mapname?: string;
    /**
     * @generated from protobuf field: optional string gamemode = 12;
     */
    gamemode?: string;
    /**
     * @generated from protobuf field: optional string server_ip_address = 13;
     */
    serverIpAddress?: string;
    /**
     * @generated from protobuf field: optional bytes data = 14;
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool is_localonly = 15;
     */
    isLocalonly?: boolean;
    /**
     * @generated from protobuf field: optional bool no_steam_server = 19;
     */
    noSteamServer?: boolean;
    /**
     * @generated from protobuf field: optional bool is_transition = 16;
     */
    isTransition?: boolean;
    /**
     * @generated from protobuf field: optional string previouslevel = 17;
     */
    previouslevel?: string;
    /**
     * @generated from protobuf field: optional string landmarkname = 18;
     */
    landmarkname?: string;
}
/**
 * @generated from protobuf message CNETMsg_DebugOverlay
 */
export interface CNETMsg_DebugOverlay {
    /**
     * @generated from protobuf field: optional int32 etype = 1;
     */
    etype?: number;
    /**
     * @generated from protobuf field: repeated CMsgVector vectors = 2;
     */
    vectors: CMsgVector[];
    /**
     * @generated from protobuf field: repeated CMsgRGBA colors = 3;
     */
    colors: CMsgRGBA[];
    /**
     * @generated from protobuf field: repeated float dimensions = 4;
     */
    dimensions: number[];
    /**
     * @generated from protobuf field: repeated float times = 5;
     */
    times: number[];
    /**
     * @generated from protobuf field: repeated bool bools = 6;
     */
    bools: boolean[];
    /**
     * @generated from protobuf field: repeated uint64 uint64s = 7 [json_name = "uint64s"];
     */
    uint64S: bigint[];
    /**
     * @generated from protobuf field: repeated string strings = 8;
     */
    strings: string[];
}
/**
 * @generated from protobuf enum SignonState_t
 */
export enum SignonState_t {
    /**
     * @generated from protobuf enum value: SIGNONSTATE_NONE = 0;
     */
    SIGNONSTATE_NONE = 0,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_CHALLENGE = 1;
     */
    SIGNONSTATE_CHALLENGE = 1,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_CONNECTED = 2;
     */
    SIGNONSTATE_CONNECTED = 2,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_NEW = 3;
     */
    SIGNONSTATE_NEW = 3,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_PRESPAWN = 4;
     */
    SIGNONSTATE_PRESPAWN = 4,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_SPAWN = 5;
     */
    SIGNONSTATE_SPAWN = 5,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_FULL = 6;
     */
    SIGNONSTATE_FULL = 6,
    /**
     * @generated from protobuf enum value: SIGNONSTATE_CHANGELEVEL = 7;
     */
    SIGNONSTATE_CHANGELEVEL = 7
}
/**
 * @generated from protobuf enum NET_Messages
 */
export enum NET_Messages {
    /**
     * @generated from protobuf enum value: net_NOP = 0;
     */
    net_NOP = 0,
    /**
     * @generated from protobuf enum value: net_Disconnect_Legacy = 1;
     */
    net_Disconnect_Legacy = 1,
    /**
     * @generated from protobuf enum value: net_SplitScreenUser = 3;
     */
    net_SplitScreenUser = 3,
    /**
     * @generated from protobuf enum value: net_Tick = 4;
     */
    net_Tick = 4,
    /**
     * @generated from protobuf enum value: net_StringCmd = 5;
     */
    net_StringCmd = 5,
    /**
     * @generated from protobuf enum value: net_SetConVar = 6;
     */
    net_SetConVar = 6,
    /**
     * @generated from protobuf enum value: net_SignonState = 7;
     */
    net_SignonState = 7,
    /**
     * @generated from protobuf enum value: net_SpawnGroup_Load = 8;
     */
    net_SpawnGroup_Load = 8,
    /**
     * @generated from protobuf enum value: net_SpawnGroup_ManifestUpdate = 9;
     */
    net_SpawnGroup_ManifestUpdate = 9,
    /**
     * @generated from protobuf enum value: net_SpawnGroup_SetCreationTick = 11;
     */
    net_SpawnGroup_SetCreationTick = 11,
    /**
     * @generated from protobuf enum value: net_SpawnGroup_Unload = 12;
     */
    net_SpawnGroup_Unload = 12,
    /**
     * @generated from protobuf enum value: net_SpawnGroup_LoadCompleted = 13;
     */
    net_SpawnGroup_LoadCompleted = 13,
    /**
     * @generated from protobuf enum value: net_DebugOverlay = 15;
     */
    net_DebugOverlay = 15
}
/**
 * @generated from protobuf enum SpawnGroupFlags_t
 */
export enum SpawnGroupFlags_t {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE = 1;
     */
    SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE = 1,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_DONT_SPAWN_ENTITIES = 2;
     */
    SPAWN_GROUP_DONT_SPAWN_ENTITIES = 2,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_SYNCHRONOUS_SPAWN = 4;
     */
    SPAWN_GROUP_SYNCHRONOUS_SPAWN = 4,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP = 8;
     */
    SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP = 8,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES = 16;
     */
    SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES = 16,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_BLOCK_UNTIL_LOADED = 64;
     */
    SPAWN_GROUP_BLOCK_UNTIL_LOADED = 64,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_LOAD_STREAMING_DATA = 128;
     */
    SPAWN_GROUP_LOAD_STREAMING_DATA = 128,
    /**
     * @generated from protobuf enum value: SPAWN_GROUP_CREATE_NEW_SCENE_WORLD = 256;
     */
    SPAWN_GROUP_CREATE_NEW_SCENE_WORLD = 256
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgVector$Type extends MessageType<CMsgVector> {
    constructor() {
        super("CMsgVector", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgVector>): CMsgVector {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgVector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgVector): CMsgVector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                case /* optional float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgVector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* optional float w = 4; */
        if (message.w !== undefined)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgVector
 */
export const CMsgVector = new CMsgVector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgVector2D$Type extends MessageType<CMsgVector2D> {
    constructor() {
        super("CMsgVector2D", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgVector2D>): CMsgVector2D {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgVector2D>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgVector2D): CMsgVector2D {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgVector2D, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgVector2D
 */
export const CMsgVector2D = new CMsgVector2D$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgQAngle$Type extends MessageType<CMsgQAngle> {
    constructor() {
        super("CMsgQAngle", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgQAngle>): CMsgQAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgQAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgQAngle): CMsgQAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgQAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgQAngle
 */
export const CMsgQAngle = new CMsgQAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgQuaternion$Type extends MessageType<CMsgQuaternion> {
    constructor() {
        super("CMsgQuaternion", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "w", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgQuaternion>): CMsgQuaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgQuaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgQuaternion): CMsgQuaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x */ 1:
                    message.x = reader.float();
                    break;
                case /* optional float y */ 2:
                    message.y = reader.float();
                    break;
                case /* optional float z */ 3:
                    message.z = reader.float();
                    break;
                case /* optional float w */ 4:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgQuaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* optional float y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* optional float z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* optional float w = 4; */
        if (message.w !== undefined)
            writer.tag(4, WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgQuaternion
 */
export const CMsgQuaternion = new CMsgQuaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTransform$Type extends MessageType<CMsgTransform> {
    constructor() {
        super("CMsgTransform", [
            { no: 1, name: "position", kind: "message", T: () => CMsgVector },
            { no: 2, name: "scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "orientation", kind: "message", T: () => CMsgQuaternion }
        ]);
    }
    create(value?: PartialMessage<CMsgTransform>): CMsgTransform {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTransform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTransform): CMsgTransform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgVector position */ 1:
                    message.position = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional float scale */ 2:
                    message.scale = reader.float();
                    break;
                case /* optional CMsgQuaternion orientation */ 3:
                    message.orientation = CMsgQuaternion.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTransform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgVector position = 1; */
        if (message.position)
            CMsgVector.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional float scale = 2; */
        if (message.scale !== undefined)
            writer.tag(2, WireType.Bit32).float(message.scale);
        /* optional CMsgQuaternion orientation = 3; */
        if (message.orientation)
            CMsgQuaternion.internalBinaryWrite(message.orientation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTransform
 */
export const CMsgTransform = new CMsgTransform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgRGBA$Type extends MessageType<CMsgRGBA> {
    constructor() {
        super("CMsgRGBA", [
            { no: 1, name: "r", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "g", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "b", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "a", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgRGBA>): CMsgRGBA {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgRGBA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgRGBA): CMsgRGBA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 r */ 1:
                    message.r = reader.int32();
                    break;
                case /* optional int32 g */ 2:
                    message.g = reader.int32();
                    break;
                case /* optional int32 b */ 3:
                    message.b = reader.int32();
                    break;
                case /* optional int32 a */ 4:
                    message.a = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgRGBA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 r = 1; */
        if (message.r !== undefined)
            writer.tag(1, WireType.Varint).int32(message.r);
        /* optional int32 g = 2; */
        if (message.g !== undefined)
            writer.tag(2, WireType.Varint).int32(message.g);
        /* optional int32 b = 3; */
        if (message.b !== undefined)
            writer.tag(3, WireType.Varint).int32(message.b);
        /* optional int32 a = 4; */
        if (message.a !== undefined)
            writer.tag(4, WireType.Varint).int32(message.a);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgRGBA
 */
export const CMsgRGBA = new CMsgRGBA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPlayerInfo$Type extends MessageType<CMsgPlayerInfo> {
    constructor() {
        super("CMsgPlayerInfo", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "xuid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "userid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "fakeplayer", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "ishltv", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgPlayerInfo>): CMsgPlayerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgPlayerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgPlayerInfo): CMsgPlayerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional fixed64 xuid */ 2:
                    message.xuid = reader.fixed64().toBigInt();
                    break;
                case /* optional int32 userid */ 3:
                    message.userid = reader.int32();
                    break;
                case /* optional fixed64 steamid */ 4:
                    message.steamid = reader.fixed64().toBigInt();
                    break;
                case /* optional bool fakeplayer */ 5:
                    message.fakeplayer = reader.bool();
                    break;
                case /* optional bool ishltv */ 6:
                    message.ishltv = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgPlayerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional fixed64 xuid = 2; */
        if (message.xuid !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.xuid);
        /* optional int32 userid = 3; */
        if (message.userid !== undefined)
            writer.tag(3, WireType.Varint).int32(message.userid);
        /* optional fixed64 steamid = 4; */
        if (message.steamid !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.steamid);
        /* optional bool fakeplayer = 5; */
        if (message.fakeplayer !== undefined)
            writer.tag(5, WireType.Varint).bool(message.fakeplayer);
        /* optional bool ishltv = 6; */
        if (message.ishltv !== undefined)
            writer.tag(6, WireType.Varint).bool(message.ishltv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgPlayerInfo
 */
export const CMsgPlayerInfo = new CMsgPlayerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CEntityMsg$Type extends MessageType<CEntityMsg> {
    constructor() {
        super("CEntityMsg", [
            { no: 1, name: "target_entity", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CEntityMsg>): CEntityMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CEntityMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CEntityMsg): CEntityMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 target_entity */ 1:
                    message.targetEntity = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CEntityMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 target_entity = 1; */
        if (message.targetEntity !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.targetEntity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CEntityMsg
 */
export const CEntityMsg = new CEntityMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsg_CVars$Type extends MessageType<CMsg_CVars> {
    constructor() {
        super("CMsg_CVars", [
            { no: 1, name: "cvars", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsg_CVars_CVar }
        ]);
    }
    create(value?: PartialMessage<CMsg_CVars>): CMsg_CVars {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cvars = [];
        if (value !== undefined)
            reflectionMergePartial<CMsg_CVars>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsg_CVars): CMsg_CVars {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsg_CVars.CVar cvars */ 1:
                    message.cvars.push(CMsg_CVars_CVar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsg_CVars, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsg_CVars.CVar cvars = 1; */
        for (let i = 0; i < message.cvars.length; i++)
            CMsg_CVars_CVar.internalBinaryWrite(message.cvars[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsg_CVars
 */
export const CMsg_CVars = new CMsg_CVars$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsg_CVars_CVar$Type extends MessageType<CMsg_CVars_CVar> {
    constructor() {
        super("CMsg_CVars.CVar", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsg_CVars_CVar>): CMsg_CVars_CVar {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsg_CVars_CVar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsg_CVars_CVar): CMsg_CVars_CVar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsg_CVars_CVar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsg_CVars.CVar
 */
export const CMsg_CVars_CVar = new CMsg_CVars_CVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_NOP$Type extends MessageType<CNETMsg_NOP> {
    constructor() {
        super("CNETMsg_NOP", []);
    }
    create(value?: PartialMessage<CNETMsg_NOP>): CNETMsg_NOP {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_NOP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_NOP): CNETMsg_NOP {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CNETMsg_NOP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_NOP
 */
export const CNETMsg_NOP = new CNETMsg_NOP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SplitScreenUser$Type extends MessageType<CNETMsg_SplitScreenUser> {
    constructor() {
        super("CNETMsg_SplitScreenUser", [
            { no: 1, name: "slot", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SplitScreenUser>): CNETMsg_SplitScreenUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SplitScreenUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SplitScreenUser): CNETMsg_SplitScreenUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 slot */ 1:
                    message.slot = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SplitScreenUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 slot = 1; */
        if (message.slot !== undefined)
            writer.tag(1, WireType.Varint).int32(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SplitScreenUser
 */
export const CNETMsg_SplitScreenUser = new CNETMsg_SplitScreenUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_Tick$Type extends MessageType<CNETMsg_Tick> {
    constructor() {
        super("CNETMsg_Tick", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "host_frametime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "host_frametime_std_deviation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "host_computationtime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "host_computationtime_std_deviation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "host_framestarttime_std_deviation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "host_loss", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "host_unfiltered_frametime", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "hltv_replay_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "expected_long_tick", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "expected_long_tick_reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "jitter", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_Tick>): CNETMsg_Tick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_Tick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_Tick): CNETMsg_Tick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 tick */ 1:
                    message.tick = reader.uint32();
                    break;
                case /* optional uint32 host_frametime */ 2:
                    message.hostFrametime = reader.uint32();
                    break;
                case /* optional uint32 host_frametime_std_deviation */ 3:
                    message.hostFrametimeStdDeviation = reader.uint32();
                    break;
                case /* optional uint32 host_computationtime */ 4:
                    message.hostComputationtime = reader.uint32();
                    break;
                case /* optional uint32 host_computationtime_std_deviation */ 5:
                    message.hostComputationtimeStdDeviation = reader.uint32();
                    break;
                case /* optional uint32 host_framestarttime_std_deviation */ 6:
                    message.hostFramestarttimeStdDeviation = reader.uint32();
                    break;
                case /* optional uint32 host_loss */ 7:
                    message.hostLoss = reader.uint32();
                    break;
                case /* optional uint32 host_unfiltered_frametime */ 8:
                    message.hostUnfilteredFrametime = reader.uint32();
                    break;
                case /* optional uint32 hltv_replay_flags */ 9:
                    message.hltvReplayFlags = reader.uint32();
                    break;
                case /* optional uint32 expected_long_tick */ 10:
                    message.expectedLongTick = reader.uint32();
                    break;
                case /* optional string expected_long_tick_reason */ 11:
                    message.expectedLongTickReason = reader.string();
                    break;
                case /* optional uint32 jitter */ 12:
                    message.jitter = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_Tick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.tick);
        /* optional uint32 host_frametime = 2; */
        if (message.hostFrametime !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.hostFrametime);
        /* optional uint32 host_frametime_std_deviation = 3; */
        if (message.hostFrametimeStdDeviation !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.hostFrametimeStdDeviation);
        /* optional uint32 host_computationtime = 4; */
        if (message.hostComputationtime !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.hostComputationtime);
        /* optional uint32 host_computationtime_std_deviation = 5; */
        if (message.hostComputationtimeStdDeviation !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.hostComputationtimeStdDeviation);
        /* optional uint32 host_framestarttime_std_deviation = 6; */
        if (message.hostFramestarttimeStdDeviation !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.hostFramestarttimeStdDeviation);
        /* optional uint32 host_loss = 7; */
        if (message.hostLoss !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.hostLoss);
        /* optional uint32 host_unfiltered_frametime = 8; */
        if (message.hostUnfilteredFrametime !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.hostUnfilteredFrametime);
        /* optional uint32 hltv_replay_flags = 9; */
        if (message.hltvReplayFlags !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.hltvReplayFlags);
        /* optional uint32 expected_long_tick = 10; */
        if (message.expectedLongTick !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.expectedLongTick);
        /* optional string expected_long_tick_reason = 11; */
        if (message.expectedLongTickReason !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.expectedLongTickReason);
        /* optional uint32 jitter = 12; */
        if (message.jitter !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.jitter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_Tick
 */
export const CNETMsg_Tick = new CNETMsg_Tick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_StringCmd$Type extends MessageType<CNETMsg_StringCmd> {
    constructor() {
        super("CNETMsg_StringCmd", [
            { no: 1, name: "command", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "prediction_sync", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_StringCmd>): CNETMsg_StringCmd {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_StringCmd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_StringCmd): CNETMsg_StringCmd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string command */ 1:
                    message.command = reader.string();
                    break;
                case /* optional uint32 prediction_sync */ 2:
                    message.predictionSync = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_StringCmd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string command = 1; */
        if (message.command !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* optional uint32 prediction_sync = 2; */
        if (message.predictionSync !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.predictionSync);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_StringCmd
 */
export const CNETMsg_StringCmd = new CNETMsg_StringCmd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SetConVar$Type extends MessageType<CNETMsg_SetConVar> {
    constructor() {
        super("CNETMsg_SetConVar", [
            { no: 1, name: "convars", kind: "message", T: () => CMsg_CVars }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SetConVar>): CNETMsg_SetConVar {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SetConVar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SetConVar): CNETMsg_SetConVar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsg_CVars convars */ 1:
                    message.convars = CMsg_CVars.internalBinaryRead(reader, reader.uint32(), options, message.convars);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SetConVar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsg_CVars convars = 1; */
        if (message.convars)
            CMsg_CVars.internalBinaryWrite(message.convars, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SetConVar
 */
export const CNETMsg_SetConVar = new CNETMsg_SetConVar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SignonState$Type extends MessageType<CNETMsg_SignonState> {
    constructor() {
        super("CNETMsg_SignonState", [
            { no: 1, name: "signon_state", kind: "enum", opt: true, T: () => ["SignonState_t", SignonState_t] },
            { no: 2, name: "spawn_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_server_players", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "players_networkids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "map_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "addons", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SignonState>): CNETMsg_SignonState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playersNetworkids = [];
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SignonState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SignonState): CNETMsg_SignonState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional SignonState_t signon_state */ 1:
                    message.signonState = reader.int32();
                    break;
                case /* optional uint32 spawn_count */ 2:
                    message.spawnCount = reader.uint32();
                    break;
                case /* optional uint32 num_server_players */ 3:
                    message.numServerPlayers = reader.uint32();
                    break;
                case /* repeated string players_networkids */ 4:
                    message.playersNetworkids.push(reader.string());
                    break;
                case /* optional string map_name */ 5:
                    message.mapName = reader.string();
                    break;
                case /* optional string addons */ 6:
                    message.addons = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SignonState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional SignonState_t signon_state = 1; */
        if (message.signonState !== undefined)
            writer.tag(1, WireType.Varint).int32(message.signonState);
        /* optional uint32 spawn_count = 2; */
        if (message.spawnCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.spawnCount);
        /* optional uint32 num_server_players = 3; */
        if (message.numServerPlayers !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.numServerPlayers);
        /* repeated string players_networkids = 4; */
        for (let i = 0; i < message.playersNetworkids.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.playersNetworkids[i]);
        /* optional string map_name = 5; */
        if (message.mapName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.mapName);
        /* optional string addons = 6; */
        if (message.addons !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.addons);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SignonState
 */
export const CNETMsg_SignonState = new CNETMsg_SignonState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEvent$Type extends MessageType<CSVCMsg_GameEvent> {
    constructor() {
        super("CSVCMsg_GameEvent", [
            { no: 1, name: "event_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eventid", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsg_GameEvent_key_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEvent>): CSVCMsg_GameEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEvent): CSVCMsg_GameEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string event_name */ 1:
                    message.eventName = reader.string();
                    break;
                case /* optional int32 eventid */ 2:
                    message.eventid = reader.int32();
                    break;
                case /* repeated CSVCMsg_GameEvent.key_t keys */ 3:
                    message.keys.push(CSVCMsg_GameEvent_key_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string event_name = 1; */
        if (message.eventName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.eventName);
        /* optional int32 eventid = 2; */
        if (message.eventid !== undefined)
            writer.tag(2, WireType.Varint).int32(message.eventid);
        /* repeated CSVCMsg_GameEvent.key_t keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            CSVCMsg_GameEvent_key_t.internalBinaryWrite(message.keys[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEvent
 */
export const CSVCMsg_GameEvent = new CSVCMsg_GameEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameEvent_key_t$Type extends MessageType<CSVCMsg_GameEvent_key_t> {
    constructor() {
        super("CSVCMsg_GameEvent.key_t", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "val_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "val_float", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "val_long", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "val_short", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "val_byte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "val_bool", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "val_uint64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameEvent_key_t>): CSVCMsg_GameEvent_key_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameEvent_key_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameEvent_key_t): CSVCMsg_GameEvent_key_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string val_string */ 2:
                    message.valString = reader.string();
                    break;
                case /* optional float val_float */ 3:
                    message.valFloat = reader.float();
                    break;
                case /* optional int32 val_long */ 4:
                    message.valLong = reader.int32();
                    break;
                case /* optional int32 val_short */ 5:
                    message.valShort = reader.int32();
                    break;
                case /* optional int32 val_byte */ 6:
                    message.valByte = reader.int32();
                    break;
                case /* optional bool val_bool */ 7:
                    message.valBool = reader.bool();
                    break;
                case /* optional uint64 val_uint64 */ 8:
                    message.valUint64 = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameEvent_key_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string val_string = 2; */
        if (message.valString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.valString);
        /* optional float val_float = 3; */
        if (message.valFloat !== undefined)
            writer.tag(3, WireType.Bit32).float(message.valFloat);
        /* optional int32 val_long = 4; */
        if (message.valLong !== undefined)
            writer.tag(4, WireType.Varint).int32(message.valLong);
        /* optional int32 val_short = 5; */
        if (message.valShort !== undefined)
            writer.tag(5, WireType.Varint).int32(message.valShort);
        /* optional int32 val_byte = 6; */
        if (message.valByte !== undefined)
            writer.tag(6, WireType.Varint).int32(message.valByte);
        /* optional bool val_bool = 7; */
        if (message.valBool !== undefined)
            writer.tag(7, WireType.Varint).bool(message.valBool);
        /* optional uint64 val_uint64 = 8; */
        if (message.valUint64 !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.valUint64);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameEvent.key_t
 */
export const CSVCMsg_GameEvent_key_t = new CSVCMsg_GameEvent_key_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsgList_GameEvents$Type extends MessageType<CSVCMsgList_GameEvents> {
    constructor() {
        super("CSVCMsgList_GameEvents", [
            { no: 1, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CSVCMsgList_GameEvents_event_t }
        ]);
    }
    create(value?: PartialMessage<CSVCMsgList_GameEvents>): CSVCMsgList_GameEvents {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<CSVCMsgList_GameEvents>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsgList_GameEvents): CSVCMsgList_GameEvents {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CSVCMsgList_GameEvents.event_t events */ 1:
                    message.events.push(CSVCMsgList_GameEvents_event_t.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsgList_GameEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CSVCMsgList_GameEvents.event_t events = 1; */
        for (let i = 0; i < message.events.length; i++)
            CSVCMsgList_GameEvents_event_t.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsgList_GameEvents
 */
export const CSVCMsgList_GameEvents = new CSVCMsgList_GameEvents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsgList_GameEvents_event_t$Type extends MessageType<CSVCMsgList_GameEvents_event_t> {
    constructor() {
        super("CSVCMsgList_GameEvents.event_t", [
            { no: 1, name: "tick", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "event", kind: "message", T: () => CSVCMsg_GameEvent }
        ]);
    }
    create(value?: PartialMessage<CSVCMsgList_GameEvents_event_t>): CSVCMsgList_GameEvents_event_t {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsgList_GameEvents_event_t>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsgList_GameEvents_event_t): CSVCMsgList_GameEvents_event_t {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 tick */ 1:
                    message.tick = reader.int32();
                    break;
                case /* optional CSVCMsg_GameEvent event */ 2:
                    message.event = CSVCMsg_GameEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsgList_GameEvents_event_t, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 tick = 1; */
        if (message.tick !== undefined)
            writer.tag(1, WireType.Varint).int32(message.tick);
        /* optional CSVCMsg_GameEvent event = 2; */
        if (message.event)
            CSVCMsg_GameEvent.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsgList_GameEvents.event_t
 */
export const CSVCMsgList_GameEvents_event_t = new CSVCMsgList_GameEvents_event_t$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SpawnGroup_Load$Type extends MessageType<CNETMsg_SpawnGroup_Load> {
    constructor() {
        super("CNETMsg_SpawnGroup_Load", [
            { no: 1, name: "worldname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entitylumpname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entityfiltername", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "spawngrouphandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "spawngroupownerhandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "world_offset_pos", kind: "message", T: () => CMsgVector },
            { no: 7, name: "world_offset_angle", kind: "message", T: () => CMsgQAngle },
            { no: 8, name: "spawngroupmanifest", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "tickcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "manifestincomplete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "localnamefixup", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "parentnamefixup", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "manifestloadpriority", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "worldgroupid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "creationsequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "savegamefilename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "spawngroupparenthandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "leveltransition", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "worldgroupname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SpawnGroup_Load>): CNETMsg_SpawnGroup_Load {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SpawnGroup_Load>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SpawnGroup_Load): CNETMsg_SpawnGroup_Load {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string worldname */ 1:
                    message.worldname = reader.string();
                    break;
                case /* optional string entitylumpname */ 2:
                    message.entitylumpname = reader.string();
                    break;
                case /* optional string entityfiltername */ 3:
                    message.entityfiltername = reader.string();
                    break;
                case /* optional uint32 spawngrouphandle */ 4:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case /* optional uint32 spawngroupownerhandle */ 5:
                    message.spawngroupownerhandle = reader.uint32();
                    break;
                case /* optional CMsgVector world_offset_pos */ 6:
                    message.worldOffsetPos = CMsgVector.internalBinaryRead(reader, reader.uint32(), options, message.worldOffsetPos);
                    break;
                case /* optional CMsgQAngle world_offset_angle */ 7:
                    message.worldOffsetAngle = CMsgQAngle.internalBinaryRead(reader, reader.uint32(), options, message.worldOffsetAngle);
                    break;
                case /* optional bytes spawngroupmanifest */ 8:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case /* optional uint32 flags */ 9:
                    message.flags = reader.uint32();
                    break;
                case /* optional int32 tickcount */ 10:
                    message.tickcount = reader.int32();
                    break;
                case /* optional bool manifestincomplete */ 11:
                    message.manifestincomplete = reader.bool();
                    break;
                case /* optional string localnamefixup */ 12:
                    message.localnamefixup = reader.string();
                    break;
                case /* optional string parentnamefixup */ 13:
                    message.parentnamefixup = reader.string();
                    break;
                case /* optional int32 manifestloadpriority */ 14:
                    message.manifestloadpriority = reader.int32();
                    break;
                case /* optional uint32 worldgroupid */ 15:
                    message.worldgroupid = reader.uint32();
                    break;
                case /* optional uint32 creationsequence */ 16:
                    message.creationsequence = reader.uint32();
                    break;
                case /* optional string savegamefilename */ 17:
                    message.savegamefilename = reader.string();
                    break;
                case /* optional uint32 spawngroupparenthandle */ 18:
                    message.spawngroupparenthandle = reader.uint32();
                    break;
                case /* optional bool leveltransition */ 19:
                    message.leveltransition = reader.bool();
                    break;
                case /* optional string worldgroupname */ 20:
                    message.worldgroupname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SpawnGroup_Load, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string worldname = 1; */
        if (message.worldname !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.worldname);
        /* optional string entitylumpname = 2; */
        if (message.entitylumpname !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.entitylumpname);
        /* optional string entityfiltername = 3; */
        if (message.entityfiltername !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.entityfiltername);
        /* optional uint32 spawngrouphandle = 4; */
        if (message.spawngrouphandle !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.spawngrouphandle);
        /* optional uint32 spawngroupownerhandle = 5; */
        if (message.spawngroupownerhandle !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.spawngroupownerhandle);
        /* optional CMsgVector world_offset_pos = 6; */
        if (message.worldOffsetPos)
            CMsgVector.internalBinaryWrite(message.worldOffsetPos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgQAngle world_offset_angle = 7; */
        if (message.worldOffsetAngle)
            CMsgQAngle.internalBinaryWrite(message.worldOffsetAngle, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes spawngroupmanifest = 8; */
        if (message.spawngroupmanifest !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.spawngroupmanifest);
        /* optional uint32 flags = 9; */
        if (message.flags !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.flags);
        /* optional int32 tickcount = 10; */
        if (message.tickcount !== undefined)
            writer.tag(10, WireType.Varint).int32(message.tickcount);
        /* optional bool manifestincomplete = 11; */
        if (message.manifestincomplete !== undefined)
            writer.tag(11, WireType.Varint).bool(message.manifestincomplete);
        /* optional string localnamefixup = 12; */
        if (message.localnamefixup !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.localnamefixup);
        /* optional string parentnamefixup = 13; */
        if (message.parentnamefixup !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.parentnamefixup);
        /* optional int32 manifestloadpriority = 14; */
        if (message.manifestloadpriority !== undefined)
            writer.tag(14, WireType.Varint).int32(message.manifestloadpriority);
        /* optional uint32 worldgroupid = 15; */
        if (message.worldgroupid !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.worldgroupid);
        /* optional uint32 creationsequence = 16; */
        if (message.creationsequence !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.creationsequence);
        /* optional string savegamefilename = 17; */
        if (message.savegamefilename !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.savegamefilename);
        /* optional uint32 spawngroupparenthandle = 18; */
        if (message.spawngroupparenthandle !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.spawngroupparenthandle);
        /* optional bool leveltransition = 19; */
        if (message.leveltransition !== undefined)
            writer.tag(19, WireType.Varint).bool(message.leveltransition);
        /* optional string worldgroupname = 20; */
        if (message.worldgroupname !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.worldgroupname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SpawnGroup_Load
 */
export const CNETMsg_SpawnGroup_Load = new CNETMsg_SpawnGroup_Load$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SpawnGroup_ManifestUpdate$Type extends MessageType<CNETMsg_SpawnGroup_ManifestUpdate> {
    constructor() {
        super("CNETMsg_SpawnGroup_ManifestUpdate", [
            { no: 1, name: "spawngrouphandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "spawngroupmanifest", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "manifestincomplete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SpawnGroup_ManifestUpdate>): CNETMsg_SpawnGroup_ManifestUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SpawnGroup_ManifestUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SpawnGroup_ManifestUpdate): CNETMsg_SpawnGroup_ManifestUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 spawngrouphandle */ 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case /* optional bytes spawngroupmanifest */ 2:
                    message.spawngroupmanifest = reader.bytes();
                    break;
                case /* optional bool manifestincomplete */ 3:
                    message.manifestincomplete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SpawnGroup_ManifestUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 spawngrouphandle = 1; */
        if (message.spawngrouphandle !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.spawngrouphandle);
        /* optional bytes spawngroupmanifest = 2; */
        if (message.spawngroupmanifest !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spawngroupmanifest);
        /* optional bool manifestincomplete = 3; */
        if (message.manifestincomplete !== undefined)
            writer.tag(3, WireType.Varint).bool(message.manifestincomplete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SpawnGroup_ManifestUpdate
 */
export const CNETMsg_SpawnGroup_ManifestUpdate = new CNETMsg_SpawnGroup_ManifestUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SpawnGroup_SetCreationTick$Type extends MessageType<CNETMsg_SpawnGroup_SetCreationTick> {
    constructor() {
        super("CNETMsg_SpawnGroup_SetCreationTick", [
            { no: 1, name: "spawngrouphandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tickcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "creationsequence", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SpawnGroup_SetCreationTick>): CNETMsg_SpawnGroup_SetCreationTick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SpawnGroup_SetCreationTick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SpawnGroup_SetCreationTick): CNETMsg_SpawnGroup_SetCreationTick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 spawngrouphandle */ 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case /* optional int32 tickcount */ 2:
                    message.tickcount = reader.int32();
                    break;
                case /* optional uint32 creationsequence */ 3:
                    message.creationsequence = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SpawnGroup_SetCreationTick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 spawngrouphandle = 1; */
        if (message.spawngrouphandle !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.spawngrouphandle);
        /* optional int32 tickcount = 2; */
        if (message.tickcount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.tickcount);
        /* optional uint32 creationsequence = 3; */
        if (message.creationsequence !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.creationsequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SpawnGroup_SetCreationTick
 */
export const CNETMsg_SpawnGroup_SetCreationTick = new CNETMsg_SpawnGroup_SetCreationTick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SpawnGroup_Unload$Type extends MessageType<CNETMsg_SpawnGroup_Unload> {
    constructor() {
        super("CNETMsg_SpawnGroup_Unload", [
            { no: 1, name: "spawngrouphandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tickcount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SpawnGroup_Unload>): CNETMsg_SpawnGroup_Unload {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SpawnGroup_Unload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SpawnGroup_Unload): CNETMsg_SpawnGroup_Unload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 spawngrouphandle */ 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                case /* optional uint32 flags */ 2:
                    message.flags = reader.uint32();
                    break;
                case /* optional int32 tickcount */ 3:
                    message.tickcount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SpawnGroup_Unload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 spawngrouphandle = 1; */
        if (message.spawngrouphandle !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.spawngrouphandle);
        /* optional uint32 flags = 2; */
        if (message.flags !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.flags);
        /* optional int32 tickcount = 3; */
        if (message.tickcount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.tickcount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SpawnGroup_Unload
 */
export const CNETMsg_SpawnGroup_Unload = new CNETMsg_SpawnGroup_Unload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_SpawnGroup_LoadCompleted$Type extends MessageType<CNETMsg_SpawnGroup_LoadCompleted> {
    constructor() {
        super("CNETMsg_SpawnGroup_LoadCompleted", [
            { no: 1, name: "spawngrouphandle", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_SpawnGroup_LoadCompleted>): CNETMsg_SpawnGroup_LoadCompleted {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_SpawnGroup_LoadCompleted>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_SpawnGroup_LoadCompleted): CNETMsg_SpawnGroup_LoadCompleted {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 spawngrouphandle */ 1:
                    message.spawngrouphandle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_SpawnGroup_LoadCompleted, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 spawngrouphandle = 1; */
        if (message.spawngrouphandle !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.spawngrouphandle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_SpawnGroup_LoadCompleted
 */
export const CNETMsg_SpawnGroup_LoadCompleted = new CNETMsg_SpawnGroup_LoadCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CSVCMsg_GameSessionConfiguration$Type extends MessageType<CSVCMsg_GameSessionConfiguration> {
    constructor() {
        super("CSVCMsg_GameSessionConfiguration", [
            { no: 1, name: "is_multiplayer", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "is_loadsavegame", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_background_map", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_headless", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "min_client_limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "max_client_limit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "max_clients", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "tick_interval", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "hostname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "savegamename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "s1_mapname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "gamemode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "server_ip_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 15, name: "is_localonly", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "no_steam_server", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "is_transition", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "previouslevel", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "landmarkname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CSVCMsg_GameSessionConfiguration>): CSVCMsg_GameSessionConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CSVCMsg_GameSessionConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CSVCMsg_GameSessionConfiguration): CSVCMsg_GameSessionConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_multiplayer */ 1:
                    message.isMultiplayer = reader.bool();
                    break;
                case /* optional bool is_loadsavegame */ 2:
                    message.isLoadsavegame = reader.bool();
                    break;
                case /* optional bool is_background_map */ 3:
                    message.isBackgroundMap = reader.bool();
                    break;
                case /* optional bool is_headless */ 4:
                    message.isHeadless = reader.bool();
                    break;
                case /* optional uint32 min_client_limit */ 5:
                    message.minClientLimit = reader.uint32();
                    break;
                case /* optional uint32 max_client_limit */ 6:
                    message.maxClientLimit = reader.uint32();
                    break;
                case /* optional uint32 max_clients */ 7:
                    message.maxClients = reader.uint32();
                    break;
                case /* optional fixed32 tick_interval */ 8:
                    message.tickInterval = reader.fixed32();
                    break;
                case /* optional string hostname */ 9:
                    message.hostname = reader.string();
                    break;
                case /* optional string savegamename */ 10:
                    message.savegamename = reader.string();
                    break;
                case /* optional string s1_mapname */ 11:
                    message.s1Mapname = reader.string();
                    break;
                case /* optional string gamemode */ 12:
                    message.gamemode = reader.string();
                    break;
                case /* optional string server_ip_address */ 13:
                    message.serverIpAddress = reader.string();
                    break;
                case /* optional bytes data */ 14:
                    message.data = reader.bytes();
                    break;
                case /* optional bool is_localonly */ 15:
                    message.isLocalonly = reader.bool();
                    break;
                case /* optional bool no_steam_server */ 19:
                    message.noSteamServer = reader.bool();
                    break;
                case /* optional bool is_transition */ 16:
                    message.isTransition = reader.bool();
                    break;
                case /* optional string previouslevel */ 17:
                    message.previouslevel = reader.string();
                    break;
                case /* optional string landmarkname */ 18:
                    message.landmarkname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CSVCMsg_GameSessionConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool is_multiplayer = 1; */
        if (message.isMultiplayer !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isMultiplayer);
        /* optional bool is_loadsavegame = 2; */
        if (message.isLoadsavegame !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isLoadsavegame);
        /* optional bool is_background_map = 3; */
        if (message.isBackgroundMap !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isBackgroundMap);
        /* optional bool is_headless = 4; */
        if (message.isHeadless !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isHeadless);
        /* optional uint32 min_client_limit = 5; */
        if (message.minClientLimit !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.minClientLimit);
        /* optional uint32 max_client_limit = 6; */
        if (message.maxClientLimit !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.maxClientLimit);
        /* optional uint32 max_clients = 7; */
        if (message.maxClients !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.maxClients);
        /* optional fixed32 tick_interval = 8; */
        if (message.tickInterval !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.tickInterval);
        /* optional string hostname = 9; */
        if (message.hostname !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.hostname);
        /* optional string savegamename = 10; */
        if (message.savegamename !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.savegamename);
        /* optional string s1_mapname = 11; */
        if (message.s1Mapname !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.s1Mapname);
        /* optional string gamemode = 12; */
        if (message.gamemode !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.gamemode);
        /* optional string server_ip_address = 13; */
        if (message.serverIpAddress !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.serverIpAddress);
        /* optional bytes data = 14; */
        if (message.data !== undefined)
            writer.tag(14, WireType.LengthDelimited).bytes(message.data);
        /* optional bool is_localonly = 15; */
        if (message.isLocalonly !== undefined)
            writer.tag(15, WireType.Varint).bool(message.isLocalonly);
        /* optional bool no_steam_server = 19; */
        if (message.noSteamServer !== undefined)
            writer.tag(19, WireType.Varint).bool(message.noSteamServer);
        /* optional bool is_transition = 16; */
        if (message.isTransition !== undefined)
            writer.tag(16, WireType.Varint).bool(message.isTransition);
        /* optional string previouslevel = 17; */
        if (message.previouslevel !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.previouslevel);
        /* optional string landmarkname = 18; */
        if (message.landmarkname !== undefined)
            writer.tag(18, WireType.LengthDelimited).string(message.landmarkname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CSVCMsg_GameSessionConfiguration
 */
export const CSVCMsg_GameSessionConfiguration = new CSVCMsg_GameSessionConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CNETMsg_DebugOverlay$Type extends MessageType<CNETMsg_DebugOverlay> {
    constructor() {
        super("CNETMsg_DebugOverlay", [
            { no: 1, name: "etype", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "vectors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgVector },
            { no: 3, name: "colors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgRGBA },
            { no: 4, name: "dimensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "times", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "bools", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "uint64s", kind: "scalar", jsonName: "uint64s", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CNETMsg_DebugOverlay>): CNETMsg_DebugOverlay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vectors = [];
        message.colors = [];
        message.dimensions = [];
        message.times = [];
        message.bools = [];
        message.uint64S = [];
        message.strings = [];
        if (value !== undefined)
            reflectionMergePartial<CNETMsg_DebugOverlay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CNETMsg_DebugOverlay): CNETMsg_DebugOverlay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 etype */ 1:
                    message.etype = reader.int32();
                    break;
                case /* repeated CMsgVector vectors */ 2:
                    message.vectors.push(CMsgVector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgRGBA colors */ 3:
                    message.colors.push(CMsgRGBA.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated float dimensions */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dimensions.push(reader.float());
                    else
                        message.dimensions.push(reader.float());
                    break;
                case /* repeated float times */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.times.push(reader.float());
                    else
                        message.times.push(reader.float());
                    break;
                case /* repeated bool bools */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bools.push(reader.bool());
                    else
                        message.bools.push(reader.bool());
                    break;
                case /* repeated uint64 uint64s = 7 [json_name = "uint64s"];*/ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uint64S.push(reader.uint64().toBigInt());
                    else
                        message.uint64S.push(reader.uint64().toBigInt());
                    break;
                case /* repeated string strings */ 8:
                    message.strings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CNETMsg_DebugOverlay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 etype = 1; */
        if (message.etype !== undefined)
            writer.tag(1, WireType.Varint).int32(message.etype);
        /* repeated CMsgVector vectors = 2; */
        for (let i = 0; i < message.vectors.length; i++)
            CMsgVector.internalBinaryWrite(message.vectors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgRGBA colors = 3; */
        for (let i = 0; i < message.colors.length; i++)
            CMsgRGBA.internalBinaryWrite(message.colors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated float dimensions = 4; */
        for (let i = 0; i < message.dimensions.length; i++)
            writer.tag(4, WireType.Bit32).float(message.dimensions[i]);
        /* repeated float times = 5; */
        for (let i = 0; i < message.times.length; i++)
            writer.tag(5, WireType.Bit32).float(message.times[i]);
        /* repeated bool bools = 6; */
        for (let i = 0; i < message.bools.length; i++)
            writer.tag(6, WireType.Varint).bool(message.bools[i]);
        /* repeated uint64 uint64s = 7 [json_name = "uint64s"]; */
        for (let i = 0; i < message.uint64S.length; i++)
            writer.tag(7, WireType.Varint).uint64(message.uint64S[i]);
        /* repeated string strings = 8; */
        for (let i = 0; i < message.strings.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.strings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CNETMsg_DebugOverlay
 */
export const CNETMsg_DebugOverlay = new CNETMsg_DebugOverlay$Type();

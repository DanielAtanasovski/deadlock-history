// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "steamdatagram_messages_sdr.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgSteamDatagramConnectionQuality } from "./steamnetworkingsockets_messages";
import { CMsgSteamNetworkingIdentityLegacyBinary } from "./steamnetworkingsockets_messages_certs";
import { CMsgSteamNetworkingICESessionSummary } from "./steamnetworkingsockets_messages";
import { CMsgSteamDatagramSessionCryptInfoSigned } from "./steamnetworkingsockets_messages";
import { CMsgSteamDatagramCertificateSigned } from "./steamnetworkingsockets_messages_certs";
/**
 * @generated from protobuf message CMsgSteamNetworkingIPAddress
 */
export interface CMsgSteamNetworkingIPAddress {
    /**
     * @generated from protobuf field: optional fixed32 v4 = 1;
     */
    v4?: number;
    /**
     * @generated from protobuf field: optional bytes v6 = 2;
     */
    v6?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramSignedMessageGeneric
 */
export interface CMsgSteamDatagramSignedMessageGeneric {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 1;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
    /**
     * @generated from protobuf field: optional bytes signed_data = 2;
     */
    signedData?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes signature = 3;
     */
    signature?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes dummy_pad = 1023;
     */
    dummyPad?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramRouterPingReply
 */
export interface CMsgSteamDatagramRouterPingReply {
    /**
     * @generated from protobuf field: optional fixed32 client_timestamp = 1;
     */
    clientTimestamp?: number;
    /**
     * @generated from protobuf field: repeated fixed32 latency_datacenter_ids = 2 [packed = true];
     */
    latencyDatacenterIds: number[];
    /**
     * @generated from protobuf field: repeated uint32 latency_ping_ms = 3 [packed = true];
     */
    latencyPingMs: number[];
    /**
     * @generated from protobuf field: repeated fixed32 latency_datacenter_ids_p2p = 14 [json_name = "latencyDatacenterIdsP2p", packed = true];
     */
    latencyDatacenterIdsP2P: number[];
    /**
     * @generated from protobuf field: repeated uint32 latency_ping_ms_p2p = 15 [json_name = "latencyPingMsP2p", packed = true];
     */
    latencyPingMsP2P: number[];
    /**
     * @generated from protobuf field: optional fixed32 your_public_ip = 4;
     */
    yourPublicIp?: number;
    /**
     * @generated from protobuf field: optional fixed32 your_public_port = 11;
     */
    yourPublicPort?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_time = 5;
     */
    serverTime?: number;
    /**
     * @generated from protobuf field: optional fixed64 challenge = 6;
     */
    challenge?: bigint;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 7;
     */
    secondsUntilShutdown?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_cookie = 8;
     */
    clientCookie?: number;
    /**
     * @generated from protobuf field: optional uint32 recv_tos = 16;
     */
    recvTos?: number;
    /**
     * @generated from protobuf field: optional uint32 echo_sent_tos = 17;
     */
    echoSentTos?: number;
    /**
     * @generated from protobuf field: optional uint32 sent_tos = 18;
     */
    sentTos?: number;
    /**
     * @generated from protobuf field: optional uint32 echo_request_reply_tos = 19;
     */
    echoRequestReplyTos?: number;
    /**
     * @generated from protobuf field: optional uint32 scoring_penalty_relay_cluster = 9;
     */
    scoringPenaltyRelayCluster?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 12;
     */
    flags?: number;
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;
     */
    routeExceptions: CMsgSteamDatagramRouterPingReply_RouteException[];
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13;
     */
    altAddresses: CMsgSteamDatagramRouterPingReply_AltAddress[];
    /**
     * @generated from protobuf field: optional bytes dummy_pad = 99;
     */
    dummyPad?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint64 dummy_varint = 100;
     */
    dummyVarint?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamDatagramRouterPingReply.RouteException
 */
export interface CMsgSteamDatagramRouterPingReply_RouteException {
    /**
     * @generated from protobuf field: optional fixed32 data_center_id = 1;
     */
    dataCenterId?: number;
    /**
     * @generated from protobuf field: optional uint32 flags = 2;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 penalty = 3;
     */
    penalty?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramRouterPingReply.AltAddress
 */
export interface CMsgSteamDatagramRouterPingReply_AltAddress {
    /**
     * @generated from protobuf field: optional fixed32 ipv4 = 1;
     */
    ipv4?: number;
    /**
     * @generated from protobuf field: optional uint32 port = 2;
     */
    port?: number;
    /**
     * @generated from protobuf field: optional uint32 penalty = 3;
     */
    penalty?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4;
     */
    protocol?: CMsgSteamDatagramRouterPingReply_AltAddress_Protocol;
    /**
     * @generated from protobuf field: optional string id = 5;
     */
    id?: string;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramRouterPingReply.AltAddress.Protocol
 */
export enum CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
    /**
     * @generated from protobuf enum value: DefaultProtocol = 0;
     */
    DefaultProtocol = 0
}
/**
 * @generated from protobuf enum CMsgSteamDatagramRouterPingReply.Flags
 */
export enum CMsgSteamDatagramRouterPingReply_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FLAG_MAYBE_MORE_DATA_CENTERS = 1;
     */
    FLAG_MAYBE_MORE_DATA_CENTERS = 1,
    /**
     * @generated from protobuf enum value: FLAG_MAYBE_MORE_ALT_ADDRESSES = 2;
     */
    FLAG_MAYBE_MORE_ALT_ADDRESSES = 2
}
/**
 * @generated from protobuf message CMsgSteamDatagramGameserverPingRequestBody
 */
export interface CMsgSteamDatagramGameserverPingRequestBody {
    /**
     * @generated from protobuf field: optional fixed32 relay_popid = 1;
     */
    relayPopid?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingIPAddress your_public_ip = 2;
     */
    yourPublicIp?: CMsgSteamNetworkingIPAddress;
    /**
     * @generated from protobuf field: optional uint32 your_public_port = 3;
     */
    yourPublicPort?: number;
    /**
     * @generated from protobuf field: optional uint64 relay_unix_time = 4;
     */
    relayUnixTime?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 routing_secret = 5;
     */
    routingSecret?: bigint;
    /**
     * @generated from protobuf field: repeated CMsgSteamNetworkingIPAddress my_ips = 6;
     */
    myIps: CMsgSteamNetworkingIPAddress[];
    /**
     * @generated from protobuf field: optional bytes echo = 8;
     */
    echo?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramGameserverPingRequestEnvelope
 */
export interface CMsgSteamDatagramGameserverPingRequestEnvelope {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 6;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
    /**
     * @generated from protobuf field: optional bytes signed_data = 7;
     */
    signedData?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes signature = 8;
     */
    signature?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed32 legacy_your_public_ip = 1;
     */
    legacyYourPublicIp?: number;
    /**
     * @generated from protobuf field: optional fixed32 legacy_your_public_port = 5;
     */
    legacyYourPublicPort?: number;
    /**
     * @generated from protobuf field: optional fixed32 legacy_relay_unix_time = 2;
     */
    legacyRelayUnixTime?: number;
    /**
     * @generated from protobuf field: optional fixed64 legacy_challenge = 3;
     */
    legacyChallenge?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 legacy_router_timestamp = 4;
     */
    legacyRouterTimestamp?: number;
    /**
     * @generated from protobuf field: optional bytes dummy_pad = 1023;
     */
    dummyPad?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramGameserverPingReplyData
 */
export interface CMsgSteamDatagramGameserverPingReplyData {
    /**
     * @generated from protobuf field: optional fixed32 echo_relay_unix_time = 2;
     */
    echoRelayUnixTime?: number;
    /**
     * @generated from protobuf field: optional bytes echo = 8;
     */
    echo?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 legacy_challenge = 3;
     */
    legacyChallenge?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 legacy_router_timestamp = 4;
     */
    legacyRouterTimestamp?: number;
    /**
     * @generated from protobuf field: optional fixed32 data_center_id = 5;
     */
    dataCenterId?: number;
    /**
     * @generated from protobuf field: optional uint32 appid = 6;
     */
    appid?: number;
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 7;
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional string build = 9;
     */
    build?: string;
    /**
     * @generated from protobuf field: optional uint64 network_config_version = 10;
     */
    networkConfigVersion?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 my_unix_time = 11;
     */
    myUnixTime?: number;
    /**
     * @generated from protobuf field: optional bytes routing_blob = 12;
     */
    routingBlob?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramNoSessionRelayToClient
 */
export interface CMsgSteamDatagramNoSessionRelayToClient {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 7;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 your_public_ip = 2;
     */
    yourPublicIp?: number;
    /**
     * @generated from protobuf field: optional fixed32 your_public_port = 6;
     */
    yourPublicPort?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_time = 3;
     */
    serverTime?: number;
    /**
     * @generated from protobuf field: optional fixed64 challenge = 4;
     */
    challenge?: bigint;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 5;
     */
    secondsUntilShutdown?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramNoSessionRelayToPeer
 */
export interface CMsgSteamDatagramNoSessionRelayToPeer {
    /**
     * @generated from protobuf field: optional uint32 legacy_relay_session_id = 1;
     */
    legacyRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_relay_session_id = 2;
     */
    fromRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_connection_id = 7;
     */
    fromConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed64 kludge_pad = 99;
     */
    kludgePad?: bigint;
}
/**
 * @generated from protobuf message CMsgTOSTreatment
 */
export interface CMsgTOSTreatment {
    /**
     * @generated from protobuf field: optional string l4s_detect = 1 [json_name = "l4sDetect"];
     */
    l4SDetect?: string;
    /**
     * @generated from protobuf field: optional string up_ecn1 = 2;
     */
    upEcn1?: string;
    /**
     * @generated from protobuf field: optional string down_dscp45 = 3;
     */
    downDscp45?: string;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientPingSampleRequest
 */
export interface CMsgSteamDatagramClientPingSampleRequest {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientPingSampleReply
 */
export interface CMsgSteamDatagramClientPingSampleReply {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional bool relay_override_active = 5;
     */
    relayOverrideActive?: boolean;
    /**
     * @generated from protobuf field: optional CMsgTOSTreatment tos = 6;
     */
    tos?: CMsgTOSTreatment;
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramClientPingSampleReply.POP pops = 2;
     */
    pops: CMsgSteamDatagramClientPingSampleReply_POP[];
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3;
     */
    legacyDataCenters: CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter[];
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientPingSampleReply.POP
 */
export interface CMsgSteamDatagramClientPingSampleReply_POP {
    /**
     * @generated from protobuf field: optional fixed32 pop_id = 1;
     */
    popId?: number;
    /**
     * @generated from protobuf field: optional uint32 default_front_ping_ms = 2;
     */
    defaultFrontPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 cluster_penalty = 4;
     */
    clusterPenalty?: number;
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7;
     */
    altAddresses: CMsgSteamDatagramClientPingSampleReply_POP_AltAddress[];
    /**
     * @generated from protobuf field: optional uint32 default_e2e_ping_ms = 3 [json_name = "defaultE2ePingMs"];
     */
    defaultE2EPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 default_e2e_score = 5 [json_name = "defaultE2eScore"];
     */
    defaultE2EScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 p2p_via_peer_relay_pop_id = 6 [json_name = "p2pViaPeerRelayPopId"];
     */
    p2PViaPeerRelayPopId?: number;
    /**
     * @generated from protobuf field: optional uint32 best_dc_ping_ms = 9;
     */
    bestDcPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 best_dc_score = 10;
     */
    bestDcScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_dc_via_relay_pop_id = 11;
     */
    bestDcViaRelayPopId?: number;
    /**
     * @generated from protobuf field: optional uint32 default_dc_ping_ms = 12;
     */
    defaultDcPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 default_dc_score = 13;
     */
    defaultDcScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 default_dc_via_relay_pop_id = 14;
     */
    defaultDcViaRelayPopId?: number;
    /**
     * @generated from protobuf field: optional uint32 test_dc_ping_ms = 15;
     */
    testDcPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 test_dc_score = 16;
     */
    testDcScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 test_dc_via_relay_pop_id = 17;
     */
    testDcViaRelayPopId?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientPingSampleReply.POP.AltAddress
 */
export interface CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    /**
     * @generated from protobuf field: optional string id = 1;
     */
    id?: string;
    /**
     * @generated from protobuf field: optional uint32 front_ping_ms = 2;
     */
    frontPingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 penalty = 3;
     */
    penalty?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter
 */
export interface CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    /**
     * @generated from protobuf field: optional fixed32 data_center_id = 1;
     */
    dataCenterId?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_dc_via_relay_pop_id = 2;
     */
    bestDcViaRelayPopId?: number;
    /**
     * @generated from protobuf field: optional uint32 best_dc_ping_ms = 3;
     */
    bestDcPingMs?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientSwitchedPrimary
 */
export interface CMsgSteamDatagramClientSwitchedPrimary {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_ip = 2;
     */
    fromIp?: number;
    /**
     * @generated from protobuf field: optional uint32 from_port = 3;
     */
    fromPort?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_router_cluster = 4;
     */
    fromRouterCluster?: number;
    /**
     * @generated from protobuf field: optional uint32 from_active_time = 5;
     */
    fromActiveTime?: number;
    /**
     * @generated from protobuf field: optional uint32 from_active_packets_recv = 6;
     */
    fromActivePacketsRecv?: number;
    /**
     * @generated from protobuf field: optional string from_dropped_reason = 7;
     */
    fromDroppedReason?: string;
    /**
     * @generated from protobuf field: optional uint32 gap_ms = 8;
     */
    gapMs?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;
     */
    fromQualityNow?: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;
     */
    toQualityNow?: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;
     */
    fromQualityThen?: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;
     */
    toQualityThen?: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality;
}
/**
 * @generated from protobuf message CMsgSteamDatagramClientSwitchedPrimary.RouterQuality
 */
export interface CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    /**
     * @generated from protobuf field: optional uint32 score = 1;
     */
    score?: number;
    /**
     * @generated from protobuf field: optional uint32 front_ping = 2;
     */
    frontPing?: number;
    /**
     * @generated from protobuf field: optional uint32 back_ping = 3;
     */
    backPing?: number;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_down = 4;
     */
    secondsUntilDown?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectRequest
 */
export interface CMsgSteamDatagramConnectRequest {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional fixed64 my_timestamp = 4;
     */
    myTimestamp?: bigint;
    /**
     * @generated from protobuf field: optional uint32 ping_est_ms = 5;
     */
    pingEstMs?: number;
    /**
     * @generated from protobuf field: optional uint32 virtual_port = 9;
     */
    virtualPort?: number;
    /**
     * @generated from protobuf field: optional uint32 gameserver_relay_session_id = 2;
     */
    gameserverRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;
     */
    crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 7;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
    /**
     * @generated from protobuf field: optional fixed64 routing_secret = 10;
     */
    routingSecret?: bigint;
    /**
     * @generated from protobuf field: optional fixed64 legacy_client_steam_id = 3;
     */
    legacyClientSteamId?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectOK
 */
export interface CMsgSteamDatagramConnectOK {
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 1;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_connection_id = 7;
     */
    serverConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed64 your_timestamp = 3;
     */
    yourTimestamp?: bigint;
    /**
     * @generated from protobuf field: optional uint32 delay_time_usec = 4;
     */
    delayTimeUsec?: number;
    /**
     * @generated from protobuf field: optional uint32 gameserver_relay_session_id = 2;
     */
    gameserverRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;
     */
    crypt?: CMsgSteamDatagramSessionCryptInfoSigned;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 6;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
}
/**
 * @generated from protobuf message CMsgSteamNetworkingP2PSDRRoutingSummary
 */
export interface CMsgSteamNetworkingP2PSDRRoutingSummary {
    /**
     * @generated from protobuf field: optional uint32 initial_ping = 1;
     */
    initialPing?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping_front_local = 2;
     */
    initialPingFrontLocal?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_ping_front_remote = 3;
     */
    initialPingFrontRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 initial_score = 4;
     */
    initialScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 initial_pop_local = 5;
     */
    initialPopLocal?: number;
    /**
     * @generated from protobuf field: optional fixed32 initial_pop_remote = 6;
     */
    initialPopRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping = 11;
     */
    bestPing?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping_front_local = 12;
     */
    bestPingFrontLocal?: number;
    /**
     * @generated from protobuf field: optional uint32 best_ping_front_remote = 13;
     */
    bestPingFrontRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 best_score = 14;
     */
    bestScore?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_pop_local = 15;
     */
    bestPopLocal?: number;
    /**
     * @generated from protobuf field: optional fixed32 best_pop_remote = 16;
     */
    bestPopRemote?: number;
    /**
     * @generated from protobuf field: optional uint32 best_time = 17;
     */
    bestTime?: number;
    /**
     * @generated from protobuf field: optional uint32 negotiation_ms = 7;
     */
    negotiationMs?: number;
    /**
     * @generated from protobuf field: optional uint32 selected_seconds = 8;
     */
    selectedSeconds?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PRoutingSummary
 */
export interface CMsgSteamDatagramP2PRoutingSummary {
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingICESessionSummary ice = 2;
     */
    ice?: CMsgSteamNetworkingICESessionSummary;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3;
     */
    sdr?: CMsgSteamNetworkingP2PSDRRoutingSummary;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionClosed
 */
export interface CMsgSteamDatagramConnectionClosed {
    /**
     * @generated from protobuf field: optional fixed32 to_connection_id = 7;
     */
    toConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_connection_id = 8;
     */
    fromConnectionId?: number;
    /**
     * @generated from protobuf field: optional string from_identity_string = 15;
     */
    fromIdentityString?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13;
     */
    legacyFromIdentityBinary?: CMsgSteamNetworkingIdentityLegacyBinary;
    /**
     * @generated from protobuf field: optional fixed64 legacy_from_steam_id = 3;
     */
    legacyFromSteamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 legacy_gameserver_relay_session_id = 2;
     */
    legacyGameserverRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 to_relay_session_id = 9;
     */
    toRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_relay_session_id = 10;
     */
    fromRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional bytes forward_target_relay_routing_token = 11;
     */
    forwardTargetRelayRoutingToken?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 forward_target_revision = 12;
     */
    forwardTargetRevision?: number;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4;
     */
    relayMode?: CMsgSteamDatagramConnectionClosed_ERelayMode;
    /**
     * @generated from protobuf field: optional string debug = 5;
     */
    debug?: string;
    /**
     * @generated from protobuf field: optional uint32 reason_code = 6;
     */
    reasonCode?: number;
    /**
     * @generated from protobuf field: optional fixed64 routing_secret = 14;
     */
    routingSecret?: bigint;
    /**
     * @generated from protobuf field: optional bool not_primary_session = 16;
     */
    notPrimarySession?: boolean;
    /**
     * @generated from protobuf field: optional bool not_primary_transport = 19;
     */
    notPrimaryTransport?: boolean;
    /**
     * @generated from protobuf field: optional bool relay_override_active = 22;
     */
    relayOverrideActive?: boolean;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 17;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 18 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21 [json_name = "p2pRoutingSummary"];
     */
    p2PRoutingSummary?: CMsgSteamDatagramP2PRoutingSummary;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionClosed.ERelayMode
 */
export enum CMsgSteamDatagramConnectionClosed_ERelayMode {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: EndToEnd = 1;
     */
    EndToEnd = 1,
    /**
     * @generated from protobuf enum value: ClosedByPeer = 2;
     */
    ClosedByPeer = 2
}
/**
 * @generated from protobuf message CMsgSteamDatagramNoConnection
 */
export interface CMsgSteamDatagramNoConnection {
    /**
     * @generated from protobuf field: optional fixed32 to_connection_id = 5;
     */
    toConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_connection_id = 6;
     */
    fromConnectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 legacy_gameserver_relay_session_id = 2;
     */
    legacyGameserverRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 to_relay_session_id = 9;
     */
    toRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 from_relay_session_id = 10;
     */
    fromRelaySessionId?: number;
    /**
     * @generated from protobuf field: optional string from_identity_string = 7;
     */
    fromIdentityString?: string;
    /**
     * @generated from protobuf field: optional fixed64 legacy_from_steam_id = 3;
     */
    legacyFromSteamId?: bigint;
    /**
     * @generated from protobuf field: optional bool end_to_end = 4;
     */
    endToEnd?: boolean;
    /**
     * @generated from protobuf field: optional bool not_primary_session = 12;
     */
    notPrimarySession?: boolean;
    /**
     * @generated from protobuf field: optional bool not_primary_transport = 15;
     */
    notPrimaryTransport?: boolean;
    /**
     * @generated from protobuf field: optional bool relay_override_active = 17;
     */
    relayOverrideActive?: boolean;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 13;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 14 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16 [json_name = "p2pRoutingSummary"];
     */
    p2PRoutingSummary?: CMsgSteamDatagramP2PRoutingSummary;
    /**
     * @generated from protobuf field: optional fixed64 routing_secret = 11;
     */
    routingSecret?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 dummy_pad = 1023;
     */
    dummyPad?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramGameserverSessionRequest
 */
export interface CMsgSteamDatagramGameserverSessionRequest {
    /**
     * @generated from protobuf field: optional bytes ticket = 1;
     */
    ticket?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed32 challenge_time = 3;
     */
    challengeTime?: number;
    /**
     * @generated from protobuf field: optional fixed64 challenge = 4;
     */
    challenge?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 5;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_connection_id = 8;
     */
    serverConnectionId?: number;
    /**
     * @generated from protobuf field: optional uint64 network_config_version = 6;
     */
    networkConfigVersion?: bigint;
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 7;
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional string platform = 9;
     */
    platform?: string;
    /**
     * @generated from protobuf field: optional string build = 10;
     */
    build?: string;
    /**
     * @generated from protobuf field: optional string dev_gameserver_identity = 100;
     */
    devGameserverIdentity?: string;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned dev_client_cert = 101;
     */
    devClientCert?: CMsgSteamDatagramCertificateSigned;
}
/**
 * @generated from protobuf message CMsgSteamDatagramGameserverSessionEstablished
 */
export interface CMsgSteamDatagramGameserverSessionEstablished {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional string gameserver_identity_string = 2;
     */
    gameserverIdentityString?: string;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 4;
     */
    secondsUntilShutdown?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_r2c = 6 [json_name = "seqNumR2c"];
     */
    seqNumR2C?: number;
    /**
     * @generated from protobuf field: optional bytes dummy_legacy_identity_binary = 7;
     */
    dummyLegacyIdentityBinary?: Uint8Array;
    /**
     * @generated from protobuf field: optional fixed64 legacy_gameserver_steamid = 3;
     */
    legacyGameserverSteamid?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsClientToRouter
 */
export interface CMsgSteamDatagramConnectionStatsClientToRouter {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 4;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 5 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 6;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 8;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_c2r = 9 [json_name = "seqNumC2r"];
     */
    seqNumC2R?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 10 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsClientToRouter.Flags
 */
export enum CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4,
    /**
     * @generated from protobuf enum value: NOT_PRIMARY_SESSION = 8;
     */
    NOT_PRIMARY_SESSION = 8,
    /**
     * @generated from protobuf enum value: CLIENT_RELAY_OVERRIDE = 32;
     */
    CLIENT_RELAY_OVERRIDE = 32
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsRouterToClient
 */
export interface CMsgSteamDatagramConnectionStatsRouterToClient {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 6;
     */
    secondsUntilShutdown?: number;
    /**
     * @generated from protobuf field: optional fixed32 migrate_request_ip = 10;
     */
    migrateRequestIp?: number;
    /**
     * @generated from protobuf field: optional uint32 migrate_request_port = 11;
     */
    migrateRequestPort?: number;
    /**
     * @generated from protobuf field: optional uint32 scoring_penalty_relay_cluster = 12;
     */
    scoringPenaltyRelayCluster?: number;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 13;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 14 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 15;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 7;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_r2c = 8 [json_name = "seqNumR2c"];
     */
    seqNumR2C?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 9 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsRouterToClient.Flags
 */
export enum CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsRouterToServer
 */
export interface CMsgSteamDatagramConnectionStatsRouterToServer {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 10;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 11 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 12;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_r2s = 5 [json_name = "seqNumR2s"];
     */
    seqNumR2S?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 6 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
    /**
     * @generated from protobuf field: optional string client_identity_string = 15;
     */
    clientIdentityString?: string;
    /**
     * @generated from protobuf field: optional fixed64 legacy_client_steam_id = 7;
     */
    legacyClientSteamId?: bigint;
    /**
     * @generated from protobuf field: optional uint32 relay_session_id = 8;
     */
    relaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 9;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_connection_id = 13;
     */
    serverConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed64 routing_secret = 14;
     */
    routingSecret?: bigint;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsRouterToServer.Flags
 */
export enum CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsServerToRouter
 */
export interface CMsgSteamDatagramConnectionStatsServerToRouter {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 8;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 9 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 10;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_s2r = 3 [json_name = "seqNumS2r"];
     */
    seqNumS2R?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 4 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
    /**
     * @generated from protobuf field: optional uint32 relay_session_id = 6;
     */
    relaySessionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 7;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed32 server_connection_id = 11;
     */
    serverConnectionId?: number;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsServerToRouter.Flags
 */
export enum CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PSessionRequestBody
 */
export interface CMsgSteamDatagramP2PSessionRequestBody {
    /**
     * @generated from protobuf field: optional fixed32 challenge_time = 1;
     */
    challengeTime?: number;
    /**
     * @generated from protobuf field: optional fixed64 challenge = 2;
     */
    challenge?: bigint;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 3;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional fixed64 legacy_peer_steam_id = 4;
     */
    legacyPeerSteamId?: bigint;
    /**
     * @generated from protobuf field: optional string peer_identity_string = 11;
     */
    peerIdentityString?: string;
    /**
     * @generated from protobuf field: optional fixed32 peer_connection_id = 5;
     */
    peerConnectionId?: number;
    /**
     * @generated from protobuf field: optional bytes encrypted_data = 14;
     */
    encryptedData?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 encryption_your_public_key_lead_byte = 15;
     */
    encryptionYourPublicKeyLeadByte?: number;
    /**
     * @generated from protobuf field: optional bytes encryption_my_ephemeral_public_key = 16;
     */
    encryptionMyEphemeralPublicKey?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 protocol_version = 8;
     */
    protocolVersion?: number;
    /**
     * @generated from protobuf field: optional uint64 network_config_version = 9;
     */
    networkConfigVersion?: bigint;
    /**
     * @generated from protobuf field: optional string platform = 12;
     */
    platform?: string;
    /**
     * @generated from protobuf field: optional string build = 13;
     */
    build?: string;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PSessionRequestBody.EncryptedData
 */
export interface CMsgSteamDatagramP2PSessionRequestBody_EncryptedData {
    /**
     * @generated from protobuf field: optional string peer_identity_string = 1;
     */
    peerIdentityString?: string;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PSessionRequest
 */
export interface CMsgSteamDatagramP2PSessionRequest {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramCertificateSigned cert = 1;
     */
    cert?: CMsgSteamDatagramCertificateSigned;
    /**
     * @generated from protobuf field: optional bytes body = 2;
     */
    body?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes signature = 3;
     */
    signature?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PSessionEstablished
 */
export interface CMsgSteamDatagramP2PSessionEstablished {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 3;
     */
    secondsUntilShutdown?: number;
    /**
     * @generated from protobuf field: optional bytes relay_routing_token = 4;
     */
    relayRoutingToken?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 seq_num_r2c = 5 [json_name = "seqNumR2c"];
     */
    seqNumR2C?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsP2PClientToRouter
 */
export interface CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14 [json_name = "p2pRoutingSummary"];
     */
    p2PRoutingSummary?: CMsgSteamDatagramP2PRoutingSummary;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 3;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 4 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 5;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional bytes forward_target_relay_routing_token = 6;
     */
    forwardTargetRelayRoutingToken?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 forward_target_revision = 7;
     */
    forwardTargetRevision?: number;
    /**
     * @generated from protobuf field: optional bytes routes = 8;
     */
    routes?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ack_peer_routes_revision = 9;
     */
    ackPeerRoutesRevision?: number;
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 10;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_c2r = 11 [json_name = "seqNumC2r"];
     */
    seqNumC2R?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 12 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags
 */
export enum CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4,
    /**
     * @generated from protobuf enum value: NOT_PRIMARY_SESSION = 8;
     */
    NOT_PRIMARY_SESSION = 8,
    /**
     * @generated from protobuf enum value: NOT_PRIMARY_TRANSPORT_E2E = 16;
     */
    NOT_PRIMARY_TRANSPORT_E2E = 16,
    /**
     * @generated from protobuf enum value: CLIENT_RELAY_OVERRIDE = 32;
     */
    CLIENT_RELAY_OVERRIDE = 32
}
/**
 * @generated from protobuf message CMsgSteamDatagramConnectionStatsP2PRouterToClient
 */
export interface CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_relay = 1;
     */
    qualityRelay?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];
     */
    qualityE2E?: CMsgSteamDatagramConnectionQuality;
    /**
     * @generated from protobuf field: optional uint32 seconds_until_shutdown = 3;
     */
    secondsUntilShutdown?: number;
    /**
     * @generated from protobuf field: optional fixed32 migrate_request_ip = 4;
     */
    migrateRequestIp?: number;
    /**
     * @generated from protobuf field: optional uint32 migrate_request_port = 5;
     */
    migrateRequestPort?: number;
    /**
     * @generated from protobuf field: optional uint32 scoring_penalty_relay_cluster = 6;
     */
    scoringPenaltyRelayCluster?: number;
    /**
     * @generated from protobuf field: repeated fixed32 ack_relay = 7;
     */
    ackRelay: number[];
    /**
     * @generated from protobuf field: repeated fixed32 legacy_ack_e2e = 8 [json_name = "legacyAckE2e"];
     */
    legacyAckE2E: number[];
    /**
     * @generated from protobuf field: optional uint32 flags = 9;
     */
    flags?: number;
    /**
     * @generated from protobuf field: optional uint32 ack_forward_target_revision = 10;
     */
    ackForwardTargetRevision?: number;
    /**
     * @generated from protobuf field: optional bytes routes = 11;
     */
    routes?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ack_peer_routes_revision = 12;
     */
    ackPeerRoutesRevision?: number;
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 13;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_r2c = 14 [json_name = "seqNumR2c"];
     */
    seqNumR2C?: number;
    /**
     * @generated from protobuf field: optional uint32 seq_num_e2e = 15 [json_name = "seqNumE2e"];
     */
    seqNumE2E?: number;
}
/**
 * @generated from protobuf enum CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags
 */
export enum CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_RELAY = 1;
     */
    ACK_REQUEST_RELAY = 1,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_E2E = 2;
     */
    ACK_REQUEST_E2E = 2,
    /**
     * @generated from protobuf enum value: ACK_REQUEST_IMMEDIATE = 4;
     */
    ACK_REQUEST_IMMEDIATE = 4,
    /**
     * @generated from protobuf enum value: NOT_PRIMARY_TRANSPORT_E2E = 16;
     */
    NOT_PRIMARY_TRANSPORT_E2E = 16
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PBadRouteRouterToClient
 */
export interface CMsgSteamDatagramP2PBadRouteRouterToClient {
    /**
     * @generated from protobuf field: optional fixed32 connection_id = 1;
     */
    connectionId?: number;
    /**
     * @generated from protobuf field: optional bytes failed_relay_routing_token = 2;
     */
    failedRelayRoutingToken?: Uint8Array;
    /**
     * @generated from protobuf field: optional uint32 ack_forward_target_revision = 3;
     */
    ackForwardTargetRevision?: number;
    /**
     * @generated from protobuf field: optional fixed64 kludge_pad = 99;
     */
    kludgePad?: bigint;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PRoutes
 */
export interface CMsgSteamDatagramP2PRoutes {
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;
     */
    relayClusters: CMsgSteamDatagramP2PRoutes_RelayCluster[];
    /**
     * @generated from protobuf field: repeated CMsgSteamDatagramP2PRoutes.Route routes = 2;
     */
    routes: CMsgSteamDatagramP2PRoutes_Route[];
    /**
     * @generated from protobuf field: optional uint32 revision = 3;
     */
    revision?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PRoutes.RelayCluster
 */
export interface CMsgSteamDatagramP2PRoutes_RelayCluster {
    /**
     * @generated from protobuf field: optional fixed32 pop_id = 1;
     */
    popId?: number;
    /**
     * @generated from protobuf field: optional uint32 ping_ms = 2;
     */
    pingMs?: number;
    /**
     * @generated from protobuf field: optional uint32 score_penalty = 3;
     */
    scorePenalty?: number;
    /**
     * @generated from protobuf field: optional bytes session_relay_routing_token = 4;
     */
    sessionRelayRoutingToken?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramP2PRoutes.Route
 */
export interface CMsgSteamDatagramP2PRoutes_Route {
    /**
     * @generated from protobuf field: optional fixed32 my_pop_id = 1;
     */
    myPopId?: number;
    /**
     * @generated from protobuf field: optional fixed32 your_pop_id = 2;
     */
    yourPopId?: number;
    /**
     * @generated from protobuf field: optional uint32 legacy_score = 3;
     */
    legacyScore?: number;
    /**
     * @generated from protobuf field: optional uint32 interior_score = 4;
     */
    interiorScore?: number;
}
/**
 * @generated from protobuf message CMsgSteamDatagramSetSecondaryAddressRequest
 */
export interface CMsgSteamDatagramSetSecondaryAddressRequest {
    /**
     * @generated from protobuf field: optional fixed32 client_main_ip = 1;
     */
    clientMainIp?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_main_port = 2;
     */
    clientMainPort?: number;
    /**
     * @generated from protobuf field: optional fixed32 client_connection_id = 3;
     */
    clientConnectionId?: number;
    /**
     * @generated from protobuf field: optional string client_identity = 4;
     */
    clientIdentity?: string;
    /**
     * @generated from protobuf field: optional bool request_send_duplication = 5;
     */
    requestSendDuplication?: boolean;
    /**
     * @generated from protobuf field: optional bytes kludge_pad = 99;
     */
    kludgePad?: Uint8Array;
}
/**
 * @generated from protobuf message CMsgSteamDatagramSetSecondaryAddressResult
 */
export interface CMsgSteamDatagramSetSecondaryAddressResult {
    /**
     * @generated from protobuf field: optional bool success = 1;
     */
    success?: boolean;
    /**
     * @generated from protobuf field: optional string message = 2;
     */
    message?: string;
}
/**
 * @generated from protobuf enum ESteamDatagramMsgID
 */
export enum ESteamDatagramMsgID {
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_Invalid = 0;
     */
    k_ESteamDatagramMsg_Invalid = 0,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_RouterPingRequest = 1;
     */
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_RouterPingReply = 2;
     */
    k_ESteamDatagramMsg_RouterPingReply = 2,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_GameserverPingRequest = 3;
     */
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_GameserverSessionRequest = 5;
     */
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_GameserverSessionEstablished = 6;
     */
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_NoSession = 7;
     */
    k_ESteamDatagramMsg_NoSession = 7,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_Diagnostic = 8;
     */
    k_ESteamDatagramMsg_Diagnostic = 8,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_DataClientToRouter = 9;
     */
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_DataRouterToServer = 10;
     */
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_DataServerToRouter = 11;
     */
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_DataRouterToClient = 12;
     */
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_Stats = 13;
     */
    k_ESteamDatagramMsg_Stats = 13,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ClientPingSampleRequest = 14;
     */
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ClientPingSampleReply = 15;
     */
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16;
     */
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_RelayHealth = 17;
     */
    k_ESteamDatagramMsg_RelayHealth = 17,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ConnectRequest = 18;
     */
    k_ESteamDatagramMsg_ConnectRequest = 18,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ConnectOK = 19;
     */
    k_ESteamDatagramMsg_ConnectOK = 19,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_ConnectionClosed = 20;
     */
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_NoConnection = 21;
     */
    k_ESteamDatagramMsg_NoConnection = 21,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_TicketDecryptRequest = 22;
     */
    k_ESteamDatagramMsg_TicketDecryptRequest = 22,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_TicketDecryptReply = 23;
     */
    k_ESteamDatagramMsg_TicketDecryptReply = 23,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_P2PSessionRequest = 24;
     */
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_P2PSessionEstablished = 25;
     */
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_P2PStatsClient = 26;
     */
    k_ESteamDatagramMsg_P2PStatsClient = 26,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_P2PStatsRelay = 27;
     */
    k_ESteamDatagramMsg_P2PStatsRelay = 27,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_P2PBadRoute = 28;
     */
    k_ESteamDatagramMsg_P2PBadRoute = 28,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_GameserverPingReply = 29;
     */
    k_ESteamDatagramMsg_GameserverPingReply = 29,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_LegacyGameserverRegistration = 30;
     */
    k_ESteamDatagramMsg_LegacyGameserverRegistration = 30,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_SetSecondaryAddressRequest = 31;
     */
    k_ESteamDatagramMsg_SetSecondaryAddressRequest = 31,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_SetSecondaryAddressResult = 32;
     */
    k_ESteamDatagramMsg_SetSecondaryAddressResult = 32,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_RelayToRelayPingRequest = 33;
     */
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 33,
    /**
     * @generated from protobuf enum value: k_ESteamDatagramMsg_RelayToRelayPingReply = 34;
     */
    k_ESteamDatagramMsg_RelayToRelayPingReply = 34
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingIPAddress$Type extends MessageType<CMsgSteamNetworkingIPAddress> {
    constructor() {
        super("CMsgSteamNetworkingIPAddress", [
            { no: 1, name: "v4", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "v6", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingIPAddress>): CMsgSteamNetworkingIPAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingIPAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingIPAddress): CMsgSteamNetworkingIPAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 v4 */ 1:
                    message.v4 = reader.fixed32();
                    break;
                case /* optional bytes v6 */ 2:
                    message.v6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingIPAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 v4 = 1; */
        if (message.v4 !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.v4);
        /* optional bytes v6 = 2; */
        if (message.v6 !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.v6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingIPAddress
 */
export const CMsgSteamNetworkingIPAddress = new CMsgSteamNetworkingIPAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSignedMessageGeneric$Type extends MessageType<CMsgSteamDatagramSignedMessageGeneric> {
    constructor() {
        super("CMsgSteamDatagramSignedMessageGeneric", [
            { no: 1, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned },
            { no: 2, name: "signed_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 1023, name: "dummy_pad", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramSignedMessageGeneric>): CMsgSteamDatagramSignedMessageGeneric {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramSignedMessageGeneric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramSignedMessageGeneric): CMsgSteamDatagramSignedMessageGeneric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 1:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                case /* optional bytes signed_data */ 2:
                    message.signedData = reader.bytes();
                    break;
                case /* optional bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                case /* optional bytes dummy_pad */ 1023:
                    message.dummyPad = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramSignedMessageGeneric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramCertificateSigned cert = 1; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes signed_data = 2; */
        if (message.signedData !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signedData);
        /* optional bytes signature = 3; */
        if (message.signature !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        /* optional bytes dummy_pad = 1023; */
        if (message.dummyPad !== undefined)
            writer.tag(1023, WireType.LengthDelimited).bytes(message.dummyPad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSignedMessageGeneric
 */
export const CMsgSteamDatagramSignedMessageGeneric = new CMsgSteamDatagramSignedMessageGeneric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramRouterPingReply$Type extends MessageType<CMsgSteamDatagramRouterPingReply> {
    constructor() {
        super("CMsgSteamDatagramRouterPingReply", [
            { no: 1, name: "client_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "latency_datacenter_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "latency_ping_ms", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "latency_datacenter_ids_p2p", kind: "scalar", jsonName: "latencyDatacenterIdsP2p", repeat: 1 /*RepeatType.PACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 15, name: "latency_ping_ms_p2p", kind: "scalar", jsonName: "latencyPingMsP2p", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "your_public_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "your_public_port", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "server_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "client_cookie", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 16, name: "recv_tos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "echo_sent_tos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "sent_tos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "echo_request_reply_tos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "scoring_penalty_relay_cluster", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "route_exceptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramRouterPingReply_RouteException },
            { no: 13, name: "alt_addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramRouterPingReply_AltAddress },
            { no: 99, name: "dummy_pad", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 100, name: "dummy_varint", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramRouterPingReply>): CMsgSteamDatagramRouterPingReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latencyDatacenterIds = [];
        message.latencyPingMs = [];
        message.latencyDatacenterIdsP2P = [];
        message.latencyPingMsP2P = [];
        message.routeExceptions = [];
        message.altAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramRouterPingReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramRouterPingReply): CMsgSteamDatagramRouterPingReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 client_timestamp */ 1:
                    message.clientTimestamp = reader.fixed32();
                    break;
                case /* repeated fixed32 latency_datacenter_ids = 2 [packed = true];*/ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.latencyDatacenterIds.push(reader.fixed32());
                    else
                        message.latencyDatacenterIds.push(reader.fixed32());
                    break;
                case /* repeated uint32 latency_ping_ms = 3 [packed = true];*/ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.latencyPingMs.push(reader.uint32());
                    else
                        message.latencyPingMs.push(reader.uint32());
                    break;
                case /* repeated fixed32 latency_datacenter_ids_p2p = 14 [json_name = "latencyDatacenterIdsP2p", packed = true];*/ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.latencyDatacenterIdsP2P.push(reader.fixed32());
                    else
                        message.latencyDatacenterIdsP2P.push(reader.fixed32());
                    break;
                case /* repeated uint32 latency_ping_ms_p2p = 15 [json_name = "latencyPingMsP2p", packed = true];*/ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.latencyPingMsP2P.push(reader.uint32());
                    else
                        message.latencyPingMsP2P.push(reader.uint32());
                    break;
                case /* optional fixed32 your_public_ip */ 4:
                    message.yourPublicIp = reader.fixed32();
                    break;
                case /* optional fixed32 your_public_port */ 11:
                    message.yourPublicPort = reader.fixed32();
                    break;
                case /* optional fixed32 server_time */ 5:
                    message.serverTime = reader.fixed32();
                    break;
                case /* optional fixed64 challenge */ 6:
                    message.challenge = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 seconds_until_shutdown */ 7:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                case /* optional fixed32 client_cookie */ 8:
                    message.clientCookie = reader.fixed32();
                    break;
                case /* optional uint32 recv_tos */ 16:
                    message.recvTos = reader.uint32();
                    break;
                case /* optional uint32 echo_sent_tos */ 17:
                    message.echoSentTos = reader.uint32();
                    break;
                case /* optional uint32 sent_tos */ 18:
                    message.sentTos = reader.uint32();
                    break;
                case /* optional uint32 echo_request_reply_tos */ 19:
                    message.echoRequestReplyTos = reader.uint32();
                    break;
                case /* optional uint32 scoring_penalty_relay_cluster */ 9:
                    message.scoringPenaltyRelayCluster = reader.uint32();
                    break;
                case /* optional uint32 flags */ 12:
                    message.flags = reader.uint32();
                    break;
                case /* repeated CMsgSteamDatagramRouterPingReply.RouteException route_exceptions */ 10:
                    message.routeExceptions.push(CMsgSteamDatagramRouterPingReply_RouteException.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses */ 13:
                    message.altAddresses.push(CMsgSteamDatagramRouterPingReply_AltAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes dummy_pad */ 99:
                    message.dummyPad = reader.bytes();
                    break;
                case /* optional uint64 dummy_varint */ 100:
                    message.dummyVarint = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramRouterPingReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 client_timestamp = 1; */
        if (message.clientTimestamp !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.clientTimestamp);
        /* repeated fixed32 latency_datacenter_ids = 2 [packed = true]; */
        if (message.latencyDatacenterIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.latencyDatacenterIds.length; i++)
                writer.fixed32(message.latencyDatacenterIds[i]);
            writer.join();
        }
        /* repeated uint32 latency_ping_ms = 3 [packed = true]; */
        if (message.latencyPingMs.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.latencyPingMs.length; i++)
                writer.uint32(message.latencyPingMs[i]);
            writer.join();
        }
        /* repeated fixed32 latency_datacenter_ids_p2p = 14 [json_name = "latencyDatacenterIdsP2p", packed = true]; */
        if (message.latencyDatacenterIdsP2P.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.latencyDatacenterIdsP2P.length; i++)
                writer.fixed32(message.latencyDatacenterIdsP2P[i]);
            writer.join();
        }
        /* repeated uint32 latency_ping_ms_p2p = 15 [json_name = "latencyPingMsP2p", packed = true]; */
        if (message.latencyPingMsP2P.length) {
            writer.tag(15, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.latencyPingMsP2P.length; i++)
                writer.uint32(message.latencyPingMsP2P[i]);
            writer.join();
        }
        /* optional fixed32 your_public_ip = 4; */
        if (message.yourPublicIp !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.yourPublicIp);
        /* optional fixed32 your_public_port = 11; */
        if (message.yourPublicPort !== undefined)
            writer.tag(11, WireType.Bit32).fixed32(message.yourPublicPort);
        /* optional fixed32 server_time = 5; */
        if (message.serverTime !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.serverTime);
        /* optional fixed64 challenge = 6; */
        if (message.challenge !== undefined)
            writer.tag(6, WireType.Bit64).fixed64(message.challenge);
        /* optional uint32 seconds_until_shutdown = 7; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.secondsUntilShutdown);
        /* optional fixed32 client_cookie = 8; */
        if (message.clientCookie !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.clientCookie);
        /* optional uint32 recv_tos = 16; */
        if (message.recvTos !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.recvTos);
        /* optional uint32 echo_sent_tos = 17; */
        if (message.echoSentTos !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.echoSentTos);
        /* optional uint32 sent_tos = 18; */
        if (message.sentTos !== undefined)
            writer.tag(18, WireType.Varint).uint32(message.sentTos);
        /* optional uint32 echo_request_reply_tos = 19; */
        if (message.echoRequestReplyTos !== undefined)
            writer.tag(19, WireType.Varint).uint32(message.echoRequestReplyTos);
        /* optional uint32 scoring_penalty_relay_cluster = 9; */
        if (message.scoringPenaltyRelayCluster !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.scoringPenaltyRelayCluster);
        /* optional uint32 flags = 12; */
        if (message.flags !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.flags);
        /* repeated CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10; */
        for (let i = 0; i < message.routeExceptions.length; i++)
            CMsgSteamDatagramRouterPingReply_RouteException.internalBinaryWrite(message.routeExceptions[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13; */
        for (let i = 0; i < message.altAddresses.length; i++)
            CMsgSteamDatagramRouterPingReply_AltAddress.internalBinaryWrite(message.altAddresses[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes dummy_pad = 99; */
        if (message.dummyPad !== undefined)
            writer.tag(99, WireType.LengthDelimited).bytes(message.dummyPad);
        /* optional uint64 dummy_varint = 100; */
        if (message.dummyVarint !== undefined)
            writer.tag(100, WireType.Varint).uint64(message.dummyVarint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramRouterPingReply
 */
export const CMsgSteamDatagramRouterPingReply = new CMsgSteamDatagramRouterPingReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramRouterPingReply_RouteException$Type extends MessageType<CMsgSteamDatagramRouterPingReply_RouteException> {
    constructor() {
        super("CMsgSteamDatagramRouterPingReply.RouteException", [
            { no: 1, name: "data_center_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "penalty", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramRouterPingReply_RouteException>): CMsgSteamDatagramRouterPingReply_RouteException {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramRouterPingReply_RouteException>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramRouterPingReply_RouteException): CMsgSteamDatagramRouterPingReply_RouteException {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 data_center_id */ 1:
                    message.dataCenterId = reader.fixed32();
                    break;
                case /* optional uint32 flags */ 2:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 penalty */ 3:
                    message.penalty = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramRouterPingReply_RouteException, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 data_center_id = 1; */
        if (message.dataCenterId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.dataCenterId);
        /* optional uint32 flags = 2; */
        if (message.flags !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.flags);
        /* optional uint32 penalty = 3; */
        if (message.penalty !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.penalty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramRouterPingReply.RouteException
 */
export const CMsgSteamDatagramRouterPingReply_RouteException = new CMsgSteamDatagramRouterPingReply_RouteException$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramRouterPingReply_AltAddress$Type extends MessageType<CMsgSteamDatagramRouterPingReply_AltAddress> {
    constructor() {
        super("CMsgSteamDatagramRouterPingReply.AltAddress", [
            { no: 1, name: "ipv4", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "penalty", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "protocol", kind: "enum", opt: true, T: () => ["CMsgSteamDatagramRouterPingReply.AltAddress.Protocol", CMsgSteamDatagramRouterPingReply_AltAddress_Protocol] },
            { no: 5, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramRouterPingReply_AltAddress>): CMsgSteamDatagramRouterPingReply_AltAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramRouterPingReply_AltAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramRouterPingReply_AltAddress): CMsgSteamDatagramRouterPingReply_AltAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 ipv4 */ 1:
                    message.ipv4 = reader.fixed32();
                    break;
                case /* optional uint32 port */ 2:
                    message.port = reader.uint32();
                    break;
                case /* optional uint32 penalty */ 3:
                    message.penalty = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol */ 4:
                    message.protocol = reader.int32();
                    break;
                case /* optional string id */ 5:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramRouterPingReply_AltAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 ipv4 = 1; */
        if (message.ipv4 !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.ipv4);
        /* optional uint32 port = 2; */
        if (message.port !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.port);
        /* optional uint32 penalty = 3; */
        if (message.penalty !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.penalty);
        /* optional CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4; */
        if (message.protocol !== undefined)
            writer.tag(4, WireType.Varint).int32(message.protocol);
        /* optional string id = 5; */
        if (message.id !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramRouterPingReply.AltAddress
 */
export const CMsgSteamDatagramRouterPingReply_AltAddress = new CMsgSteamDatagramRouterPingReply_AltAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramGameserverPingRequestBody$Type extends MessageType<CMsgSteamDatagramGameserverPingRequestBody> {
    constructor() {
        super("CMsgSteamDatagramGameserverPingRequestBody", [
            { no: 1, name: "relay_popid", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "your_public_ip", kind: "message", T: () => CMsgSteamNetworkingIPAddress },
            { no: 3, name: "your_public_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "relay_unix_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "routing_secret", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "my_ips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamNetworkingIPAddress },
            { no: 8, name: "echo", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramGameserverPingRequestBody>): CMsgSteamDatagramGameserverPingRequestBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.myIps = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramGameserverPingRequestBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramGameserverPingRequestBody): CMsgSteamDatagramGameserverPingRequestBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 relay_popid */ 1:
                    message.relayPopid = reader.fixed32();
                    break;
                case /* optional CMsgSteamNetworkingIPAddress your_public_ip */ 2:
                    message.yourPublicIp = CMsgSteamNetworkingIPAddress.internalBinaryRead(reader, reader.uint32(), options, message.yourPublicIp);
                    break;
                case /* optional uint32 your_public_port */ 3:
                    message.yourPublicPort = reader.uint32();
                    break;
                case /* optional uint64 relay_unix_time */ 4:
                    message.relayUnixTime = reader.uint64().toBigInt();
                    break;
                case /* optional fixed64 routing_secret */ 5:
                    message.routingSecret = reader.fixed64().toBigInt();
                    break;
                case /* repeated CMsgSteamNetworkingIPAddress my_ips */ 6:
                    message.myIps.push(CMsgSteamNetworkingIPAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes echo */ 8:
                    message.echo = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramGameserverPingRequestBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 relay_popid = 1; */
        if (message.relayPopid !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.relayPopid);
        /* optional CMsgSteamNetworkingIPAddress your_public_ip = 2; */
        if (message.yourPublicIp)
            CMsgSteamNetworkingIPAddress.internalBinaryWrite(message.yourPublicIp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 your_public_port = 3; */
        if (message.yourPublicPort !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.yourPublicPort);
        /* optional uint64 relay_unix_time = 4; */
        if (message.relayUnixTime !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.relayUnixTime);
        /* optional fixed64 routing_secret = 5; */
        if (message.routingSecret !== undefined)
            writer.tag(5, WireType.Bit64).fixed64(message.routingSecret);
        /* repeated CMsgSteamNetworkingIPAddress my_ips = 6; */
        for (let i = 0; i < message.myIps.length; i++)
            CMsgSteamNetworkingIPAddress.internalBinaryWrite(message.myIps[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes echo = 8; */
        if (message.echo !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.echo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramGameserverPingRequestBody
 */
export const CMsgSteamDatagramGameserverPingRequestBody = new CMsgSteamDatagramGameserverPingRequestBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramGameserverPingRequestEnvelope$Type extends MessageType<CMsgSteamDatagramGameserverPingRequestEnvelope> {
    constructor() {
        super("CMsgSteamDatagramGameserverPingRequestEnvelope", [
            { no: 6, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned },
            { no: 7, name: "signed_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 1, name: "legacy_your_public_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "legacy_your_public_port", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "legacy_relay_unix_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "legacy_challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "legacy_router_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 1023, name: "dummy_pad", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramGameserverPingRequestEnvelope>): CMsgSteamDatagramGameserverPingRequestEnvelope {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramGameserverPingRequestEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramGameserverPingRequestEnvelope): CMsgSteamDatagramGameserverPingRequestEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 6:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                case /* optional bytes signed_data */ 7:
                    message.signedData = reader.bytes();
                    break;
                case /* optional bytes signature */ 8:
                    message.signature = reader.bytes();
                    break;
                case /* optional fixed32 legacy_your_public_ip */ 1:
                    message.legacyYourPublicIp = reader.fixed32();
                    break;
                case /* optional fixed32 legacy_your_public_port */ 5:
                    message.legacyYourPublicPort = reader.fixed32();
                    break;
                case /* optional fixed32 legacy_relay_unix_time */ 2:
                    message.legacyRelayUnixTime = reader.fixed32();
                    break;
                case /* optional fixed64 legacy_challenge */ 3:
                    message.legacyChallenge = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 legacy_router_timestamp */ 4:
                    message.legacyRouterTimestamp = reader.fixed32();
                    break;
                case /* optional bytes dummy_pad */ 1023:
                    message.dummyPad = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramGameserverPingRequestEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramCertificateSigned cert = 6; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes signed_data = 7; */
        if (message.signedData !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.signedData);
        /* optional bytes signature = 8; */
        if (message.signature !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.signature);
        /* optional fixed32 legacy_your_public_ip = 1; */
        if (message.legacyYourPublicIp !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.legacyYourPublicIp);
        /* optional fixed32 legacy_your_public_port = 5; */
        if (message.legacyYourPublicPort !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.legacyYourPublicPort);
        /* optional fixed32 legacy_relay_unix_time = 2; */
        if (message.legacyRelayUnixTime !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.legacyRelayUnixTime);
        /* optional fixed64 legacy_challenge = 3; */
        if (message.legacyChallenge !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyChallenge);
        /* optional fixed32 legacy_router_timestamp = 4; */
        if (message.legacyRouterTimestamp !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.legacyRouterTimestamp);
        /* optional bytes dummy_pad = 1023; */
        if (message.dummyPad !== undefined)
            writer.tag(1023, WireType.LengthDelimited).bytes(message.dummyPad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramGameserverPingRequestEnvelope
 */
export const CMsgSteamDatagramGameserverPingRequestEnvelope = new CMsgSteamDatagramGameserverPingRequestEnvelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramGameserverPingReplyData$Type extends MessageType<CMsgSteamDatagramGameserverPingReplyData> {
    constructor() {
        super("CMsgSteamDatagramGameserverPingReplyData", [
            { no: 2, name: "echo_relay_unix_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "echo", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "legacy_challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "legacy_router_timestamp", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "data_center_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "appid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "build", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "network_config_version", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "my_unix_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 12, name: "routing_blob", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramGameserverPingReplyData>): CMsgSteamDatagramGameserverPingReplyData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramGameserverPingReplyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramGameserverPingReplyData): CMsgSteamDatagramGameserverPingReplyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 echo_relay_unix_time */ 2:
                    message.echoRelayUnixTime = reader.fixed32();
                    break;
                case /* optional bytes echo */ 8:
                    message.echo = reader.bytes();
                    break;
                case /* optional fixed64 legacy_challenge */ 3:
                    message.legacyChallenge = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 legacy_router_timestamp */ 4:
                    message.legacyRouterTimestamp = reader.fixed32();
                    break;
                case /* optional fixed32 data_center_id */ 5:
                    message.dataCenterId = reader.fixed32();
                    break;
                case /* optional uint32 appid */ 6:
                    message.appid = reader.uint32();
                    break;
                case /* optional uint32 protocol_version */ 7:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional string build */ 9:
                    message.build = reader.string();
                    break;
                case /* optional uint64 network_config_version */ 10:
                    message.networkConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* optional fixed32 my_unix_time */ 11:
                    message.myUnixTime = reader.fixed32();
                    break;
                case /* optional bytes routing_blob */ 12:
                    message.routingBlob = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramGameserverPingReplyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 echo_relay_unix_time = 2; */
        if (message.echoRelayUnixTime !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.echoRelayUnixTime);
        /* optional bytes echo = 8; */
        if (message.echo !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.echo);
        /* optional fixed64 legacy_challenge = 3; */
        if (message.legacyChallenge !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyChallenge);
        /* optional fixed32 legacy_router_timestamp = 4; */
        if (message.legacyRouterTimestamp !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.legacyRouterTimestamp);
        /* optional fixed32 data_center_id = 5; */
        if (message.dataCenterId !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.dataCenterId);
        /* optional uint32 appid = 6; */
        if (message.appid !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.appid);
        /* optional uint32 protocol_version = 7; */
        if (message.protocolVersion !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.protocolVersion);
        /* optional string build = 9; */
        if (message.build !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.build);
        /* optional uint64 network_config_version = 10; */
        if (message.networkConfigVersion !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.networkConfigVersion);
        /* optional fixed32 my_unix_time = 11; */
        if (message.myUnixTime !== undefined)
            writer.tag(11, WireType.Bit32).fixed32(message.myUnixTime);
        /* optional bytes routing_blob = 12; */
        if (message.routingBlob !== undefined)
            writer.tag(12, WireType.LengthDelimited).bytes(message.routingBlob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramGameserverPingReplyData
 */
export const CMsgSteamDatagramGameserverPingReplyData = new CMsgSteamDatagramGameserverPingReplyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramNoSessionRelayToClient$Type extends MessageType<CMsgSteamDatagramNoSessionRelayToClient> {
    constructor() {
        super("CMsgSteamDatagramNoSessionRelayToClient", [
            { no: 7, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "your_public_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "your_public_port", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "server_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramNoSessionRelayToClient>): CMsgSteamDatagramNoSessionRelayToClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramNoSessionRelayToClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramNoSessionRelayToClient): CMsgSteamDatagramNoSessionRelayToClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 7:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional fixed32 your_public_ip */ 2:
                    message.yourPublicIp = reader.fixed32();
                    break;
                case /* optional fixed32 your_public_port */ 6:
                    message.yourPublicPort = reader.fixed32();
                    break;
                case /* optional fixed32 server_time */ 3:
                    message.serverTime = reader.fixed32();
                    break;
                case /* optional fixed64 challenge */ 4:
                    message.challenge = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 seconds_until_shutdown */ 5:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramNoSessionRelayToClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 7; */
        if (message.connectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.connectionId);
        /* optional fixed32 your_public_ip = 2; */
        if (message.yourPublicIp !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.yourPublicIp);
        /* optional fixed32 your_public_port = 6; */
        if (message.yourPublicPort !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.yourPublicPort);
        /* optional fixed32 server_time = 3; */
        if (message.serverTime !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.serverTime);
        /* optional fixed64 challenge = 4; */
        if (message.challenge !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.challenge);
        /* optional uint32 seconds_until_shutdown = 5; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.secondsUntilShutdown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramNoSessionRelayToClient
 */
export const CMsgSteamDatagramNoSessionRelayToClient = new CMsgSteamDatagramNoSessionRelayToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramNoSessionRelayToPeer$Type extends MessageType<CMsgSteamDatagramNoSessionRelayToPeer> {
    constructor() {
        super("CMsgSteamDatagramNoSessionRelayToPeer", [
            { no: 1, name: "legacy_relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "from_relay_session_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "from_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 99, name: "kludge_pad", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramNoSessionRelayToPeer>): CMsgSteamDatagramNoSessionRelayToPeer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramNoSessionRelayToPeer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramNoSessionRelayToPeer): CMsgSteamDatagramNoSessionRelayToPeer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 legacy_relay_session_id */ 1:
                    message.legacyRelaySessionId = reader.uint32();
                    break;
                case /* optional fixed32 from_relay_session_id */ 2:
                    message.fromRelaySessionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_connection_id */ 7:
                    message.fromConnectionId = reader.fixed32();
                    break;
                case /* optional fixed64 kludge_pad */ 99:
                    message.kludgePad = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramNoSessionRelayToPeer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 legacy_relay_session_id = 1; */
        if (message.legacyRelaySessionId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.legacyRelaySessionId);
        /* optional fixed32 from_relay_session_id = 2; */
        if (message.fromRelaySessionId !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.fromRelaySessionId);
        /* optional fixed32 from_connection_id = 7; */
        if (message.fromConnectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.fromConnectionId);
        /* optional fixed64 kludge_pad = 99; */
        if (message.kludgePad !== undefined)
            writer.tag(99, WireType.Bit64).fixed64(message.kludgePad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramNoSessionRelayToPeer
 */
export const CMsgSteamDatagramNoSessionRelayToPeer = new CMsgSteamDatagramNoSessionRelayToPeer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgTOSTreatment$Type extends MessageType<CMsgTOSTreatment> {
    constructor() {
        super("CMsgTOSTreatment", [
            { no: 1, name: "l4s_detect", kind: "scalar", jsonName: "l4sDetect", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "up_ecn1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "down_dscp45", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgTOSTreatment>): CMsgTOSTreatment {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgTOSTreatment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgTOSTreatment): CMsgTOSTreatment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string l4s_detect = 1 [json_name = "l4sDetect"];*/ 1:
                    message.l4SDetect = reader.string();
                    break;
                case /* optional string up_ecn1 */ 2:
                    message.upEcn1 = reader.string();
                    break;
                case /* optional string down_dscp45 */ 3:
                    message.downDscp45 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgTOSTreatment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string l4s_detect = 1 [json_name = "l4sDetect"]; */
        if (message.l4SDetect !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.l4SDetect);
        /* optional string up_ecn1 = 2; */
        if (message.upEcn1 !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.upEcn1);
        /* optional string down_dscp45 = 3; */
        if (message.downDscp45 !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.downDscp45);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgTOSTreatment
 */
export const CMsgTOSTreatment = new CMsgTOSTreatment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientPingSampleRequest$Type extends MessageType<CMsgSteamDatagramClientPingSampleRequest> {
    constructor() {
        super("CMsgSteamDatagramClientPingSampleRequest", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientPingSampleRequest>): CMsgSteamDatagramClientPingSampleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientPingSampleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientPingSampleRequest): CMsgSteamDatagramClientPingSampleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientPingSampleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientPingSampleRequest
 */
export const CMsgSteamDatagramClientPingSampleRequest = new CMsgSteamDatagramClientPingSampleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientPingSampleReply$Type extends MessageType<CMsgSteamDatagramClientPingSampleReply> {
    constructor() {
        super("CMsgSteamDatagramClientPingSampleReply", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "relay_override_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "tos", kind: "message", T: () => CMsgTOSTreatment },
            { no: 2, name: "pops", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramClientPingSampleReply_POP },
            { no: 3, name: "legacy_data_centers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientPingSampleReply>): CMsgSteamDatagramClientPingSampleReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pops = [];
        message.legacyDataCenters = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientPingSampleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientPingSampleReply): CMsgSteamDatagramClientPingSampleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional bool relay_override_active */ 5:
                    message.relayOverrideActive = reader.bool();
                    break;
                case /* optional CMsgTOSTreatment tos */ 6:
                    message.tos = CMsgTOSTreatment.internalBinaryRead(reader, reader.uint32(), options, message.tos);
                    break;
                case /* repeated CMsgSteamDatagramClientPingSampleReply.POP pops */ 2:
                    message.pops.push(CMsgSteamDatagramClientPingSampleReply_POP.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers */ 3:
                    message.legacyDataCenters.push(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientPingSampleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional bool relay_override_active = 5; */
        if (message.relayOverrideActive !== undefined)
            writer.tag(5, WireType.Varint).bool(message.relayOverrideActive);
        /* optional CMsgTOSTreatment tos = 6; */
        if (message.tos)
            CMsgTOSTreatment.internalBinaryWrite(message.tos, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamDatagramClientPingSampleReply.POP pops = 2; */
        for (let i = 0; i < message.pops.length; i++)
            CMsgSteamDatagramClientPingSampleReply_POP.internalBinaryWrite(message.pops[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3; */
        for (let i = 0; i < message.legacyDataCenters.length; i++)
            CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter.internalBinaryWrite(message.legacyDataCenters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientPingSampleReply
 */
export const CMsgSteamDatagramClientPingSampleReply = new CMsgSteamDatagramClientPingSampleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientPingSampleReply_POP$Type extends MessageType<CMsgSteamDatagramClientPingSampleReply_POP> {
    constructor() {
        super("CMsgSteamDatagramClientPingSampleReply.POP", [
            { no: 1, name: "pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "default_front_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cluster_penalty", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "alt_addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramClientPingSampleReply_POP_AltAddress },
            { no: 3, name: "default_e2e_ping_ms", kind: "scalar", jsonName: "defaultE2ePingMs", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "default_e2e_score", kind: "scalar", jsonName: "defaultE2eScore", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "p2p_via_peer_relay_pop_id", kind: "scalar", jsonName: "p2pViaPeerRelayPopId", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "best_dc_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "best_dc_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "best_dc_via_relay_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 12, name: "default_dc_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "default_dc_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "default_dc_via_relay_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 15, name: "test_dc_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "test_dc_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "test_dc_via_relay_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientPingSampleReply_POP>): CMsgSteamDatagramClientPingSampleReply_POP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.altAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientPingSampleReply_POP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientPingSampleReply_POP): CMsgSteamDatagramClientPingSampleReply_POP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 pop_id */ 1:
                    message.popId = reader.fixed32();
                    break;
                case /* optional uint32 default_front_ping_ms */ 2:
                    message.defaultFrontPingMs = reader.uint32();
                    break;
                case /* optional uint32 cluster_penalty */ 4:
                    message.clusterPenalty = reader.uint32();
                    break;
                case /* repeated CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses */ 7:
                    message.altAddresses.push(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 default_e2e_ping_ms = 3 [json_name = "defaultE2ePingMs"];*/ 3:
                    message.defaultE2EPingMs = reader.uint32();
                    break;
                case /* optional uint32 default_e2e_score = 5 [json_name = "defaultE2eScore"];*/ 5:
                    message.defaultE2EScore = reader.uint32();
                    break;
                case /* optional fixed32 p2p_via_peer_relay_pop_id = 6 [json_name = "p2pViaPeerRelayPopId"];*/ 6:
                    message.p2PViaPeerRelayPopId = reader.fixed32();
                    break;
                case /* optional uint32 best_dc_ping_ms */ 9:
                    message.bestDcPingMs = reader.uint32();
                    break;
                case /* optional uint32 best_dc_score */ 10:
                    message.bestDcScore = reader.uint32();
                    break;
                case /* optional fixed32 best_dc_via_relay_pop_id */ 11:
                    message.bestDcViaRelayPopId = reader.fixed32();
                    break;
                case /* optional uint32 default_dc_ping_ms */ 12:
                    message.defaultDcPingMs = reader.uint32();
                    break;
                case /* optional uint32 default_dc_score */ 13:
                    message.defaultDcScore = reader.uint32();
                    break;
                case /* optional fixed32 default_dc_via_relay_pop_id */ 14:
                    message.defaultDcViaRelayPopId = reader.fixed32();
                    break;
                case /* optional uint32 test_dc_ping_ms */ 15:
                    message.testDcPingMs = reader.uint32();
                    break;
                case /* optional uint32 test_dc_score */ 16:
                    message.testDcScore = reader.uint32();
                    break;
                case /* optional fixed32 test_dc_via_relay_pop_id */ 17:
                    message.testDcViaRelayPopId = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientPingSampleReply_POP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 pop_id = 1; */
        if (message.popId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.popId);
        /* optional uint32 default_front_ping_ms = 2; */
        if (message.defaultFrontPingMs !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.defaultFrontPingMs);
        /* optional uint32 cluster_penalty = 4; */
        if (message.clusterPenalty !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.clusterPenalty);
        /* repeated CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7; */
        for (let i = 0; i < message.altAddresses.length; i++)
            CMsgSteamDatagramClientPingSampleReply_POP_AltAddress.internalBinaryWrite(message.altAddresses[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 default_e2e_ping_ms = 3 [json_name = "defaultE2ePingMs"]; */
        if (message.defaultE2EPingMs !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.defaultE2EPingMs);
        /* optional uint32 default_e2e_score = 5 [json_name = "defaultE2eScore"]; */
        if (message.defaultE2EScore !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.defaultE2EScore);
        /* optional fixed32 p2p_via_peer_relay_pop_id = 6 [json_name = "p2pViaPeerRelayPopId"]; */
        if (message.p2PViaPeerRelayPopId !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.p2PViaPeerRelayPopId);
        /* optional uint32 best_dc_ping_ms = 9; */
        if (message.bestDcPingMs !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.bestDcPingMs);
        /* optional uint32 best_dc_score = 10; */
        if (message.bestDcScore !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.bestDcScore);
        /* optional fixed32 best_dc_via_relay_pop_id = 11; */
        if (message.bestDcViaRelayPopId !== undefined)
            writer.tag(11, WireType.Bit32).fixed32(message.bestDcViaRelayPopId);
        /* optional uint32 default_dc_ping_ms = 12; */
        if (message.defaultDcPingMs !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.defaultDcPingMs);
        /* optional uint32 default_dc_score = 13; */
        if (message.defaultDcScore !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.defaultDcScore);
        /* optional fixed32 default_dc_via_relay_pop_id = 14; */
        if (message.defaultDcViaRelayPopId !== undefined)
            writer.tag(14, WireType.Bit32).fixed32(message.defaultDcViaRelayPopId);
        /* optional uint32 test_dc_ping_ms = 15; */
        if (message.testDcPingMs !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.testDcPingMs);
        /* optional uint32 test_dc_score = 16; */
        if (message.testDcScore !== undefined)
            writer.tag(16, WireType.Varint).uint32(message.testDcScore);
        /* optional fixed32 test_dc_via_relay_pop_id = 17; */
        if (message.testDcViaRelayPopId !== undefined)
            writer.tag(17, WireType.Bit32).fixed32(message.testDcViaRelayPopId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientPingSampleReply.POP
 */
export const CMsgSteamDatagramClientPingSampleReply_POP = new CMsgSteamDatagramClientPingSampleReply_POP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientPingSampleReply_POP_AltAddress$Type extends MessageType<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress> {
    constructor() {
        super("CMsgSteamDatagramClientPingSampleReply.POP.AltAddress", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "front_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "penalty", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>): CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientPingSampleReply_POP_AltAddress): CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional uint32 front_ping_ms */ 2:
                    message.frontPingMs = reader.uint32();
                    break;
                case /* optional uint32 penalty */ 3:
                    message.penalty = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientPingSampleReply_POP_AltAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional uint32 front_ping_ms = 2; */
        if (message.frontPingMs !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.frontPingMs);
        /* optional uint32 penalty = 3; */
        if (message.penalty !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.penalty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientPingSampleReply.POP.AltAddress
 */
export const CMsgSteamDatagramClientPingSampleReply_POP_AltAddress = new CMsgSteamDatagramClientPingSampleReply_POP_AltAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter$Type extends MessageType<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter> {
    constructor() {
        super("CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter", [
            { no: 1, name: "data_center_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "best_dc_via_relay_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "best_dc_ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>): CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter): CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 data_center_id */ 1:
                    message.dataCenterId = reader.fixed32();
                    break;
                case /* optional fixed32 best_dc_via_relay_pop_id */ 2:
                    message.bestDcViaRelayPopId = reader.fixed32();
                    break;
                case /* optional uint32 best_dc_ping_ms */ 3:
                    message.bestDcPingMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 data_center_id = 1; */
        if (message.dataCenterId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.dataCenterId);
        /* optional fixed32 best_dc_via_relay_pop_id = 2; */
        if (message.bestDcViaRelayPopId !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.bestDcViaRelayPopId);
        /* optional uint32 best_dc_ping_ms = 3; */
        if (message.bestDcPingMs !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.bestDcPingMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter
 */
export const CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter = new CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientSwitchedPrimary$Type extends MessageType<CMsgSteamDatagramClientSwitchedPrimary> {
    constructor() {
        super("CMsgSteamDatagramClientSwitchedPrimary", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "from_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "from_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "from_router_cluster", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "from_active_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "from_active_packets_recv", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "from_dropped_reason", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "gap_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "from_quality_now", kind: "message", T: () => CMsgSteamDatagramClientSwitchedPrimary_RouterQuality },
            { no: 10, name: "to_quality_now", kind: "message", T: () => CMsgSteamDatagramClientSwitchedPrimary_RouterQuality },
            { no: 11, name: "from_quality_then", kind: "message", T: () => CMsgSteamDatagramClientSwitchedPrimary_RouterQuality },
            { no: 12, name: "to_quality_then", kind: "message", T: () => CMsgSteamDatagramClientSwitchedPrimary_RouterQuality }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientSwitchedPrimary>): CMsgSteamDatagramClientSwitchedPrimary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientSwitchedPrimary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientSwitchedPrimary): CMsgSteamDatagramClientSwitchedPrimary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_ip */ 2:
                    message.fromIp = reader.fixed32();
                    break;
                case /* optional uint32 from_port */ 3:
                    message.fromPort = reader.uint32();
                    break;
                case /* optional fixed32 from_router_cluster */ 4:
                    message.fromRouterCluster = reader.fixed32();
                    break;
                case /* optional uint32 from_active_time */ 5:
                    message.fromActiveTime = reader.uint32();
                    break;
                case /* optional uint32 from_active_packets_recv */ 6:
                    message.fromActivePacketsRecv = reader.uint32();
                    break;
                case /* optional string from_dropped_reason */ 7:
                    message.fromDroppedReason = reader.string();
                    break;
                case /* optional uint32 gap_ms */ 8:
                    message.gapMs = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now */ 9:
                    message.fromQualityNow = CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryRead(reader, reader.uint32(), options, message.fromQualityNow);
                    break;
                case /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now */ 10:
                    message.toQualityNow = CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryRead(reader, reader.uint32(), options, message.toQualityNow);
                    break;
                case /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then */ 11:
                    message.fromQualityThen = CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryRead(reader, reader.uint32(), options, message.fromQualityThen);
                    break;
                case /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then */ 12:
                    message.toQualityThen = CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryRead(reader, reader.uint32(), options, message.toQualityThen);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientSwitchedPrimary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional fixed32 from_ip = 2; */
        if (message.fromIp !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.fromIp);
        /* optional uint32 from_port = 3; */
        if (message.fromPort !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.fromPort);
        /* optional fixed32 from_router_cluster = 4; */
        if (message.fromRouterCluster !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.fromRouterCluster);
        /* optional uint32 from_active_time = 5; */
        if (message.fromActiveTime !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.fromActiveTime);
        /* optional uint32 from_active_packets_recv = 6; */
        if (message.fromActivePacketsRecv !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.fromActivePacketsRecv);
        /* optional string from_dropped_reason = 7; */
        if (message.fromDroppedReason !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.fromDroppedReason);
        /* optional uint32 gap_ms = 8; */
        if (message.gapMs !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.gapMs);
        /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9; */
        if (message.fromQualityNow)
            CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryWrite(message.fromQualityNow, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10; */
        if (message.toQualityNow)
            CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryWrite(message.toQualityNow, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11; */
        if (message.fromQualityThen)
            CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryWrite(message.fromQualityThen, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12; */
        if (message.toQualityThen)
            CMsgSteamDatagramClientSwitchedPrimary_RouterQuality.internalBinaryWrite(message.toQualityThen, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientSwitchedPrimary
 */
export const CMsgSteamDatagramClientSwitchedPrimary = new CMsgSteamDatagramClientSwitchedPrimary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramClientSwitchedPrimary_RouterQuality$Type extends MessageType<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality> {
    constructor() {
        super("CMsgSteamDatagramClientSwitchedPrimary.RouterQuality", [
            { no: 1, name: "score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "front_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "back_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "seconds_until_down", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>): CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality): CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 score */ 1:
                    message.score = reader.uint32();
                    break;
                case /* optional uint32 front_ping */ 2:
                    message.frontPing = reader.uint32();
                    break;
                case /* optional uint32 back_ping */ 3:
                    message.backPing = reader.uint32();
                    break;
                case /* optional uint32 seconds_until_down */ 4:
                    message.secondsUntilDown = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 score = 1; */
        if (message.score !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.score);
        /* optional uint32 front_ping = 2; */
        if (message.frontPing !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.frontPing);
        /* optional uint32 back_ping = 3; */
        if (message.backPing !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.backPing);
        /* optional uint32 seconds_until_down = 4; */
        if (message.secondsUntilDown !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.secondsUntilDown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramClientSwitchedPrimary.RouterQuality
 */
export const CMsgSteamDatagramClientSwitchedPrimary_RouterQuality = new CMsgSteamDatagramClientSwitchedPrimary_RouterQuality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectRequest$Type extends MessageType<CMsgSteamDatagramConnectRequest> {
    constructor() {
        super("CMsgSteamDatagramConnectRequest", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "my_timestamp", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "ping_est_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "virtual_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameserver_relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "crypt", kind: "message", T: () => CMsgSteamDatagramSessionCryptInfoSigned },
            { no: 7, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned },
            { no: 10, name: "routing_secret", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "legacy_client_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectRequest>): CMsgSteamDatagramConnectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectRequest): CMsgSteamDatagramConnectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional fixed64 my_timestamp */ 4:
                    message.myTimestamp = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 ping_est_ms */ 5:
                    message.pingEstMs = reader.uint32();
                    break;
                case /* optional uint32 virtual_port */ 9:
                    message.virtualPort = reader.uint32();
                    break;
                case /* optional uint32 gameserver_relay_session_id */ 2:
                    message.gameserverRelaySessionId = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 6:
                    message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(reader, reader.uint32(), options, message.crypt);
                    break;
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 7:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                case /* optional fixed64 routing_secret */ 10:
                    message.routingSecret = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed64 legacy_client_steam_id */ 3:
                    message.legacyClientSteamId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional fixed64 my_timestamp = 4; */
        if (message.myTimestamp !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.myTimestamp);
        /* optional uint32 ping_est_ms = 5; */
        if (message.pingEstMs !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.pingEstMs);
        /* optional uint32 virtual_port = 9; */
        if (message.virtualPort !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.virtualPort);
        /* optional uint32 gameserver_relay_session_id = 2; */
        if (message.gameserverRelaySessionId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameserverRelaySessionId);
        /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 6; */
        if (message.crypt)
            CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(message.crypt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramCertificateSigned cert = 7; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 routing_secret = 10; */
        if (message.routingSecret !== undefined)
            writer.tag(10, WireType.Bit64).fixed64(message.routingSecret);
        /* optional fixed64 legacy_client_steam_id = 3; */
        if (message.legacyClientSteamId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyClientSteamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectRequest
 */
export const CMsgSteamDatagramConnectRequest = new CMsgSteamDatagramConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectOK$Type extends MessageType<CMsgSteamDatagramConnectOK> {
    constructor() {
        super("CMsgSteamDatagramConnectOK", [
            { no: 1, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "server_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "your_timestamp", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "delay_time_usec", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gameserver_relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "crypt", kind: "message", T: () => CMsgSteamDatagramSessionCryptInfoSigned },
            { no: 6, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectOK>): CMsgSteamDatagramConnectOK {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectOK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectOK): CMsgSteamDatagramConnectOK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 client_connection_id */ 1:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 server_connection_id */ 7:
                    message.serverConnectionId = reader.fixed32();
                    break;
                case /* optional fixed64 your_timestamp */ 3:
                    message.yourTimestamp = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 delay_time_usec */ 4:
                    message.delayTimeUsec = reader.uint32();
                    break;
                case /* optional uint32 gameserver_relay_session_id */ 2:
                    message.gameserverRelaySessionId = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt */ 5:
                    message.crypt = CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryRead(reader, reader.uint32(), options, message.crypt);
                    break;
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 6:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectOK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 client_connection_id = 1; */
        if (message.clientConnectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional fixed32 server_connection_id = 7; */
        if (message.serverConnectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.serverConnectionId);
        /* optional fixed64 your_timestamp = 3; */
        if (message.yourTimestamp !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.yourTimestamp);
        /* optional uint32 delay_time_usec = 4; */
        if (message.delayTimeUsec !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.delayTimeUsec);
        /* optional uint32 gameserver_relay_session_id = 2; */
        if (message.gameserverRelaySessionId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.gameserverRelaySessionId);
        /* optional CMsgSteamDatagramSessionCryptInfoSigned crypt = 5; */
        if (message.crypt)
            CMsgSteamDatagramSessionCryptInfoSigned.internalBinaryWrite(message.crypt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramCertificateSigned cert = 6; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectOK
 */
export const CMsgSteamDatagramConnectOK = new CMsgSteamDatagramConnectOK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamNetworkingP2PSDRRoutingSummary$Type extends MessageType<CMsgSteamNetworkingP2PSDRRoutingSummary> {
    constructor() {
        super("CMsgSteamNetworkingP2PSDRRoutingSummary", [
            { no: 1, name: "initial_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "initial_ping_front_local", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "initial_ping_front_remote", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "initial_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "initial_pop_local", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "initial_pop_remote", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "best_ping", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "best_ping_front_local", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "best_ping_front_remote", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "best_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "best_pop_local", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 16, name: "best_pop_remote", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 17, name: "best_time", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "negotiation_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "selected_seconds", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamNetworkingP2PSDRRoutingSummary>): CMsgSteamNetworkingP2PSDRRoutingSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamNetworkingP2PSDRRoutingSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamNetworkingP2PSDRRoutingSummary): CMsgSteamNetworkingP2PSDRRoutingSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 initial_ping */ 1:
                    message.initialPing = reader.uint32();
                    break;
                case /* optional uint32 initial_ping_front_local */ 2:
                    message.initialPingFrontLocal = reader.uint32();
                    break;
                case /* optional uint32 initial_ping_front_remote */ 3:
                    message.initialPingFrontRemote = reader.uint32();
                    break;
                case /* optional uint32 initial_score */ 4:
                    message.initialScore = reader.uint32();
                    break;
                case /* optional fixed32 initial_pop_local */ 5:
                    message.initialPopLocal = reader.fixed32();
                    break;
                case /* optional fixed32 initial_pop_remote */ 6:
                    message.initialPopRemote = reader.fixed32();
                    break;
                case /* optional uint32 best_ping */ 11:
                    message.bestPing = reader.uint32();
                    break;
                case /* optional uint32 best_ping_front_local */ 12:
                    message.bestPingFrontLocal = reader.uint32();
                    break;
                case /* optional uint32 best_ping_front_remote */ 13:
                    message.bestPingFrontRemote = reader.uint32();
                    break;
                case /* optional uint32 best_score */ 14:
                    message.bestScore = reader.uint32();
                    break;
                case /* optional fixed32 best_pop_local */ 15:
                    message.bestPopLocal = reader.fixed32();
                    break;
                case /* optional fixed32 best_pop_remote */ 16:
                    message.bestPopRemote = reader.fixed32();
                    break;
                case /* optional uint32 best_time */ 17:
                    message.bestTime = reader.uint32();
                    break;
                case /* optional uint32 negotiation_ms */ 7:
                    message.negotiationMs = reader.uint32();
                    break;
                case /* optional uint32 selected_seconds */ 8:
                    message.selectedSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamNetworkingP2PSDRRoutingSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 initial_ping = 1; */
        if (message.initialPing !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.initialPing);
        /* optional uint32 initial_ping_front_local = 2; */
        if (message.initialPingFrontLocal !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.initialPingFrontLocal);
        /* optional uint32 initial_ping_front_remote = 3; */
        if (message.initialPingFrontRemote !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.initialPingFrontRemote);
        /* optional uint32 initial_score = 4; */
        if (message.initialScore !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.initialScore);
        /* optional fixed32 initial_pop_local = 5; */
        if (message.initialPopLocal !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.initialPopLocal);
        /* optional fixed32 initial_pop_remote = 6; */
        if (message.initialPopRemote !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.initialPopRemote);
        /* optional uint32 best_ping = 11; */
        if (message.bestPing !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.bestPing);
        /* optional uint32 best_ping_front_local = 12; */
        if (message.bestPingFrontLocal !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.bestPingFrontLocal);
        /* optional uint32 best_ping_front_remote = 13; */
        if (message.bestPingFrontRemote !== undefined)
            writer.tag(13, WireType.Varint).uint32(message.bestPingFrontRemote);
        /* optional uint32 best_score = 14; */
        if (message.bestScore !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.bestScore);
        /* optional fixed32 best_pop_local = 15; */
        if (message.bestPopLocal !== undefined)
            writer.tag(15, WireType.Bit32).fixed32(message.bestPopLocal);
        /* optional fixed32 best_pop_remote = 16; */
        if (message.bestPopRemote !== undefined)
            writer.tag(16, WireType.Bit32).fixed32(message.bestPopRemote);
        /* optional uint32 best_time = 17; */
        if (message.bestTime !== undefined)
            writer.tag(17, WireType.Varint).uint32(message.bestTime);
        /* optional uint32 negotiation_ms = 7; */
        if (message.negotiationMs !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.negotiationMs);
        /* optional uint32 selected_seconds = 8; */
        if (message.selectedSeconds !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.selectedSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamNetworkingP2PSDRRoutingSummary
 */
export const CMsgSteamNetworkingP2PSDRRoutingSummary = new CMsgSteamNetworkingP2PSDRRoutingSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PRoutingSummary$Type extends MessageType<CMsgSteamDatagramP2PRoutingSummary> {
    constructor() {
        super("CMsgSteamDatagramP2PRoutingSummary", [
            { no: 2, name: "ice", kind: "message", T: () => CMsgSteamNetworkingICESessionSummary },
            { no: 3, name: "sdr", kind: "message", T: () => CMsgSteamNetworkingP2PSDRRoutingSummary }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PRoutingSummary>): CMsgSteamDatagramP2PRoutingSummary {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PRoutingSummary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PRoutingSummary): CMsgSteamDatagramP2PRoutingSummary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamNetworkingICESessionSummary ice */ 2:
                    message.ice = CMsgSteamNetworkingICESessionSummary.internalBinaryRead(reader, reader.uint32(), options, message.ice);
                    break;
                case /* optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr */ 3:
                    message.sdr = CMsgSteamNetworkingP2PSDRRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.sdr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PRoutingSummary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamNetworkingICESessionSummary ice = 2; */
        if (message.ice)
            CMsgSteamNetworkingICESessionSummary.internalBinaryWrite(message.ice, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3; */
        if (message.sdr)
            CMsgSteamNetworkingP2PSDRRoutingSummary.internalBinaryWrite(message.sdr, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PRoutingSummary
 */
export const CMsgSteamDatagramP2PRoutingSummary = new CMsgSteamDatagramP2PRoutingSummary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionClosed$Type extends MessageType<CMsgSteamDatagramConnectionClosed> {
    constructor() {
        super("CMsgSteamDatagramConnectionClosed", [
            { no: 7, name: "to_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "from_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 15, name: "from_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "legacy_from_identity_binary", kind: "message", T: () => CMsgSteamNetworkingIdentityLegacyBinary },
            { no: 3, name: "legacy_from_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "legacy_gameserver_relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "to_relay_session_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "from_relay_session_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "forward_target_relay_routing_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "forward_target_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "relay_mode", kind: "enum", opt: true, T: () => ["CMsgSteamDatagramConnectionClosed.ERelayMode", CMsgSteamDatagramConnectionClosed_ERelayMode] },
            { no: 5, name: "debug", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "reason_code", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "routing_secret", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "not_primary_session", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "not_primary_transport", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "relay_override_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 18, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 21, name: "p2p_routing_summary", kind: "message", jsonName: "p2pRoutingSummary", T: () => CMsgSteamDatagramP2PRoutingSummary }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionClosed>): CMsgSteamDatagramConnectionClosed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionClosed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionClosed): CMsgSteamDatagramConnectionClosed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 to_connection_id */ 7:
                    message.toConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_connection_id */ 8:
                    message.fromConnectionId = reader.fixed32();
                    break;
                case /* optional string from_identity_string */ 15:
                    message.fromIdentityString = reader.string();
                    break;
                case /* optional CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary */ 13:
                    message.legacyFromIdentityBinary = CMsgSteamNetworkingIdentityLegacyBinary.internalBinaryRead(reader, reader.uint32(), options, message.legacyFromIdentityBinary);
                    break;
                case /* optional fixed64 legacy_from_steam_id */ 3:
                    message.legacyFromSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 legacy_gameserver_relay_session_id */ 2:
                    message.legacyGameserverRelaySessionId = reader.uint32();
                    break;
                case /* optional fixed32 to_relay_session_id */ 9:
                    message.toRelaySessionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_relay_session_id */ 10:
                    message.fromRelaySessionId = reader.fixed32();
                    break;
                case /* optional bytes forward_target_relay_routing_token */ 11:
                    message.forwardTargetRelayRoutingToken = reader.bytes();
                    break;
                case /* optional uint32 forward_target_revision */ 12:
                    message.forwardTargetRevision = reader.uint32();
                    break;
                case /* optional CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode */ 4:
                    message.relayMode = reader.int32();
                    break;
                case /* optional string debug */ 5:
                    message.debug = reader.string();
                    break;
                case /* optional uint32 reason_code */ 6:
                    message.reasonCode = reader.uint32();
                    break;
                case /* optional fixed64 routing_secret */ 14:
                    message.routingSecret = reader.fixed64().toBigInt();
                    break;
                case /* optional bool not_primary_session */ 16:
                    message.notPrimarySession = reader.bool();
                    break;
                case /* optional bool not_primary_transport */ 19:
                    message.notPrimaryTransport = reader.bool();
                    break;
                case /* optional bool relay_override_active */ 22:
                    message.relayOverrideActive = reader.bool();
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 17:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 18 [json_name = "qualityE2e"];*/ 18:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21 [json_name = "p2pRoutingSummary"];*/ 21:
                    message.p2PRoutingSummary = CMsgSteamDatagramP2PRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.p2PRoutingSummary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionClosed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 to_connection_id = 7; */
        if (message.toConnectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.toConnectionId);
        /* optional fixed32 from_connection_id = 8; */
        if (message.fromConnectionId !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.fromConnectionId);
        /* optional string from_identity_string = 15; */
        if (message.fromIdentityString !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.fromIdentityString);
        /* optional CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13; */
        if (message.legacyFromIdentityBinary)
            CMsgSteamNetworkingIdentityLegacyBinary.internalBinaryWrite(message.legacyFromIdentityBinary, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 legacy_from_steam_id = 3; */
        if (message.legacyFromSteamId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyFromSteamId);
        /* optional uint32 legacy_gameserver_relay_session_id = 2; */
        if (message.legacyGameserverRelaySessionId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.legacyGameserverRelaySessionId);
        /* optional fixed32 to_relay_session_id = 9; */
        if (message.toRelaySessionId !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.toRelaySessionId);
        /* optional fixed32 from_relay_session_id = 10; */
        if (message.fromRelaySessionId !== undefined)
            writer.tag(10, WireType.Bit32).fixed32(message.fromRelaySessionId);
        /* optional bytes forward_target_relay_routing_token = 11; */
        if (message.forwardTargetRelayRoutingToken !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.forwardTargetRelayRoutingToken);
        /* optional uint32 forward_target_revision = 12; */
        if (message.forwardTargetRevision !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.forwardTargetRevision);
        /* optional CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4; */
        if (message.relayMode !== undefined)
            writer.tag(4, WireType.Varint).int32(message.relayMode);
        /* optional string debug = 5; */
        if (message.debug !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.debug);
        /* optional uint32 reason_code = 6; */
        if (message.reasonCode !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.reasonCode);
        /* optional fixed64 routing_secret = 14; */
        if (message.routingSecret !== undefined)
            writer.tag(14, WireType.Bit64).fixed64(message.routingSecret);
        /* optional bool not_primary_session = 16; */
        if (message.notPrimarySession !== undefined)
            writer.tag(16, WireType.Varint).bool(message.notPrimarySession);
        /* optional bool not_primary_transport = 19; */
        if (message.notPrimaryTransport !== undefined)
            writer.tag(19, WireType.Varint).bool(message.notPrimaryTransport);
        /* optional bool relay_override_active = 22; */
        if (message.relayOverrideActive !== undefined)
            writer.tag(22, WireType.Varint).bool(message.relayOverrideActive);
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 17; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 18 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21 [json_name = "p2pRoutingSummary"]; */
        if (message.p2PRoutingSummary)
            CMsgSteamDatagramP2PRoutingSummary.internalBinaryWrite(message.p2PRoutingSummary, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionClosed
 */
export const CMsgSteamDatagramConnectionClosed = new CMsgSteamDatagramConnectionClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramNoConnection$Type extends MessageType<CMsgSteamDatagramNoConnection> {
    constructor() {
        super("CMsgSteamDatagramNoConnection", [
            { no: 5, name: "to_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "from_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "legacy_gameserver_relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "to_relay_session_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "from_relay_session_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 7, name: "from_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "legacy_from_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "end_to_end", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "not_primary_session", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "not_primary_transport", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "relay_override_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 14, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 16, name: "p2p_routing_summary", kind: "message", jsonName: "p2pRoutingSummary", T: () => CMsgSteamDatagramP2PRoutingSummary },
            { no: 11, name: "routing_secret", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1023, name: "dummy_pad", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramNoConnection>): CMsgSteamDatagramNoConnection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramNoConnection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramNoConnection): CMsgSteamDatagramNoConnection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 to_connection_id */ 5:
                    message.toConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_connection_id */ 6:
                    message.fromConnectionId = reader.fixed32();
                    break;
                case /* optional uint32 legacy_gameserver_relay_session_id */ 2:
                    message.legacyGameserverRelaySessionId = reader.uint32();
                    break;
                case /* optional fixed32 to_relay_session_id */ 9:
                    message.toRelaySessionId = reader.fixed32();
                    break;
                case /* optional fixed32 from_relay_session_id */ 10:
                    message.fromRelaySessionId = reader.fixed32();
                    break;
                case /* optional string from_identity_string */ 7:
                    message.fromIdentityString = reader.string();
                    break;
                case /* optional fixed64 legacy_from_steam_id */ 3:
                    message.legacyFromSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional bool end_to_end */ 4:
                    message.endToEnd = reader.bool();
                    break;
                case /* optional bool not_primary_session */ 12:
                    message.notPrimarySession = reader.bool();
                    break;
                case /* optional bool not_primary_transport */ 15:
                    message.notPrimaryTransport = reader.bool();
                    break;
                case /* optional bool relay_override_active */ 17:
                    message.relayOverrideActive = reader.bool();
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 13:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 14 [json_name = "qualityE2e"];*/ 14:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16 [json_name = "p2pRoutingSummary"];*/ 16:
                    message.p2PRoutingSummary = CMsgSteamDatagramP2PRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.p2PRoutingSummary);
                    break;
                case /* optional fixed64 routing_secret */ 11:
                    message.routingSecret = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 dummy_pad */ 1023:
                    message.dummyPad = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramNoConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 to_connection_id = 5; */
        if (message.toConnectionId !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.toConnectionId);
        /* optional fixed32 from_connection_id = 6; */
        if (message.fromConnectionId !== undefined)
            writer.tag(6, WireType.Bit32).fixed32(message.fromConnectionId);
        /* optional uint32 legacy_gameserver_relay_session_id = 2; */
        if (message.legacyGameserverRelaySessionId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.legacyGameserverRelaySessionId);
        /* optional fixed32 to_relay_session_id = 9; */
        if (message.toRelaySessionId !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.toRelaySessionId);
        /* optional fixed32 from_relay_session_id = 10; */
        if (message.fromRelaySessionId !== undefined)
            writer.tag(10, WireType.Bit32).fixed32(message.fromRelaySessionId);
        /* optional string from_identity_string = 7; */
        if (message.fromIdentityString !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.fromIdentityString);
        /* optional fixed64 legacy_from_steam_id = 3; */
        if (message.legacyFromSteamId !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyFromSteamId);
        /* optional bool end_to_end = 4; */
        if (message.endToEnd !== undefined)
            writer.tag(4, WireType.Varint).bool(message.endToEnd);
        /* optional bool not_primary_session = 12; */
        if (message.notPrimarySession !== undefined)
            writer.tag(12, WireType.Varint).bool(message.notPrimarySession);
        /* optional bool not_primary_transport = 15; */
        if (message.notPrimaryTransport !== undefined)
            writer.tag(15, WireType.Varint).bool(message.notPrimaryTransport);
        /* optional bool relay_override_active = 17; */
        if (message.relayOverrideActive !== undefined)
            writer.tag(17, WireType.Varint).bool(message.relayOverrideActive);
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 13; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 14 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16 [json_name = "p2pRoutingSummary"]; */
        if (message.p2PRoutingSummary)
            CMsgSteamDatagramP2PRoutingSummary.internalBinaryWrite(message.p2PRoutingSummary, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional fixed64 routing_secret = 11; */
        if (message.routingSecret !== undefined)
            writer.tag(11, WireType.Bit64).fixed64(message.routingSecret);
        /* optional fixed32 dummy_pad = 1023; */
        if (message.dummyPad !== undefined)
            writer.tag(1023, WireType.Bit32).fixed32(message.dummyPad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramNoConnection
 */
export const CMsgSteamDatagramNoConnection = new CMsgSteamDatagramNoConnection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramGameserverSessionRequest$Type extends MessageType<CMsgSteamDatagramGameserverSessionRequest> {
    constructor() {
        super("CMsgSteamDatagramGameserverSessionRequest", [
            { no: 1, name: "ticket", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "challenge_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "server_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "network_config_version", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "platform", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "build", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 100, name: "dev_gameserver_identity", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 101, name: "dev_client_cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramGameserverSessionRequest>): CMsgSteamDatagramGameserverSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramGameserverSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramGameserverSessionRequest): CMsgSteamDatagramGameserverSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes ticket */ 1:
                    message.ticket = reader.bytes();
                    break;
                case /* optional fixed32 challenge_time */ 3:
                    message.challengeTime = reader.fixed32();
                    break;
                case /* optional fixed64 challenge */ 4:
                    message.challenge = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 client_connection_id */ 5:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 server_connection_id */ 8:
                    message.serverConnectionId = reader.fixed32();
                    break;
                case /* optional uint64 network_config_version */ 6:
                    message.networkConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 protocol_version */ 7:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional string platform */ 9:
                    message.platform = reader.string();
                    break;
                case /* optional string build */ 10:
                    message.build = reader.string();
                    break;
                case /* optional string dev_gameserver_identity */ 100:
                    message.devGameserverIdentity = reader.string();
                    break;
                case /* optional CMsgSteamDatagramCertificateSigned dev_client_cert */ 101:
                    message.devClientCert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.devClientCert);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramGameserverSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes ticket = 1; */
        if (message.ticket !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ticket);
        /* optional fixed32 challenge_time = 3; */
        if (message.challengeTime !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.challengeTime);
        /* optional fixed64 challenge = 4; */
        if (message.challenge !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.challenge);
        /* optional fixed32 client_connection_id = 5; */
        if (message.clientConnectionId !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional fixed32 server_connection_id = 8; */
        if (message.serverConnectionId !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.serverConnectionId);
        /* optional uint64 network_config_version = 6; */
        if (message.networkConfigVersion !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.networkConfigVersion);
        /* optional uint32 protocol_version = 7; */
        if (message.protocolVersion !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.protocolVersion);
        /* optional string platform = 9; */
        if (message.platform !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.platform);
        /* optional string build = 10; */
        if (message.build !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.build);
        /* optional string dev_gameserver_identity = 100; */
        if (message.devGameserverIdentity !== undefined)
            writer.tag(100, WireType.LengthDelimited).string(message.devGameserverIdentity);
        /* optional CMsgSteamDatagramCertificateSigned dev_client_cert = 101; */
        if (message.devClientCert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.devClientCert, writer.tag(101, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramGameserverSessionRequest
 */
export const CMsgSteamDatagramGameserverSessionRequest = new CMsgSteamDatagramGameserverSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramGameserverSessionEstablished$Type extends MessageType<CMsgSteamDatagramGameserverSessionEstablished> {
    constructor() {
        super("CMsgSteamDatagramGameserverSessionEstablished", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "gameserver_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "seq_num_r2c", kind: "scalar", jsonName: "seqNumR2c", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "dummy_legacy_identity_binary", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "legacy_gameserver_steamid", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramGameserverSessionEstablished>): CMsgSteamDatagramGameserverSessionEstablished {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramGameserverSessionEstablished>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramGameserverSessionEstablished): CMsgSteamDatagramGameserverSessionEstablished {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional string gameserver_identity_string */ 2:
                    message.gameserverIdentityString = reader.string();
                    break;
                case /* optional uint32 seconds_until_shutdown */ 4:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                case /* optional uint32 seq_num_r2c = 6 [json_name = "seqNumR2c"];*/ 6:
                    message.seqNumR2C = reader.uint32();
                    break;
                case /* optional bytes dummy_legacy_identity_binary */ 7:
                    message.dummyLegacyIdentityBinary = reader.bytes();
                    break;
                case /* optional fixed64 legacy_gameserver_steamid */ 3:
                    message.legacyGameserverSteamid = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramGameserverSessionEstablished, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional string gameserver_identity_string = 2; */
        if (message.gameserverIdentityString !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.gameserverIdentityString);
        /* optional uint32 seconds_until_shutdown = 4; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.secondsUntilShutdown);
        /* optional uint32 seq_num_r2c = 6 [json_name = "seqNumR2c"]; */
        if (message.seqNumR2C !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.seqNumR2C);
        /* optional bytes dummy_legacy_identity_binary = 7; */
        if (message.dummyLegacyIdentityBinary !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.dummyLegacyIdentityBinary);
        /* optional fixed64 legacy_gameserver_steamid = 3; */
        if (message.legacyGameserverSteamid !== undefined)
            writer.tag(3, WireType.Bit64).fixed64(message.legacyGameserverSteamid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramGameserverSessionEstablished
 */
export const CMsgSteamDatagramGameserverSessionEstablished = new CMsgSteamDatagramGameserverSessionEstablished$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsClientToRouter$Type extends MessageType<CMsgSteamDatagramConnectionStatsClientToRouter> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsClientToRouter", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 4, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 6, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "seq_num_c2r", kind: "scalar", jsonName: "seqNumC2r", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsClientToRouter>): CMsgSteamDatagramConnectionStatsClientToRouter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsClientToRouter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsClientToRouter): CMsgSteamDatagramConnectionStatsClientToRouter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* repeated fixed32 ack_relay */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 5 [json_name = "legacyAckE2e"];*/ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 6:
                    message.flags = reader.uint32();
                    break;
                case /* optional fixed32 client_connection_id */ 8:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional uint32 seq_num_c2r = 9 [json_name = "seqNumC2r"];*/ 9:
                    message.seqNumC2R = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 10 [json_name = "seqNumE2e"];*/ 10:
                    message.seqNumE2E = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsClientToRouter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed32 ack_relay = 4; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(4, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 5 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(5, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 6; */
        if (message.flags !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.flags);
        /* optional fixed32 client_connection_id = 8; */
        if (message.clientConnectionId !== undefined)
            writer.tag(8, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional uint32 seq_num_c2r = 9 [json_name = "seqNumC2r"]; */
        if (message.seqNumC2R !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.seqNumC2R);
        /* optional uint32 seq_num_e2e = 10 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.seqNumE2E);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsClientToRouter
 */
export const CMsgSteamDatagramConnectionStatsClientToRouter = new CMsgSteamDatagramConnectionStatsClientToRouter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsRouterToClient$Type extends MessageType<CMsgSteamDatagramConnectionStatsRouterToClient> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsRouterToClient", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 6, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "migrate_request_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "migrate_request_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "scoring_penalty_relay_cluster", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 14, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 15, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "seq_num_r2c", kind: "scalar", jsonName: "seqNumR2c", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsRouterToClient>): CMsgSteamDatagramConnectionStatsRouterToClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsRouterToClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsRouterToClient): CMsgSteamDatagramConnectionStatsRouterToClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* optional uint32 seconds_until_shutdown */ 6:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                case /* optional fixed32 migrate_request_ip */ 10:
                    message.migrateRequestIp = reader.fixed32();
                    break;
                case /* optional uint32 migrate_request_port */ 11:
                    message.migrateRequestPort = reader.uint32();
                    break;
                case /* optional uint32 scoring_penalty_relay_cluster */ 12:
                    message.scoringPenaltyRelayCluster = reader.uint32();
                    break;
                case /* repeated fixed32 ack_relay */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 14 [json_name = "legacyAckE2e"];*/ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 15:
                    message.flags = reader.uint32();
                    break;
                case /* optional fixed32 client_connection_id */ 7:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional uint32 seq_num_r2c = 8 [json_name = "seqNumR2c"];*/ 8:
                    message.seqNumR2C = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 9 [json_name = "seqNumE2e"];*/ 9:
                    message.seqNumE2E = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsRouterToClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 seconds_until_shutdown = 6; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.secondsUntilShutdown);
        /* optional fixed32 migrate_request_ip = 10; */
        if (message.migrateRequestIp !== undefined)
            writer.tag(10, WireType.Bit32).fixed32(message.migrateRequestIp);
        /* optional uint32 migrate_request_port = 11; */
        if (message.migrateRequestPort !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.migrateRequestPort);
        /* optional uint32 scoring_penalty_relay_cluster = 12; */
        if (message.scoringPenaltyRelayCluster !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.scoringPenaltyRelayCluster);
        /* repeated fixed32 ack_relay = 13; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(13, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 14 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(14, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 15; */
        if (message.flags !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.flags);
        /* optional fixed32 client_connection_id = 7; */
        if (message.clientConnectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional uint32 seq_num_r2c = 8 [json_name = "seqNumR2c"]; */
        if (message.seqNumR2C !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.seqNumR2C);
        /* optional uint32 seq_num_e2e = 9 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.seqNumE2E);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsRouterToClient
 */
export const CMsgSteamDatagramConnectionStatsRouterToClient = new CMsgSteamDatagramConnectionStatsRouterToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsRouterToServer$Type extends MessageType<CMsgSteamDatagramConnectionStatsRouterToServer> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsRouterToServer", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 10, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 12, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "seq_num_r2s", kind: "scalar", jsonName: "seqNumR2s", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "client_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "legacy_client_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 13, name: "server_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 14, name: "routing_secret", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsRouterToServer>): CMsgSteamDatagramConnectionStatsRouterToServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsRouterToServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsRouterToServer): CMsgSteamDatagramConnectionStatsRouterToServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* repeated fixed32 ack_relay */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 11 [json_name = "legacyAckE2e"];*/ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 12:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 seq_num_r2s = 5 [json_name = "seqNumR2s"];*/ 5:
                    message.seqNumR2S = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 6 [json_name = "seqNumE2e"];*/ 6:
                    message.seqNumE2E = reader.uint32();
                    break;
                case /* optional string client_identity_string */ 15:
                    message.clientIdentityString = reader.string();
                    break;
                case /* optional fixed64 legacy_client_steam_id */ 7:
                    message.legacyClientSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional uint32 relay_session_id */ 8:
                    message.relaySessionId = reader.uint32();
                    break;
                case /* optional fixed32 client_connection_id */ 9:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 server_connection_id */ 13:
                    message.serverConnectionId = reader.fixed32();
                    break;
                case /* optional fixed64 routing_secret */ 14:
                    message.routingSecret = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsRouterToServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed32 ack_relay = 10; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(10, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 11 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(11, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 12; */
        if (message.flags !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.flags);
        /* optional uint32 seq_num_r2s = 5 [json_name = "seqNumR2s"]; */
        if (message.seqNumR2S !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.seqNumR2S);
        /* optional uint32 seq_num_e2e = 6 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.seqNumE2E);
        /* optional string client_identity_string = 15; */
        if (message.clientIdentityString !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.clientIdentityString);
        /* optional fixed64 legacy_client_steam_id = 7; */
        if (message.legacyClientSteamId !== undefined)
            writer.tag(7, WireType.Bit64).fixed64(message.legacyClientSteamId);
        /* optional uint32 relay_session_id = 8; */
        if (message.relaySessionId !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.relaySessionId);
        /* optional fixed32 client_connection_id = 9; */
        if (message.clientConnectionId !== undefined)
            writer.tag(9, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional fixed32 server_connection_id = 13; */
        if (message.serverConnectionId !== undefined)
            writer.tag(13, WireType.Bit32).fixed32(message.serverConnectionId);
        /* optional fixed64 routing_secret = 14; */
        if (message.routingSecret !== undefined)
            writer.tag(14, WireType.Bit64).fixed64(message.routingSecret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsRouterToServer
 */
export const CMsgSteamDatagramConnectionStatsRouterToServer = new CMsgSteamDatagramConnectionStatsRouterToServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsServerToRouter$Type extends MessageType<CMsgSteamDatagramConnectionStatsServerToRouter> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsServerToRouter", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 8, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 10, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "seq_num_s2r", kind: "scalar", jsonName: "seqNumS2r", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "relay_session_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "server_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsServerToRouter>): CMsgSteamDatagramConnectionStatsServerToRouter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsServerToRouter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsServerToRouter): CMsgSteamDatagramConnectionStatsServerToRouter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* repeated fixed32 ack_relay */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 9 [json_name = "legacyAckE2e"];*/ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 10:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 seq_num_s2r = 3 [json_name = "seqNumS2r"];*/ 3:
                    message.seqNumS2R = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 4 [json_name = "seqNumE2e"];*/ 4:
                    message.seqNumE2E = reader.uint32();
                    break;
                case /* optional uint32 relay_session_id */ 6:
                    message.relaySessionId = reader.uint32();
                    break;
                case /* optional fixed32 client_connection_id */ 7:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional fixed32 server_connection_id */ 11:
                    message.serverConnectionId = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsServerToRouter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed32 ack_relay = 8; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(8, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 9 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(9, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 10; */
        if (message.flags !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.flags);
        /* optional uint32 seq_num_s2r = 3 [json_name = "seqNumS2r"]; */
        if (message.seqNumS2R !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.seqNumS2R);
        /* optional uint32 seq_num_e2e = 4 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.seqNumE2E);
        /* optional uint32 relay_session_id = 6; */
        if (message.relaySessionId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.relaySessionId);
        /* optional fixed32 client_connection_id = 7; */
        if (message.clientConnectionId !== undefined)
            writer.tag(7, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional fixed32 server_connection_id = 11; */
        if (message.serverConnectionId !== undefined)
            writer.tag(11, WireType.Bit32).fixed32(message.serverConnectionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsServerToRouter
 */
export const CMsgSteamDatagramConnectionStatsServerToRouter = new CMsgSteamDatagramConnectionStatsServerToRouter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PSessionRequestBody$Type extends MessageType<CMsgSteamDatagramP2PSessionRequestBody> {
    constructor() {
        super("CMsgSteamDatagramP2PSessionRequestBody", [
            { no: 1, name: "challenge_time", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "challenge", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "legacy_peer_steam_id", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "peer_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "peer_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 14, name: "encrypted_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 15, name: "encryption_your_public_key_lead_byte", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "encryption_my_ephemeral_public_key", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "protocol_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "network_config_version", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "platform", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "build", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PSessionRequestBody>): CMsgSteamDatagramP2PSessionRequestBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PSessionRequestBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PSessionRequestBody): CMsgSteamDatagramP2PSessionRequestBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 challenge_time */ 1:
                    message.challengeTime = reader.fixed32();
                    break;
                case /* optional fixed64 challenge */ 2:
                    message.challenge = reader.fixed64().toBigInt();
                    break;
                case /* optional fixed32 client_connection_id */ 3:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional fixed64 legacy_peer_steam_id */ 4:
                    message.legacyPeerSteamId = reader.fixed64().toBigInt();
                    break;
                case /* optional string peer_identity_string */ 11:
                    message.peerIdentityString = reader.string();
                    break;
                case /* optional fixed32 peer_connection_id */ 5:
                    message.peerConnectionId = reader.fixed32();
                    break;
                case /* optional bytes encrypted_data */ 14:
                    message.encryptedData = reader.bytes();
                    break;
                case /* optional uint32 encryption_your_public_key_lead_byte */ 15:
                    message.encryptionYourPublicKeyLeadByte = reader.uint32();
                    break;
                case /* optional bytes encryption_my_ephemeral_public_key */ 16:
                    message.encryptionMyEphemeralPublicKey = reader.bytes();
                    break;
                case /* optional uint32 protocol_version */ 8:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* optional uint64 network_config_version */ 9:
                    message.networkConfigVersion = reader.uint64().toBigInt();
                    break;
                case /* optional string platform */ 12:
                    message.platform = reader.string();
                    break;
                case /* optional string build */ 13:
                    message.build = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PSessionRequestBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 challenge_time = 1; */
        if (message.challengeTime !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.challengeTime);
        /* optional fixed64 challenge = 2; */
        if (message.challenge !== undefined)
            writer.tag(2, WireType.Bit64).fixed64(message.challenge);
        /* optional fixed32 client_connection_id = 3; */
        if (message.clientConnectionId !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional fixed64 legacy_peer_steam_id = 4; */
        if (message.legacyPeerSteamId !== undefined)
            writer.tag(4, WireType.Bit64).fixed64(message.legacyPeerSteamId);
        /* optional string peer_identity_string = 11; */
        if (message.peerIdentityString !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.peerIdentityString);
        /* optional fixed32 peer_connection_id = 5; */
        if (message.peerConnectionId !== undefined)
            writer.tag(5, WireType.Bit32).fixed32(message.peerConnectionId);
        /* optional bytes encrypted_data = 14; */
        if (message.encryptedData !== undefined)
            writer.tag(14, WireType.LengthDelimited).bytes(message.encryptedData);
        /* optional uint32 encryption_your_public_key_lead_byte = 15; */
        if (message.encryptionYourPublicKeyLeadByte !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.encryptionYourPublicKeyLeadByte);
        /* optional bytes encryption_my_ephemeral_public_key = 16; */
        if (message.encryptionMyEphemeralPublicKey !== undefined)
            writer.tag(16, WireType.LengthDelimited).bytes(message.encryptionMyEphemeralPublicKey);
        /* optional uint32 protocol_version = 8; */
        if (message.protocolVersion !== undefined)
            writer.tag(8, WireType.Varint).uint32(message.protocolVersion);
        /* optional uint64 network_config_version = 9; */
        if (message.networkConfigVersion !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.networkConfigVersion);
        /* optional string platform = 12; */
        if (message.platform !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.platform);
        /* optional string build = 13; */
        if (message.build !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.build);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PSessionRequestBody
 */
export const CMsgSteamDatagramP2PSessionRequestBody = new CMsgSteamDatagramP2PSessionRequestBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PSessionRequestBody_EncryptedData$Type extends MessageType<CMsgSteamDatagramP2PSessionRequestBody_EncryptedData> {
    constructor() {
        super("CMsgSteamDatagramP2PSessionRequestBody.EncryptedData", [
            { no: 1, name: "peer_identity_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PSessionRequestBody_EncryptedData>): CMsgSteamDatagramP2PSessionRequestBody_EncryptedData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PSessionRequestBody_EncryptedData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PSessionRequestBody_EncryptedData): CMsgSteamDatagramP2PSessionRequestBody_EncryptedData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string peer_identity_string */ 1:
                    message.peerIdentityString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PSessionRequestBody_EncryptedData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string peer_identity_string = 1; */
        if (message.peerIdentityString !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.peerIdentityString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PSessionRequestBody.EncryptedData
 */
export const CMsgSteamDatagramP2PSessionRequestBody_EncryptedData = new CMsgSteamDatagramP2PSessionRequestBody_EncryptedData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PSessionRequest$Type extends MessageType<CMsgSteamDatagramP2PSessionRequest> {
    constructor() {
        super("CMsgSteamDatagramP2PSessionRequest", [
            { no: 1, name: "cert", kind: "message", T: () => CMsgSteamDatagramCertificateSigned },
            { no: 2, name: "body", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signature", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PSessionRequest>): CMsgSteamDatagramP2PSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PSessionRequest): CMsgSteamDatagramP2PSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramCertificateSigned cert */ 1:
                    message.cert = CMsgSteamDatagramCertificateSigned.internalBinaryRead(reader, reader.uint32(), options, message.cert);
                    break;
                case /* optional bytes body */ 2:
                    message.body = reader.bytes();
                    break;
                case /* optional bytes signature */ 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramCertificateSigned cert = 1; */
        if (message.cert)
            CMsgSteamDatagramCertificateSigned.internalBinaryWrite(message.cert, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes body = 2; */
        if (message.body !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.body);
        /* optional bytes signature = 3; */
        if (message.signature !== undefined)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PSessionRequest
 */
export const CMsgSteamDatagramP2PSessionRequest = new CMsgSteamDatagramP2PSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PSessionEstablished$Type extends MessageType<CMsgSteamDatagramP2PSessionEstablished> {
    constructor() {
        super("CMsgSteamDatagramP2PSessionEstablished", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "relay_routing_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "seq_num_r2c", kind: "scalar", jsonName: "seqNumR2c", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PSessionEstablished>): CMsgSteamDatagramP2PSessionEstablished {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PSessionEstablished>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PSessionEstablished): CMsgSteamDatagramP2PSessionEstablished {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional uint32 seconds_until_shutdown */ 3:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                case /* optional bytes relay_routing_token */ 4:
                    message.relayRoutingToken = reader.bytes();
                    break;
                case /* optional uint32 seq_num_r2c = 5 [json_name = "seqNumR2c"];*/ 5:
                    message.seqNumR2C = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PSessionEstablished, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional uint32 seconds_until_shutdown = 3; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.secondsUntilShutdown);
        /* optional bytes relay_routing_token = 4; */
        if (message.relayRoutingToken !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.relayRoutingToken);
        /* optional uint32 seq_num_r2c = 5 [json_name = "seqNumR2c"]; */
        if (message.seqNumR2C !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.seqNumR2C);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PSessionEstablished
 */
export const CMsgSteamDatagramP2PSessionEstablished = new CMsgSteamDatagramP2PSessionEstablished$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsP2PClientToRouter$Type extends MessageType<CMsgSteamDatagramConnectionStatsP2PClientToRouter> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsP2PClientToRouter", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 14, name: "p2p_routing_summary", kind: "message", jsonName: "p2pRoutingSummary", T: () => CMsgSteamDatagramP2PRoutingSummary },
            { no: 3, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "forward_target_relay_routing_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "forward_target_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "routes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "ack_peer_routes_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 11, name: "seq_num_c2r", kind: "scalar", jsonName: "seqNumC2r", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsP2PClientToRouter>): CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsP2PClientToRouter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsP2PClientToRouter): CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14 [json_name = "p2pRoutingSummary"];*/ 14:
                    message.p2PRoutingSummary = CMsgSteamDatagramP2PRoutingSummary.internalBinaryRead(reader, reader.uint32(), options, message.p2PRoutingSummary);
                    break;
                case /* repeated fixed32 ack_relay */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 4 [json_name = "legacyAckE2e"];*/ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 5:
                    message.flags = reader.uint32();
                    break;
                case /* optional bytes forward_target_relay_routing_token */ 6:
                    message.forwardTargetRelayRoutingToken = reader.bytes();
                    break;
                case /* optional uint32 forward_target_revision */ 7:
                    message.forwardTargetRevision = reader.uint32();
                    break;
                case /* optional bytes routes */ 8:
                    message.routes = reader.bytes();
                    break;
                case /* optional uint32 ack_peer_routes_revision */ 9:
                    message.ackPeerRoutesRevision = reader.uint32();
                    break;
                case /* optional fixed32 connection_id */ 10:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional uint32 seq_num_c2r = 11 [json_name = "seqNumC2r"];*/ 11:
                    message.seqNumC2R = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 12 [json_name = "seqNumE2e"];*/ 12:
                    message.seqNumE2E = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsP2PClientToRouter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14 [json_name = "p2pRoutingSummary"]; */
        if (message.p2PRoutingSummary)
            CMsgSteamDatagramP2PRoutingSummary.internalBinaryWrite(message.p2PRoutingSummary, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated fixed32 ack_relay = 3; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(3, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 4 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(4, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 5; */
        if (message.flags !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.flags);
        /* optional bytes forward_target_relay_routing_token = 6; */
        if (message.forwardTargetRelayRoutingToken !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.forwardTargetRelayRoutingToken);
        /* optional uint32 forward_target_revision = 7; */
        if (message.forwardTargetRevision !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.forwardTargetRevision);
        /* optional bytes routes = 8; */
        if (message.routes !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.routes);
        /* optional uint32 ack_peer_routes_revision = 9; */
        if (message.ackPeerRoutesRevision !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.ackPeerRoutesRevision);
        /* optional fixed32 connection_id = 10; */
        if (message.connectionId !== undefined)
            writer.tag(10, WireType.Bit32).fixed32(message.connectionId);
        /* optional uint32 seq_num_c2r = 11 [json_name = "seqNumC2r"]; */
        if (message.seqNumC2R !== undefined)
            writer.tag(11, WireType.Varint).uint32(message.seqNumC2R);
        /* optional uint32 seq_num_e2e = 12 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.seqNumE2E);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsP2PClientToRouter
 */
export const CMsgSteamDatagramConnectionStatsP2PClientToRouter = new CMsgSteamDatagramConnectionStatsP2PClientToRouter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramConnectionStatsP2PRouterToClient$Type extends MessageType<CMsgSteamDatagramConnectionStatsP2PRouterToClient> {
    constructor() {
        super("CMsgSteamDatagramConnectionStatsP2PRouterToClient", [
            { no: 1, name: "quality_relay", kind: "message", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 2, name: "quality_e2e", kind: "message", jsonName: "qualityE2e", T: () => CMsgSteamDatagramConnectionQuality },
            { no: 3, name: "seconds_until_shutdown", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "migrate_request_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "migrate_request_port", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "scoring_penalty_relay_cluster", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "ack_relay", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 8, name: "legacy_ack_e2e", kind: "scalar", jsonName: "legacyAckE2e", repeat: 2 /*RepeatType.UNPACKED*/, T: 7 /*ScalarType.FIXED32*/ },
            { no: 9, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "ack_forward_target_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "routes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "ack_peer_routes_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 14, name: "seq_num_r2c", kind: "scalar", jsonName: "seqNumR2c", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "seq_num_e2e", kind: "scalar", jsonName: "seqNumE2e", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramConnectionStatsP2PRouterToClient>): CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ackRelay = [];
        message.legacyAckE2E = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramConnectionStatsP2PRouterToClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramConnectionStatsP2PRouterToClient): CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional CMsgSteamDatagramConnectionQuality quality_relay */ 1:
                    message.qualityRelay = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityRelay);
                    break;
                case /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"];*/ 2:
                    message.qualityE2E = CMsgSteamDatagramConnectionQuality.internalBinaryRead(reader, reader.uint32(), options, message.qualityE2E);
                    break;
                case /* optional uint32 seconds_until_shutdown */ 3:
                    message.secondsUntilShutdown = reader.uint32();
                    break;
                case /* optional fixed32 migrate_request_ip */ 4:
                    message.migrateRequestIp = reader.fixed32();
                    break;
                case /* optional uint32 migrate_request_port */ 5:
                    message.migrateRequestPort = reader.uint32();
                    break;
                case /* optional uint32 scoring_penalty_relay_cluster */ 6:
                    message.scoringPenaltyRelayCluster = reader.uint32();
                    break;
                case /* repeated fixed32 ack_relay */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ackRelay.push(reader.fixed32());
                    else
                        message.ackRelay.push(reader.fixed32());
                    break;
                case /* repeated fixed32 legacy_ack_e2e = 8 [json_name = "legacyAckE2e"];*/ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyAckE2E.push(reader.fixed32());
                    else
                        message.legacyAckE2E.push(reader.fixed32());
                    break;
                case /* optional uint32 flags */ 9:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 ack_forward_target_revision */ 10:
                    message.ackForwardTargetRevision = reader.uint32();
                    break;
                case /* optional bytes routes */ 11:
                    message.routes = reader.bytes();
                    break;
                case /* optional uint32 ack_peer_routes_revision */ 12:
                    message.ackPeerRoutesRevision = reader.uint32();
                    break;
                case /* optional fixed32 connection_id */ 13:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional uint32 seq_num_r2c = 14 [json_name = "seqNumR2c"];*/ 14:
                    message.seqNumR2C = reader.uint32();
                    break;
                case /* optional uint32 seq_num_e2e = 15 [json_name = "seqNumE2e"];*/ 15:
                    message.seqNumE2E = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramConnectionStatsP2PRouterToClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional CMsgSteamDatagramConnectionQuality quality_relay = 1; */
        if (message.qualityRelay)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityRelay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional CMsgSteamDatagramConnectionQuality quality_e2e = 2 [json_name = "qualityE2e"]; */
        if (message.qualityE2E)
            CMsgSteamDatagramConnectionQuality.internalBinaryWrite(message.qualityE2E, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 seconds_until_shutdown = 3; */
        if (message.secondsUntilShutdown !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.secondsUntilShutdown);
        /* optional fixed32 migrate_request_ip = 4; */
        if (message.migrateRequestIp !== undefined)
            writer.tag(4, WireType.Bit32).fixed32(message.migrateRequestIp);
        /* optional uint32 migrate_request_port = 5; */
        if (message.migrateRequestPort !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.migrateRequestPort);
        /* optional uint32 scoring_penalty_relay_cluster = 6; */
        if (message.scoringPenaltyRelayCluster !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.scoringPenaltyRelayCluster);
        /* repeated fixed32 ack_relay = 7; */
        for (let i = 0; i < message.ackRelay.length; i++)
            writer.tag(7, WireType.Bit32).fixed32(message.ackRelay[i]);
        /* repeated fixed32 legacy_ack_e2e = 8 [json_name = "legacyAckE2e"]; */
        for (let i = 0; i < message.legacyAckE2E.length; i++)
            writer.tag(8, WireType.Bit32).fixed32(message.legacyAckE2E[i]);
        /* optional uint32 flags = 9; */
        if (message.flags !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.flags);
        /* optional uint32 ack_forward_target_revision = 10; */
        if (message.ackForwardTargetRevision !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.ackForwardTargetRevision);
        /* optional bytes routes = 11; */
        if (message.routes !== undefined)
            writer.tag(11, WireType.LengthDelimited).bytes(message.routes);
        /* optional uint32 ack_peer_routes_revision = 12; */
        if (message.ackPeerRoutesRevision !== undefined)
            writer.tag(12, WireType.Varint).uint32(message.ackPeerRoutesRevision);
        /* optional fixed32 connection_id = 13; */
        if (message.connectionId !== undefined)
            writer.tag(13, WireType.Bit32).fixed32(message.connectionId);
        /* optional uint32 seq_num_r2c = 14 [json_name = "seqNumR2c"]; */
        if (message.seqNumR2C !== undefined)
            writer.tag(14, WireType.Varint).uint32(message.seqNumR2C);
        /* optional uint32 seq_num_e2e = 15 [json_name = "seqNumE2e"]; */
        if (message.seqNumE2E !== undefined)
            writer.tag(15, WireType.Varint).uint32(message.seqNumE2E);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramConnectionStatsP2PRouterToClient
 */
export const CMsgSteamDatagramConnectionStatsP2PRouterToClient = new CMsgSteamDatagramConnectionStatsP2PRouterToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PBadRouteRouterToClient$Type extends MessageType<CMsgSteamDatagramP2PBadRouteRouterToClient> {
    constructor() {
        super("CMsgSteamDatagramP2PBadRouteRouterToClient", [
            { no: 1, name: "connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "failed_relay_routing_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "ack_forward_target_revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 99, name: "kludge_pad", kind: "scalar", opt: true, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PBadRouteRouterToClient>): CMsgSteamDatagramP2PBadRouteRouterToClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PBadRouteRouterToClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PBadRouteRouterToClient): CMsgSteamDatagramP2PBadRouteRouterToClient {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 connection_id */ 1:
                    message.connectionId = reader.fixed32();
                    break;
                case /* optional bytes failed_relay_routing_token */ 2:
                    message.failedRelayRoutingToken = reader.bytes();
                    break;
                case /* optional uint32 ack_forward_target_revision */ 3:
                    message.ackForwardTargetRevision = reader.uint32();
                    break;
                case /* optional fixed64 kludge_pad */ 99:
                    message.kludgePad = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PBadRouteRouterToClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 connection_id = 1; */
        if (message.connectionId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.connectionId);
        /* optional bytes failed_relay_routing_token = 2; */
        if (message.failedRelayRoutingToken !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.failedRelayRoutingToken);
        /* optional uint32 ack_forward_target_revision = 3; */
        if (message.ackForwardTargetRevision !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.ackForwardTargetRevision);
        /* optional fixed64 kludge_pad = 99; */
        if (message.kludgePad !== undefined)
            writer.tag(99, WireType.Bit64).fixed64(message.kludgePad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PBadRouteRouterToClient
 */
export const CMsgSteamDatagramP2PBadRouteRouterToClient = new CMsgSteamDatagramP2PBadRouteRouterToClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PRoutes$Type extends MessageType<CMsgSteamDatagramP2PRoutes> {
    constructor() {
        super("CMsgSteamDatagramP2PRoutes", [
            { no: 1, name: "relay_clusters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramP2PRoutes_RelayCluster },
            { no: 2, name: "routes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CMsgSteamDatagramP2PRoutes_Route },
            { no: 3, name: "revision", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PRoutes>): CMsgSteamDatagramP2PRoutes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.relayClusters = [];
        message.routes = [];
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PRoutes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PRoutes): CMsgSteamDatagramP2PRoutes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters */ 1:
                    message.relayClusters.push(CMsgSteamDatagramP2PRoutes_RelayCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CMsgSteamDatagramP2PRoutes.Route routes */ 2:
                    message.routes.push(CMsgSteamDatagramP2PRoutes_Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 revision */ 3:
                    message.revision = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PRoutes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1; */
        for (let i = 0; i < message.relayClusters.length; i++)
            CMsgSteamDatagramP2PRoutes_RelayCluster.internalBinaryWrite(message.relayClusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CMsgSteamDatagramP2PRoutes.Route routes = 2; */
        for (let i = 0; i < message.routes.length; i++)
            CMsgSteamDatagramP2PRoutes_Route.internalBinaryWrite(message.routes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 revision = 3; */
        if (message.revision !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.revision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PRoutes
 */
export const CMsgSteamDatagramP2PRoutes = new CMsgSteamDatagramP2PRoutes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PRoutes_RelayCluster$Type extends MessageType<CMsgSteamDatagramP2PRoutes_RelayCluster> {
    constructor() {
        super("CMsgSteamDatagramP2PRoutes.RelayCluster", [
            { no: 1, name: "pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "ping_ms", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "score_penalty", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "session_relay_routing_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PRoutes_RelayCluster>): CMsgSteamDatagramP2PRoutes_RelayCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PRoutes_RelayCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PRoutes_RelayCluster): CMsgSteamDatagramP2PRoutes_RelayCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 pop_id */ 1:
                    message.popId = reader.fixed32();
                    break;
                case /* optional uint32 ping_ms */ 2:
                    message.pingMs = reader.uint32();
                    break;
                case /* optional uint32 score_penalty */ 3:
                    message.scorePenalty = reader.uint32();
                    break;
                case /* optional bytes session_relay_routing_token */ 4:
                    message.sessionRelayRoutingToken = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PRoutes_RelayCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 pop_id = 1; */
        if (message.popId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.popId);
        /* optional uint32 ping_ms = 2; */
        if (message.pingMs !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.pingMs);
        /* optional uint32 score_penalty = 3; */
        if (message.scorePenalty !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.scorePenalty);
        /* optional bytes session_relay_routing_token = 4; */
        if (message.sessionRelayRoutingToken !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.sessionRelayRoutingToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PRoutes.RelayCluster
 */
export const CMsgSteamDatagramP2PRoutes_RelayCluster = new CMsgSteamDatagramP2PRoutes_RelayCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramP2PRoutes_Route$Type extends MessageType<CMsgSteamDatagramP2PRoutes_Route> {
    constructor() {
        super("CMsgSteamDatagramP2PRoutes.Route", [
            { no: 1, name: "my_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "your_pop_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "legacy_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "interior_score", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramP2PRoutes_Route>): CMsgSteamDatagramP2PRoutes_Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramP2PRoutes_Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramP2PRoutes_Route): CMsgSteamDatagramP2PRoutes_Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 my_pop_id */ 1:
                    message.myPopId = reader.fixed32();
                    break;
                case /* optional fixed32 your_pop_id */ 2:
                    message.yourPopId = reader.fixed32();
                    break;
                case /* optional uint32 legacy_score */ 3:
                    message.legacyScore = reader.uint32();
                    break;
                case /* optional uint32 interior_score */ 4:
                    message.interiorScore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramP2PRoutes_Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 my_pop_id = 1; */
        if (message.myPopId !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.myPopId);
        /* optional fixed32 your_pop_id = 2; */
        if (message.yourPopId !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.yourPopId);
        /* optional uint32 legacy_score = 3; */
        if (message.legacyScore !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.legacyScore);
        /* optional uint32 interior_score = 4; */
        if (message.interiorScore !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.interiorScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramP2PRoutes.Route
 */
export const CMsgSteamDatagramP2PRoutes_Route = new CMsgSteamDatagramP2PRoutes_Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSetSecondaryAddressRequest$Type extends MessageType<CMsgSteamDatagramSetSecondaryAddressRequest> {
    constructor() {
        super("CMsgSteamDatagramSetSecondaryAddressRequest", [
            { no: 1, name: "client_main_ip", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "client_main_port", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "client_connection_id", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 4, name: "client_identity", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "request_send_duplication", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 99, name: "kludge_pad", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramSetSecondaryAddressRequest>): CMsgSteamDatagramSetSecondaryAddressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramSetSecondaryAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramSetSecondaryAddressRequest): CMsgSteamDatagramSetSecondaryAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 client_main_ip */ 1:
                    message.clientMainIp = reader.fixed32();
                    break;
                case /* optional fixed32 client_main_port */ 2:
                    message.clientMainPort = reader.fixed32();
                    break;
                case /* optional fixed32 client_connection_id */ 3:
                    message.clientConnectionId = reader.fixed32();
                    break;
                case /* optional string client_identity */ 4:
                    message.clientIdentity = reader.string();
                    break;
                case /* optional bool request_send_duplication */ 5:
                    message.requestSendDuplication = reader.bool();
                    break;
                case /* optional bytes kludge_pad */ 99:
                    message.kludgePad = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramSetSecondaryAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional fixed32 client_main_ip = 1; */
        if (message.clientMainIp !== undefined)
            writer.tag(1, WireType.Bit32).fixed32(message.clientMainIp);
        /* optional fixed32 client_main_port = 2; */
        if (message.clientMainPort !== undefined)
            writer.tag(2, WireType.Bit32).fixed32(message.clientMainPort);
        /* optional fixed32 client_connection_id = 3; */
        if (message.clientConnectionId !== undefined)
            writer.tag(3, WireType.Bit32).fixed32(message.clientConnectionId);
        /* optional string client_identity = 4; */
        if (message.clientIdentity !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.clientIdentity);
        /* optional bool request_send_duplication = 5; */
        if (message.requestSendDuplication !== undefined)
            writer.tag(5, WireType.Varint).bool(message.requestSendDuplication);
        /* optional bytes kludge_pad = 99; */
        if (message.kludgePad !== undefined)
            writer.tag(99, WireType.LengthDelimited).bytes(message.kludgePad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSetSecondaryAddressRequest
 */
export const CMsgSteamDatagramSetSecondaryAddressRequest = new CMsgSteamDatagramSetSecondaryAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgSteamDatagramSetSecondaryAddressResult$Type extends MessageType<CMsgSteamDatagramSetSecondaryAddressResult> {
    constructor() {
        super("CMsgSteamDatagramSetSecondaryAddressResult", [
            { no: 1, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CMsgSteamDatagramSetSecondaryAddressResult>): CMsgSteamDatagramSetSecondaryAddressResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CMsgSteamDatagramSetSecondaryAddressResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CMsgSteamDatagramSetSecondaryAddressResult): CMsgSteamDatagramSetSecondaryAddressResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* optional string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CMsgSteamDatagramSetSecondaryAddressResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool success = 1; */
        if (message.success !== undefined)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* optional string message = 2; */
        if (message.message !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CMsgSteamDatagramSetSecondaryAddressResult
 */
export const CMsgSteamDatagramSetSecondaryAddressResult = new CMsgSteamDatagramSetSecondaryAddressResult$Type();

// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "citadel_gameevents.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CMsgQAngle } from "./networkbasetypes";
import { CMsgVector } from "./networkbasetypes";
/**
 * @generated from protobuf message CMsgFireBullets
 */
export interface CMsgFireBullets {
  /**
   * @generated from protobuf field: optional CMsgVector origin = 1;
   */
  origin?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgQAngle angles = 2;
   */
  angles?: CMsgQAngle;
  /**
   * @generated from protobuf field: optional uint32 seed = 4;
   */
  seed?: number;
  /**
   * @generated from protobuf field: optional int32 shooter_entity = 5;
   */
  shooterEntity?: number;
  /**
   * @generated from protobuf field: optional int32 ability = 7;
   */
  ability?: number;
  /**
   * @generated from protobuf field: optional float penetration_percent = 8;
   */
  penetrationPercent?: number;
  /**
   * @generated from protobuf field: optional float spread = 9;
   */
  spread?: number;
  /**
   * @generated from protobuf field: optional bool fired_from_gun = 10;
   */
  firedFromGun?: boolean;
  /**
   * @generated from protobuf field: optional uint32 bullets_override = 11;
   */
  bulletsOverride?: number;
  /**
   * @generated from protobuf field: optional CMsgFireBullets.TracerAssignment tracer_replacement = 12;
   */
  tracerReplacement?: CMsgFireBullets_TracerAssignment;
  /**
   * @generated from protobuf field: repeated CMsgFireBullets.TracerAssignment tracer_additional = 13;
   */
  tracerAdditional: CMsgFireBullets_TracerAssignment[];
  /**
   * @generated from protobuf field: optional CMsgQAngle angles_original = 14;
   */
  anglesOriginal?: CMsgQAngle;
  /**
   * @generated from protobuf field: optional uint32 weapon_subclass_id = 15;
   */
  weaponSubclassId?: number;
  /**
   * @generated from protobuf field: optional uint32 shot_number = 16;
   */
  shotNumber?: number;
  /**
   * @generated from protobuf field: optional int32 ignore_entity = 17;
   */
  ignoreEntity?: number;
  /**
   * @generated from protobuf field: optional float max_range = 18;
   */
  maxRange?: number;
}
/**
 * @generated from protobuf message CMsgFireBullets.TracerAssignment
 */
export interface CMsgFireBullets_TracerAssignment {
  /**
   * @generated from protobuf field: optional uint64 tracer_resource_id = 1;
   */
  tracerResourceId?: bigint;
  /**
   * @generated from protobuf field: optional uint32 bullet_indicies = 2;
   */
  bulletIndicies?: number;
}
/**
 * @generated from protobuf message CMsgBulletImpact
 */
export interface CMsgBulletImpact {
  /**
   * @generated from protobuf field: optional CMsgVector trace_start = 1;
   */
  traceStart?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector impact_origin = 2;
   */
  impactOrigin?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector surface_normal = 3;
   */
  surfaceNormal?: CMsgVector;
  /**
   * @generated from protobuf field: optional uint32 damage = 4;
   */
  damage?: number;
  /**
   * @generated from protobuf field: optional uint32 surface_type = 5;
   */
  surfaceType?: number;
  /**
   * @generated from protobuf field: optional int32 ability_entindex = 7;
   */
  abilityEntindex?: number;
  /**
   * @generated from protobuf field: optional int32 impacted_entindex = 8;
   */
  impactedEntindex?: number;
  /**
   * @generated from protobuf field: optional uint32 impacted_hitbox = 9;
   */
  impactedHitbox?: number;
  /**
   * @generated from protobuf field: optional uint32 weapon_subclass_id = 10;
   */
  weaponSubclassId?: number;
  /**
   * @generated from protobuf field: optional int32 shooter_entindex = 11;
   */
  shooterEntindex?: number;
}
/**
 * @generated from protobuf message CMsgPlayerAnimEvent
 */
export interface CMsgPlayerAnimEvent {
  /**
   * @generated from protobuf field: optional fixed32 player = 1;
   */
  player?: number;
  /**
   * @generated from protobuf field: optional uint32 event = 2;
   */
  event?: number;
  /**
   * @generated from protobuf field: optional int32 data = 3;
   */
  data?: number;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager
 */
export interface CMsgParticleSystemManager {
  /**
   * @generated from protobuf field: PARTICLE_SYSTEM_MANAGER_MESSAGE type = 1;
   */
  type: PARTICLE_SYSTEM_MANAGER_MESSAGE;
  /**
   * @generated from protobuf field: uint32 index = 2;
   */
  index: number;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.CreateParticle create_particle = 3;
   */
  createParticle?: CMsgParticleSystemManager_CreateParticle;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.DestroyParticle destroy_particle = 4;
   */
  destroyParticle?: CMsgParticleSystemManager_DestroyParticle;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving = 5;
   */
  destroyParticleInvolving?: CMsgParticleSystemManager_DestroyParticleInvolving;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index = 6;
   */
  releaseParticleIndex?: CMsgParticleSystemManager_ReleaseParticleIndex;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticle update_particle = 7;
   */
  updateParticle?: CMsgParticleSystemManager_UpdateParticle;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd = 8;
   */
  updateParticleFwd?: CMsgParticleSystemManager_UpdateParticleFwd;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient = 9;
   */
  updateParticleOrient?: CMsgParticleSystemManager_UpdateParticleOrient;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback = 10;
   */
  updateParticleFallback?: CMsgParticleSystemManager_UpdateParticleFallback;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset = 11;
   */
  updateParticleOffset?: CMsgParticleSystemManager_UpdateParticleOffset;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent = 12;
   */
  updateParticleEnt?: CMsgParticleSystemManager_UpdateParticleEnt;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen = 13;
   */
  updateParticleFrozen?: CMsgParticleSystemManager_UpdateParticleFrozen;
  /**
   * @generated from protobuf field: optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw = 14;
   */
  updateParticleShouldDraw?: CMsgParticleSystemManager_UpdateParticleShouldDraw;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.CreateParticle
 */
export interface CMsgParticleSystemManager_CreateParticle {
  /**
   * @generated from protobuf field: optional fixed64 particle_name_index = 1;
   */
  particleNameIndex?: bigint;
  /**
   * @generated from protobuf field: optional int32 attach_type = 2;
   */
  attachType?: number;
  /**
   * @generated from protobuf field: optional uint32 entity_handle = 3;
   */
  entityHandle?: number;
  /**
   * @generated from protobuf field: optional CMsgVector position = 4;
   */
  position?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgQAngle angles = 5;
   */
  angles?: CMsgQAngle;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.DestroyParticle
 */
export interface CMsgParticleSystemManager_DestroyParticle {
  /**
   * @generated from protobuf field: optional bool destroy_immediately = 1;
   */
  destroyImmediately?: boolean;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.DestroyParticleInvolving
 */
export interface CMsgParticleSystemManager_DestroyParticleInvolving {
  /**
   * @generated from protobuf field: optional bool destroy_immediately = 1;
   */
  destroyImmediately?: boolean;
  /**
   * @generated from protobuf field: optional uint32 entity_handle = 3;
   */
  entityHandle?: number;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.ReleaseParticleIndex
 */
export interface CMsgParticleSystemManager_ReleaseParticleIndex {}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticle
 */
export interface CMsgParticleSystemManager_UpdateParticle {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional CMsgVector position = 2;
   */
  position?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFwd
 */
export interface CMsgParticleSystemManager_UpdateParticleFwd {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional CMsgVector forward = 2;
   */
  forward?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleOrient
 */
export interface CMsgParticleSystemManager_UpdateParticleOrient {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional CMsgVector forward = 2;
   */
  forward?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector left = 3;
   */
  left?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector up = 4;
   */
  up?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFallback
 */
export interface CMsgParticleSystemManager_UpdateParticleFallback {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional CMsgVector position = 2;
   */
  position?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleEnt
 */
export interface CMsgParticleSystemManager_UpdateParticleEnt {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional uint32 entity_handle = 2;
   */
  entityHandle?: number;
  /**
   * @generated from protobuf field: optional int32 attach_type = 3;
   */
  attachType?: number;
  /**
   * @generated from protobuf field: optional int32 attachment = 4;
   */
  attachment?: number;
  /**
   * @generated from protobuf field: optional CMsgVector fallback_position = 5;
   */
  fallbackPosition?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleOffset
 */
export interface CMsgParticleSystemManager_UpdateParticleOffset {
  /**
   * @generated from protobuf field: optional int32 control_point = 1;
   */
  controlPoint?: number;
  /**
   * @generated from protobuf field: optional CMsgVector origin_offset = 2;
   */
  originOffset?: CMsgVector;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleFrozen
 */
export interface CMsgParticleSystemManager_UpdateParticleFrozen {
  /**
   * @generated from protobuf field: optional bool set_frozen = 1;
   */
  setFrozen?: boolean;
}
/**
 * @generated from protobuf message CMsgParticleSystemManager.UpdateParticleShouldDraw
 */
export interface CMsgParticleSystemManager_UpdateParticleShouldDraw {
  /**
   * @generated from protobuf field: optional bool should_draw = 1;
   */
  shouldDraw?: boolean;
}
/**
 * @generated from protobuf message CMsgScreenTextPretty
 */
export interface CMsgScreenTextPretty {
  /**
   * @generated from protobuf field: optional float x_pos = 1;
   */
  xPos?: number;
  /**
   * @generated from protobuf field: optional float y_pos = 2;
   */
  yPos?: number;
  /**
   * @generated from protobuf field: optional int32 line = 3;
   */
  line?: number;
  /**
   * @generated from protobuf field: optional string text = 4;
   */
  text?: string;
  /**
   * @generated from protobuf field: optional int32 r = 5;
   */
  r?: number;
  /**
   * @generated from protobuf field: optional int32 g = 6;
   */
  g?: number;
  /**
   * @generated from protobuf field: optional int32 b = 7;
   */
  b?: number;
  /**
   * @generated from protobuf field: optional int32 a = 8;
   */
  a?: number;
  /**
   * @generated from protobuf field: optional float duration = 9;
   */
  duration?: number;
  /**
   * @generated from protobuf field: optional string font_name = 10;
   */
  fontName?: string;
  /**
   * @generated from protobuf field: optional int32 font_size = 11;
   */
  fontSize?: number;
  /**
   * @generated from protobuf field: optional bool bold_font = 12;
   */
  boldFont?: boolean;
}
/**
 * @generated from protobuf message CMsgServerRequestedTracer
 */
export interface CMsgServerRequestedTracer {
  /**
   * @generated from protobuf field: optional CMsgVector origin = 1;
   */
  origin?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector end = 2;
   */
  end?: CMsgVector;
  /**
   * @generated from protobuf field: optional int32 weaponid = 3;
   */
  weaponid?: number;
  /**
   * @generated from protobuf field: optional uint32 entity_handle = 4;
   */
  entityHandle?: number;
  /**
   * @generated from protobuf field: optional float dps = 5;
   */
  dps?: number;
}
/**
 * @generated from protobuf message CMsgEnableSatVolumesEvent
 */
export interface CMsgEnableSatVolumesEvent {
  /**
   * @generated from protobuf field: optional uint32 mode = 1;
   */
  mode?: number;
  /**
   * @generated from protobuf field: optional float desat_amount = 2;
   */
  desatAmount?: number;
  /**
   * @generated from protobuf field: optional fixed32 sat_tint = 3;
   */
  satTint?: number;
  /**
   * @generated from protobuf field: optional fixed32 desat_tint = 4;
   */
  desatTint?: number;
  /**
   * @generated from protobuf field: optional fixed32 outline_color = 5;
   */
  outlineColor?: number;
}
/**
 * @generated from protobuf message CMsgPlaceSatVolumeEvent
 */
export interface CMsgPlaceSatVolumeEvent {
  /**
   * @generated from protobuf field: optional CMsgVector position = 1;
   */
  position?: CMsgVector;
  /**
   * @generated from protobuf field: optional CMsgVector direction = 2;
   */
  direction?: CMsgVector;
  /**
   * @generated from protobuf field: optional float radius = 3;
   */
  radius?: number;
  /**
   * @generated from protobuf field: optional float falloff_distance = 4;
   */
  falloffDistance?: number;
  /**
   * @generated from protobuf field: optional float theta_dot = 5;
   */
  thetaDot?: number;
  /**
   * @generated from protobuf field: optional float phi_dot = 6;
   */
  phiDot?: number;
  /**
   * @generated from protobuf field: optional uint32 entity_handle = 7;
   */
  entityHandle?: number;
  /**
   * @generated from protobuf field: optional uint32 attachment_handle = 8;
   */
  attachmentHandle?: number;
  /**
   * @generated from protobuf field: optional uint32 type = 9;
   */
  type?: number;
  /**
   * @generated from protobuf field: optional int32 volume_id = 10;
   */
  volumeId?: number;
}
/**
 * @generated from protobuf message CMsgRemoveSatVolumeEvent
 */
export interface CMsgRemoveSatVolumeEvent {
  /**
   * @generated from protobuf field: optional int32 volume_id = 1;
   */
  volumeId?: number;
}
/**
 * @generated from protobuf message CMsgDisableSatVolumesEvent
 */
export interface CMsgDisableSatVolumesEvent {}
/**
 * @generated from protobuf enum ECitadelGameEvents
 */
export enum ECitadelGameEvents {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: GE_FireBullets = 450;
   */
  GE_FireBullets = 450,
  /**
   * @generated from protobuf enum value: GE_PlayerAnimEvent = 451;
   */
  GE_PlayerAnimEvent = 451,
  /**
   * @generated from protobuf enum value: GE_ParticleSystemManager = 458;
   */
  GE_ParticleSystemManager = 458,
  /**
   * @generated from protobuf enum value: GE_ScreenTextPretty = 459;
   */
  GE_ScreenTextPretty = 459,
  /**
   * @generated from protobuf enum value: GE_ServerRequestedTracer = 460;
   */
  GE_ServerRequestedTracer = 460,
  /**
   * @generated from protobuf enum value: GE_BulletImpact = 461;
   */
  GE_BulletImpact = 461,
  /**
   * @generated from protobuf enum value: GE_EnableSatVolumesEvent = 462;
   */
  GE_EnableSatVolumesEvent = 462,
  /**
   * @generated from protobuf enum value: GE_PlaceSatVolumeEvent = 463;
   */
  GE_PlaceSatVolumeEvent = 463,
  /**
   * @generated from protobuf enum value: GE_DisableSatVolumesEvent = 464;
   */
  GE_DisableSatVolumesEvent = 464,
  /**
   * @generated from protobuf enum value: GE_RemoveSatVolumeEvent = 465;
   */
  GE_RemoveSatVolumeEvent = 465,
}
/**
 * @generated from protobuf enum PARTICLE_SYSTEM_MANAGER_MESSAGE
 */
export enum PARTICLE_SYSTEM_MANAGER_MESSAGE {
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_CREATE = 0;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_CREATE = 0,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY = 1;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY = 1,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING = 2;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_DESTROY_INVOLVING = 2,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE = 3;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_RELEASE = 3,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE = 4;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE = 4,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD = 5;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FORWARD = 5,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION = 6;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ORIENTATION = 6,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK = 7;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FALLBACK = 7,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT = 8;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_ENT = 8,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET = 9;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_OFFSET = 9,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN = 10;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_FROZEN = 10,
  /**
   * @generated from protobuf enum value: PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW = 11;
   */
  PARTICLE_SYSTEM_MANAGER_EVENT_UPDATE_SHOULD_DRAW = 11,
}
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFireBullets$Type extends MessageType<CMsgFireBullets> {
  constructor() {
    super("CMsgFireBullets", [
      { no: 1, name: "origin", kind: "message", T: () => CMsgVector },
      { no: 2, name: "angles", kind: "message", T: () => CMsgQAngle },
      {
        no: 4,
        name: "seed",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "shooter_entity",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 7,
        name: "ability",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: "penetration_percent",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 9,
        name: "spread",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 10,
        name: "fired_from_gun",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 11,
        name: "bullets_override",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 12,
        name: "tracer_replacement",
        kind: "message",
        T: () => CMsgFireBullets_TracerAssignment,
      },
      {
        no: 13,
        name: "tracer_additional",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CMsgFireBullets_TracerAssignment,
      },
      { no: 14, name: "angles_original", kind: "message", T: () => CMsgQAngle },
      {
        no: 15,
        name: "weapon_subclass_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "shot_number",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "ignore_entity",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 18,
        name: "max_range",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgFireBullets>): CMsgFireBullets {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.tracerAdditional = [];
    if (value !== undefined)
      reflectionMergePartial<CMsgFireBullets>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgFireBullets,
  ): CMsgFireBullets {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgVector origin */ 1:
          message.origin = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.origin,
          );
          break;
        case /* optional CMsgQAngle angles */ 2:
          message.angles = CMsgQAngle.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.angles,
          );
          break;
        case /* optional uint32 seed */ 4:
          message.seed = reader.uint32();
          break;
        case /* optional int32 shooter_entity */ 5:
          message.shooterEntity = reader.int32();
          break;
        case /* optional int32 ability */ 7:
          message.ability = reader.int32();
          break;
        case /* optional float penetration_percent */ 8:
          message.penetrationPercent = reader.float();
          break;
        case /* optional float spread */ 9:
          message.spread = reader.float();
          break;
        case /* optional bool fired_from_gun */ 10:
          message.firedFromGun = reader.bool();
          break;
        case /* optional uint32 bullets_override */ 11:
          message.bulletsOverride = reader.uint32();
          break;
        case /* optional CMsgFireBullets.TracerAssignment tracer_replacement */ 12:
          message.tracerReplacement =
            CMsgFireBullets_TracerAssignment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.tracerReplacement,
            );
          break;
        case /* repeated CMsgFireBullets.TracerAssignment tracer_additional */ 13:
          message.tracerAdditional.push(
            CMsgFireBullets_TracerAssignment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* optional CMsgQAngle angles_original */ 14:
          message.anglesOriginal = CMsgQAngle.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.anglesOriginal,
          );
          break;
        case /* optional uint32 weapon_subclass_id */ 15:
          message.weaponSubclassId = reader.uint32();
          break;
        case /* optional uint32 shot_number */ 16:
          message.shotNumber = reader.uint32();
          break;
        case /* optional int32 ignore_entity */ 17:
          message.ignoreEntity = reader.int32();
          break;
        case /* optional float max_range */ 18:
          message.maxRange = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgFireBullets,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgVector origin = 1; */
    if (message.origin)
      CMsgVector.internalBinaryWrite(
        message.origin,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgQAngle angles = 2; */
    if (message.angles)
      CMsgQAngle.internalBinaryWrite(
        message.angles,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 seed = 4; */
    if (message.seed !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.seed);
    /* optional int32 shooter_entity = 5; */
    if (message.shooterEntity !== undefined)
      writer.tag(5, WireType.Varint).int32(message.shooterEntity);
    /* optional int32 ability = 7; */
    if (message.ability !== undefined)
      writer.tag(7, WireType.Varint).int32(message.ability);
    /* optional float penetration_percent = 8; */
    if (message.penetrationPercent !== undefined)
      writer.tag(8, WireType.Bit32).float(message.penetrationPercent);
    /* optional float spread = 9; */
    if (message.spread !== undefined)
      writer.tag(9, WireType.Bit32).float(message.spread);
    /* optional bool fired_from_gun = 10; */
    if (message.firedFromGun !== undefined)
      writer.tag(10, WireType.Varint).bool(message.firedFromGun);
    /* optional uint32 bullets_override = 11; */
    if (message.bulletsOverride !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.bulletsOverride);
    /* optional CMsgFireBullets.TracerAssignment tracer_replacement = 12; */
    if (message.tracerReplacement)
      CMsgFireBullets_TracerAssignment.internalBinaryWrite(
        message.tracerReplacement,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated CMsgFireBullets.TracerAssignment tracer_additional = 13; */
    for (let i = 0; i < message.tracerAdditional.length; i++)
      CMsgFireBullets_TracerAssignment.internalBinaryWrite(
        message.tracerAdditional[i],
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgQAngle angles_original = 14; */
    if (message.anglesOriginal)
      CMsgQAngle.internalBinaryWrite(
        message.anglesOriginal,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 weapon_subclass_id = 15; */
    if (message.weaponSubclassId !== undefined)
      writer.tag(15, WireType.Varint).uint32(message.weaponSubclassId);
    /* optional uint32 shot_number = 16; */
    if (message.shotNumber !== undefined)
      writer.tag(16, WireType.Varint).uint32(message.shotNumber);
    /* optional int32 ignore_entity = 17; */
    if (message.ignoreEntity !== undefined)
      writer.tag(17, WireType.Varint).int32(message.ignoreEntity);
    /* optional float max_range = 18; */
    if (message.maxRange !== undefined)
      writer.tag(18, WireType.Bit32).float(message.maxRange);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgFireBullets
 */
export const CMsgFireBullets = new CMsgFireBullets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgFireBullets_TracerAssignment$Type extends MessageType<CMsgFireBullets_TracerAssignment> {
  constructor() {
    super("CMsgFireBullets.TracerAssignment", [
      {
        no: 1,
        name: "tracer_resource_id",
        kind: "scalar",
        opt: true,
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "bullet_indicies",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgFireBullets_TracerAssignment>,
  ): CMsgFireBullets_TracerAssignment {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgFireBullets_TracerAssignment>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgFireBullets_TracerAssignment,
  ): CMsgFireBullets_TracerAssignment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 tracer_resource_id */ 1:
          message.tracerResourceId = reader.uint64().toBigInt();
          break;
        case /* optional uint32 bullet_indicies */ 2:
          message.bulletIndicies = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgFireBullets_TracerAssignment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint64 tracer_resource_id = 1; */
    if (message.tracerResourceId !== undefined)
      writer.tag(1, WireType.Varint).uint64(message.tracerResourceId);
    /* optional uint32 bullet_indicies = 2; */
    if (message.bulletIndicies !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.bulletIndicies);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgFireBullets.TracerAssignment
 */
export const CMsgFireBullets_TracerAssignment =
  new CMsgFireBullets_TracerAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgBulletImpact$Type extends MessageType<CMsgBulletImpact> {
  constructor() {
    super("CMsgBulletImpact", [
      { no: 1, name: "trace_start", kind: "message", T: () => CMsgVector },
      { no: 2, name: "impact_origin", kind: "message", T: () => CMsgVector },
      { no: 3, name: "surface_normal", kind: "message", T: () => CMsgVector },
      {
        no: 4,
        name: "damage",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "surface_type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 7,
        name: "ability_entindex",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: "impacted_entindex",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "impacted_hitbox",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "weapon_subclass_id",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 11,
        name: "shooter_entindex",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgBulletImpact>): CMsgBulletImpact {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgBulletImpact>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgBulletImpact,
  ): CMsgBulletImpact {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgVector trace_start */ 1:
          message.traceStart = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.traceStart,
          );
          break;
        case /* optional CMsgVector impact_origin */ 2:
          message.impactOrigin = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.impactOrigin,
          );
          break;
        case /* optional CMsgVector surface_normal */ 3:
          message.surfaceNormal = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.surfaceNormal,
          );
          break;
        case /* optional uint32 damage */ 4:
          message.damage = reader.uint32();
          break;
        case /* optional uint32 surface_type */ 5:
          message.surfaceType = reader.uint32();
          break;
        case /* optional int32 ability_entindex */ 7:
          message.abilityEntindex = reader.int32();
          break;
        case /* optional int32 impacted_entindex */ 8:
          message.impactedEntindex = reader.int32();
          break;
        case /* optional uint32 impacted_hitbox */ 9:
          message.impactedHitbox = reader.uint32();
          break;
        case /* optional uint32 weapon_subclass_id */ 10:
          message.weaponSubclassId = reader.uint32();
          break;
        case /* optional int32 shooter_entindex */ 11:
          message.shooterEntindex = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgBulletImpact,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgVector trace_start = 1; */
    if (message.traceStart)
      CMsgVector.internalBinaryWrite(
        message.traceStart,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector impact_origin = 2; */
    if (message.impactOrigin)
      CMsgVector.internalBinaryWrite(
        message.impactOrigin,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector surface_normal = 3; */
    if (message.surfaceNormal)
      CMsgVector.internalBinaryWrite(
        message.surfaceNormal,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional uint32 damage = 4; */
    if (message.damage !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.damage);
    /* optional uint32 surface_type = 5; */
    if (message.surfaceType !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.surfaceType);
    /* optional int32 ability_entindex = 7; */
    if (message.abilityEntindex !== undefined)
      writer.tag(7, WireType.Varint).int32(message.abilityEntindex);
    /* optional int32 impacted_entindex = 8; */
    if (message.impactedEntindex !== undefined)
      writer.tag(8, WireType.Varint).int32(message.impactedEntindex);
    /* optional uint32 impacted_hitbox = 9; */
    if (message.impactedHitbox !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.impactedHitbox);
    /* optional uint32 weapon_subclass_id = 10; */
    if (message.weaponSubclassId !== undefined)
      writer.tag(10, WireType.Varint).uint32(message.weaponSubclassId);
    /* optional int32 shooter_entindex = 11; */
    if (message.shooterEntindex !== undefined)
      writer.tag(11, WireType.Varint).int32(message.shooterEntindex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgBulletImpact
 */
export const CMsgBulletImpact = new CMsgBulletImpact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPlayerAnimEvent$Type extends MessageType<CMsgPlayerAnimEvent> {
  constructor() {
    super("CMsgPlayerAnimEvent", [
      {
        no: 1,
        name: "player",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 2,
        name: "event",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "data",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgPlayerAnimEvent>): CMsgPlayerAnimEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgPlayerAnimEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgPlayerAnimEvent,
  ): CMsgPlayerAnimEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed32 player */ 1:
          message.player = reader.fixed32();
          break;
        case /* optional uint32 event */ 2:
          message.event = reader.uint32();
          break;
        case /* optional int32 data */ 3:
          message.data = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgPlayerAnimEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed32 player = 1; */
    if (message.player !== undefined)
      writer.tag(1, WireType.Bit32).fixed32(message.player);
    /* optional uint32 event = 2; */
    if (message.event !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.event);
    /* optional int32 data = 3; */
    if (message.data !== undefined)
      writer.tag(3, WireType.Varint).int32(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgPlayerAnimEvent
 */
export const CMsgPlayerAnimEvent = new CMsgPlayerAnimEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager$Type extends MessageType<CMsgParticleSystemManager> {
  constructor() {
    super("CMsgParticleSystemManager", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        T: () => [
          "PARTICLE_SYSTEM_MANAGER_MESSAGE",
          PARTICLE_SYSTEM_MANAGER_MESSAGE,
        ],
      },
      { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 3,
        name: "create_particle",
        kind: "message",
        T: () => CMsgParticleSystemManager_CreateParticle,
      },
      {
        no: 4,
        name: "destroy_particle",
        kind: "message",
        T: () => CMsgParticleSystemManager_DestroyParticle,
      },
      {
        no: 5,
        name: "destroy_particle_involving",
        kind: "message",
        T: () => CMsgParticleSystemManager_DestroyParticleInvolving,
      },
      {
        no: 6,
        name: "release_particle_index",
        kind: "message",
        T: () => CMsgParticleSystemManager_ReleaseParticleIndex,
      },
      {
        no: 7,
        name: "update_particle",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticle,
      },
      {
        no: 8,
        name: "update_particle_fwd",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleFwd,
      },
      {
        no: 9,
        name: "update_particle_orient",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleOrient,
      },
      {
        no: 10,
        name: "update_particle_fallback",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleFallback,
      },
      {
        no: 11,
        name: "update_particle_offset",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleOffset,
      },
      {
        no: 12,
        name: "update_particle_ent",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleEnt,
      },
      {
        no: 13,
        name: "update_particle_frozen",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleFrozen,
      },
      {
        no: 14,
        name: "update_particle_should_draw",
        kind: "message",
        T: () => CMsgParticleSystemManager_UpdateParticleShouldDraw,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager>,
  ): CMsgParticleSystemManager {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    message.index = 0;
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager,
  ): CMsgParticleSystemManager {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* PARTICLE_SYSTEM_MANAGER_MESSAGE type */ 1:
          message.type = reader.int32();
          break;
        case /* uint32 index */ 2:
          message.index = reader.uint32();
          break;
        case /* optional CMsgParticleSystemManager.CreateParticle create_particle */ 3:
          message.createParticle =
            CMsgParticleSystemManager_CreateParticle.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.createParticle,
            );
          break;
        case /* optional CMsgParticleSystemManager.DestroyParticle destroy_particle */ 4:
          message.destroyParticle =
            CMsgParticleSystemManager_DestroyParticle.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.destroyParticle,
            );
          break;
        case /* optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving */ 5:
          message.destroyParticleInvolving =
            CMsgParticleSystemManager_DestroyParticleInvolving.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.destroyParticleInvolving,
            );
          break;
        case /* optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index */ 6:
          message.releaseParticleIndex =
            CMsgParticleSystemManager_ReleaseParticleIndex.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.releaseParticleIndex,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticle update_particle */ 7:
          message.updateParticle =
            CMsgParticleSystemManager_UpdateParticle.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticle,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd */ 8:
          message.updateParticleFwd =
            CMsgParticleSystemManager_UpdateParticleFwd.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleFwd,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient */ 9:
          message.updateParticleOrient =
            CMsgParticleSystemManager_UpdateParticleOrient.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleOrient,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback */ 10:
          message.updateParticleFallback =
            CMsgParticleSystemManager_UpdateParticleFallback.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleFallback,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset */ 11:
          message.updateParticleOffset =
            CMsgParticleSystemManager_UpdateParticleOffset.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleOffset,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent */ 12:
          message.updateParticleEnt =
            CMsgParticleSystemManager_UpdateParticleEnt.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleEnt,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen */ 13:
          message.updateParticleFrozen =
            CMsgParticleSystemManager_UpdateParticleFrozen.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleFrozen,
            );
          break;
        case /* optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw */ 14:
          message.updateParticleShouldDraw =
            CMsgParticleSystemManager_UpdateParticleShouldDraw.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.updateParticleShouldDraw,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* PARTICLE_SYSTEM_MANAGER_MESSAGE type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    /* uint32 index = 2; */
    if (message.index !== 0)
      writer.tag(2, WireType.Varint).uint32(message.index);
    /* optional CMsgParticleSystemManager.CreateParticle create_particle = 3; */
    if (message.createParticle)
      CMsgParticleSystemManager_CreateParticle.internalBinaryWrite(
        message.createParticle,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.DestroyParticle destroy_particle = 4; */
    if (message.destroyParticle)
      CMsgParticleSystemManager_DestroyParticle.internalBinaryWrite(
        message.destroyParticle,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.DestroyParticleInvolving destroy_particle_involving = 5; */
    if (message.destroyParticleInvolving)
      CMsgParticleSystemManager_DestroyParticleInvolving.internalBinaryWrite(
        message.destroyParticleInvolving,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.ReleaseParticleIndex release_particle_index = 6; */
    if (message.releaseParticleIndex)
      CMsgParticleSystemManager_ReleaseParticleIndex.internalBinaryWrite(
        message.releaseParticleIndex,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticle update_particle = 7; */
    if (message.updateParticle)
      CMsgParticleSystemManager_UpdateParticle.internalBinaryWrite(
        message.updateParticle,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleFwd update_particle_fwd = 8; */
    if (message.updateParticleFwd)
      CMsgParticleSystemManager_UpdateParticleFwd.internalBinaryWrite(
        message.updateParticleFwd,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleOrient update_particle_orient = 9; */
    if (message.updateParticleOrient)
      CMsgParticleSystemManager_UpdateParticleOrient.internalBinaryWrite(
        message.updateParticleOrient,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleFallback update_particle_fallback = 10; */
    if (message.updateParticleFallback)
      CMsgParticleSystemManager_UpdateParticleFallback.internalBinaryWrite(
        message.updateParticleFallback,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleOffset update_particle_offset = 11; */
    if (message.updateParticleOffset)
      CMsgParticleSystemManager_UpdateParticleOffset.internalBinaryWrite(
        message.updateParticleOffset,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleEnt update_particle_ent = 12; */
    if (message.updateParticleEnt)
      CMsgParticleSystemManager_UpdateParticleEnt.internalBinaryWrite(
        message.updateParticleEnt,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleFrozen update_particle_frozen = 13; */
    if (message.updateParticleFrozen)
      CMsgParticleSystemManager_UpdateParticleFrozen.internalBinaryWrite(
        message.updateParticleFrozen,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgParticleSystemManager.UpdateParticleShouldDraw update_particle_should_draw = 14; */
    if (message.updateParticleShouldDraw)
      CMsgParticleSystemManager_UpdateParticleShouldDraw.internalBinaryWrite(
        message.updateParticleShouldDraw,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager
 */
export const CMsgParticleSystemManager = new CMsgParticleSystemManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_CreateParticle$Type extends MessageType<CMsgParticleSystemManager_CreateParticle> {
  constructor() {
    super("CMsgParticleSystemManager.CreateParticle", [
      {
        no: 1,
        name: "particle_name_index",
        kind: "scalar",
        opt: true,
        T: 6 /*ScalarType.FIXED64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: "attach_type",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "entity_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 4, name: "position", kind: "message", T: () => CMsgVector },
      { no: 5, name: "angles", kind: "message", T: () => CMsgQAngle },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_CreateParticle>,
  ): CMsgParticleSystemManager_CreateParticle {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_CreateParticle>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_CreateParticle,
  ): CMsgParticleSystemManager_CreateParticle {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional fixed64 particle_name_index */ 1:
          message.particleNameIndex = reader.fixed64().toBigInt();
          break;
        case /* optional int32 attach_type */ 2:
          message.attachType = reader.int32();
          break;
        case /* optional uint32 entity_handle */ 3:
          message.entityHandle = reader.uint32();
          break;
        case /* optional CMsgVector position */ 4:
          message.position = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        case /* optional CMsgQAngle angles */ 5:
          message.angles = CMsgQAngle.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.angles,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_CreateParticle,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional fixed64 particle_name_index = 1; */
    if (message.particleNameIndex !== undefined)
      writer.tag(1, WireType.Bit64).fixed64(message.particleNameIndex);
    /* optional int32 attach_type = 2; */
    if (message.attachType !== undefined)
      writer.tag(2, WireType.Varint).int32(message.attachType);
    /* optional uint32 entity_handle = 3; */
    if (message.entityHandle !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.entityHandle);
    /* optional CMsgVector position = 4; */
    if (message.position)
      CMsgVector.internalBinaryWrite(
        message.position,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgQAngle angles = 5; */
    if (message.angles)
      CMsgQAngle.internalBinaryWrite(
        message.angles,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.CreateParticle
 */
export const CMsgParticleSystemManager_CreateParticle =
  new CMsgParticleSystemManager_CreateParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_DestroyParticle$Type extends MessageType<CMsgParticleSystemManager_DestroyParticle> {
  constructor() {
    super("CMsgParticleSystemManager.DestroyParticle", [
      {
        no: 1,
        name: "destroy_immediately",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_DestroyParticle>,
  ): CMsgParticleSystemManager_DestroyParticle {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_DestroyParticle>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_DestroyParticle,
  ): CMsgParticleSystemManager_DestroyParticle {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool destroy_immediately */ 1:
          message.destroyImmediately = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_DestroyParticle,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool destroy_immediately = 1; */
    if (message.destroyImmediately !== undefined)
      writer.tag(1, WireType.Varint).bool(message.destroyImmediately);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.DestroyParticle
 */
export const CMsgParticleSystemManager_DestroyParticle =
  new CMsgParticleSystemManager_DestroyParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_DestroyParticleInvolving$Type extends MessageType<CMsgParticleSystemManager_DestroyParticleInvolving> {
  constructor() {
    super("CMsgParticleSystemManager.DestroyParticleInvolving", [
      {
        no: 1,
        name: "destroy_immediately",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "entity_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_DestroyParticleInvolving>,
  ): CMsgParticleSystemManager_DestroyParticleInvolving {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_DestroyParticleInvolving>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_DestroyParticleInvolving,
  ): CMsgParticleSystemManager_DestroyParticleInvolving {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool destroy_immediately */ 1:
          message.destroyImmediately = reader.bool();
          break;
        case /* optional uint32 entity_handle */ 3:
          message.entityHandle = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_DestroyParticleInvolving,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool destroy_immediately = 1; */
    if (message.destroyImmediately !== undefined)
      writer.tag(1, WireType.Varint).bool(message.destroyImmediately);
    /* optional uint32 entity_handle = 3; */
    if (message.entityHandle !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.entityHandle);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.DestroyParticleInvolving
 */
export const CMsgParticleSystemManager_DestroyParticleInvolving =
  new CMsgParticleSystemManager_DestroyParticleInvolving$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_ReleaseParticleIndex$Type extends MessageType<CMsgParticleSystemManager_ReleaseParticleIndex> {
  constructor() {
    super("CMsgParticleSystemManager.ReleaseParticleIndex", []);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_ReleaseParticleIndex>,
  ): CMsgParticleSystemManager_ReleaseParticleIndex {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_ReleaseParticleIndex>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_ReleaseParticleIndex,
  ): CMsgParticleSystemManager_ReleaseParticleIndex {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_ReleaseParticleIndex,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.ReleaseParticleIndex
 */
export const CMsgParticleSystemManager_ReleaseParticleIndex =
  new CMsgParticleSystemManager_ReleaseParticleIndex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticle$Type extends MessageType<CMsgParticleSystemManager_UpdateParticle> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticle", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "position", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticle>,
  ): CMsgParticleSystemManager_UpdateParticle {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticle>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticle,
  ): CMsgParticleSystemManager_UpdateParticle {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional CMsgVector position */ 2:
          message.position = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticle,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional CMsgVector position = 2; */
    if (message.position)
      CMsgVector.internalBinaryWrite(
        message.position,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticle
 */
export const CMsgParticleSystemManager_UpdateParticle =
  new CMsgParticleSystemManager_UpdateParticle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFwd$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFwd> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleFwd", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "forward", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFwd>,
  ): CMsgParticleSystemManager_UpdateParticleFwd {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFwd>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleFwd,
  ): CMsgParticleSystemManager_UpdateParticleFwd {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional CMsgVector forward */ 2:
          message.forward = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.forward,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleFwd,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional CMsgVector forward = 2; */
    if (message.forward)
      CMsgVector.internalBinaryWrite(
        message.forward,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFwd
 */
export const CMsgParticleSystemManager_UpdateParticleFwd =
  new CMsgParticleSystemManager_UpdateParticleFwd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleOrient$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleOrient> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleOrient", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "forward", kind: "message", T: () => CMsgVector },
      { no: 3, name: "left", kind: "message", T: () => CMsgVector },
      { no: 4, name: "up", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleOrient>,
  ): CMsgParticleSystemManager_UpdateParticleOrient {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleOrient>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleOrient,
  ): CMsgParticleSystemManager_UpdateParticleOrient {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional CMsgVector forward */ 2:
          message.forward = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.forward,
          );
          break;
        case /* optional CMsgVector left */ 3:
          message.left = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.left,
          );
          break;
        case /* optional CMsgVector up */ 4:
          message.up = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.up,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleOrient,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional CMsgVector forward = 2; */
    if (message.forward)
      CMsgVector.internalBinaryWrite(
        message.forward,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector left = 3; */
    if (message.left)
      CMsgVector.internalBinaryWrite(
        message.left,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector up = 4; */
    if (message.up)
      CMsgVector.internalBinaryWrite(
        message.up,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleOrient
 */
export const CMsgParticleSystemManager_UpdateParticleOrient =
  new CMsgParticleSystemManager_UpdateParticleOrient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFallback$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFallback> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleFallback", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "position", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFallback>,
  ): CMsgParticleSystemManager_UpdateParticleFallback {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFallback>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleFallback,
  ): CMsgParticleSystemManager_UpdateParticleFallback {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional CMsgVector position */ 2:
          message.position = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleFallback,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional CMsgVector position = 2; */
    if (message.position)
      CMsgVector.internalBinaryWrite(
        message.position,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFallback
 */
export const CMsgParticleSystemManager_UpdateParticleFallback =
  new CMsgParticleSystemManager_UpdateParticleFallback$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleEnt$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleEnt> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleEnt", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: "entity_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "attach_type",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "attachment",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 5,
        name: "fallback_position",
        kind: "message",
        T: () => CMsgVector,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleEnt>,
  ): CMsgParticleSystemManager_UpdateParticleEnt {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleEnt>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleEnt,
  ): CMsgParticleSystemManager_UpdateParticleEnt {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional uint32 entity_handle */ 2:
          message.entityHandle = reader.uint32();
          break;
        case /* optional int32 attach_type */ 3:
          message.attachType = reader.int32();
          break;
        case /* optional int32 attachment */ 4:
          message.attachment = reader.int32();
          break;
        case /* optional CMsgVector fallback_position */ 5:
          message.fallbackPosition = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.fallbackPosition,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleEnt,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional uint32 entity_handle = 2; */
    if (message.entityHandle !== undefined)
      writer.tag(2, WireType.Varint).uint32(message.entityHandle);
    /* optional int32 attach_type = 3; */
    if (message.attachType !== undefined)
      writer.tag(3, WireType.Varint).int32(message.attachType);
    /* optional int32 attachment = 4; */
    if (message.attachment !== undefined)
      writer.tag(4, WireType.Varint).int32(message.attachment);
    /* optional CMsgVector fallback_position = 5; */
    if (message.fallbackPosition)
      CMsgVector.internalBinaryWrite(
        message.fallbackPosition,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleEnt
 */
export const CMsgParticleSystemManager_UpdateParticleEnt =
  new CMsgParticleSystemManager_UpdateParticleEnt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleOffset$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleOffset> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleOffset", [
      {
        no: 1,
        name: "control_point",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 2, name: "origin_offset", kind: "message", T: () => CMsgVector },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleOffset>,
  ): CMsgParticleSystemManager_UpdateParticleOffset {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleOffset>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleOffset,
  ): CMsgParticleSystemManager_UpdateParticleOffset {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 control_point */ 1:
          message.controlPoint = reader.int32();
          break;
        case /* optional CMsgVector origin_offset */ 2:
          message.originOffset = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.originOffset,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleOffset,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 control_point = 1; */
    if (message.controlPoint !== undefined)
      writer.tag(1, WireType.Varint).int32(message.controlPoint);
    /* optional CMsgVector origin_offset = 2; */
    if (message.originOffset)
      CMsgVector.internalBinaryWrite(
        message.originOffset,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleOffset
 */
export const CMsgParticleSystemManager_UpdateParticleOffset =
  new CMsgParticleSystemManager_UpdateParticleOffset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleFrozen$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleFrozen> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleFrozen", [
      {
        no: 1,
        name: "set_frozen",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleFrozen>,
  ): CMsgParticleSystemManager_UpdateParticleFrozen {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleFrozen>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleFrozen,
  ): CMsgParticleSystemManager_UpdateParticleFrozen {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool set_frozen */ 1:
          message.setFrozen = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleFrozen,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool set_frozen = 1; */
    if (message.setFrozen !== undefined)
      writer.tag(1, WireType.Varint).bool(message.setFrozen);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleFrozen
 */
export const CMsgParticleSystemManager_UpdateParticleFrozen =
  new CMsgParticleSystemManager_UpdateParticleFrozen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgParticleSystemManager_UpdateParticleShouldDraw$Type extends MessageType<CMsgParticleSystemManager_UpdateParticleShouldDraw> {
  constructor() {
    super("CMsgParticleSystemManager.UpdateParticleShouldDraw", [
      {
        no: 1,
        name: "should_draw",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgParticleSystemManager_UpdateParticleShouldDraw>,
  ): CMsgParticleSystemManager_UpdateParticleShouldDraw {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgParticleSystemManager_UpdateParticleShouldDraw>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgParticleSystemManager_UpdateParticleShouldDraw,
  ): CMsgParticleSystemManager_UpdateParticleShouldDraw {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool should_draw */ 1:
          message.shouldDraw = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgParticleSystemManager_UpdateParticleShouldDraw,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional bool should_draw = 1; */
    if (message.shouldDraw !== undefined)
      writer.tag(1, WireType.Varint).bool(message.shouldDraw);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgParticleSystemManager.UpdateParticleShouldDraw
 */
export const CMsgParticleSystemManager_UpdateParticleShouldDraw =
  new CMsgParticleSystemManager_UpdateParticleShouldDraw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgScreenTextPretty$Type extends MessageType<CMsgScreenTextPretty> {
  constructor() {
    super("CMsgScreenTextPretty", [
      {
        no: 1,
        name: "x_pos",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: "y_pos",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "line",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "r",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 6,
        name: "g",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 7,
        name: "b",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 8,
        name: "a",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "duration",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 10,
        name: "font_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 11,
        name: "font_size",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 12,
        name: "bold_font",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<CMsgScreenTextPretty>): CMsgScreenTextPretty {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgScreenTextPretty>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgScreenTextPretty,
  ): CMsgScreenTextPretty {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional float x_pos */ 1:
          message.xPos = reader.float();
          break;
        case /* optional float y_pos */ 2:
          message.yPos = reader.float();
          break;
        case /* optional int32 line */ 3:
          message.line = reader.int32();
          break;
        case /* optional string text */ 4:
          message.text = reader.string();
          break;
        case /* optional int32 r */ 5:
          message.r = reader.int32();
          break;
        case /* optional int32 g */ 6:
          message.g = reader.int32();
          break;
        case /* optional int32 b */ 7:
          message.b = reader.int32();
          break;
        case /* optional int32 a */ 8:
          message.a = reader.int32();
          break;
        case /* optional float duration */ 9:
          message.duration = reader.float();
          break;
        case /* optional string font_name */ 10:
          message.fontName = reader.string();
          break;
        case /* optional int32 font_size */ 11:
          message.fontSize = reader.int32();
          break;
        case /* optional bool bold_font */ 12:
          message.boldFont = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgScreenTextPretty,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional float x_pos = 1; */
    if (message.xPos !== undefined)
      writer.tag(1, WireType.Bit32).float(message.xPos);
    /* optional float y_pos = 2; */
    if (message.yPos !== undefined)
      writer.tag(2, WireType.Bit32).float(message.yPos);
    /* optional int32 line = 3; */
    if (message.line !== undefined)
      writer.tag(3, WireType.Varint).int32(message.line);
    /* optional string text = 4; */
    if (message.text !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.text);
    /* optional int32 r = 5; */
    if (message.r !== undefined)
      writer.tag(5, WireType.Varint).int32(message.r);
    /* optional int32 g = 6; */
    if (message.g !== undefined)
      writer.tag(6, WireType.Varint).int32(message.g);
    /* optional int32 b = 7; */
    if (message.b !== undefined)
      writer.tag(7, WireType.Varint).int32(message.b);
    /* optional int32 a = 8; */
    if (message.a !== undefined)
      writer.tag(8, WireType.Varint).int32(message.a);
    /* optional float duration = 9; */
    if (message.duration !== undefined)
      writer.tag(9, WireType.Bit32).float(message.duration);
    /* optional string font_name = 10; */
    if (message.fontName !== undefined)
      writer.tag(10, WireType.LengthDelimited).string(message.fontName);
    /* optional int32 font_size = 11; */
    if (message.fontSize !== undefined)
      writer.tag(11, WireType.Varint).int32(message.fontSize);
    /* optional bool bold_font = 12; */
    if (message.boldFont !== undefined)
      writer.tag(12, WireType.Varint).bool(message.boldFont);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgScreenTextPretty
 */
export const CMsgScreenTextPretty = new CMsgScreenTextPretty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgServerRequestedTracer$Type extends MessageType<CMsgServerRequestedTracer> {
  constructor() {
    super("CMsgServerRequestedTracer", [
      { no: 1, name: "origin", kind: "message", T: () => CMsgVector },
      { no: 2, name: "end", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "weaponid",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "entity_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 5,
        name: "dps",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgServerRequestedTracer>,
  ): CMsgServerRequestedTracer {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgServerRequestedTracer>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgServerRequestedTracer,
  ): CMsgServerRequestedTracer {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgVector origin */ 1:
          message.origin = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.origin,
          );
          break;
        case /* optional CMsgVector end */ 2:
          message.end = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.end,
          );
          break;
        case /* optional int32 weaponid */ 3:
          message.weaponid = reader.int32();
          break;
        case /* optional uint32 entity_handle */ 4:
          message.entityHandle = reader.uint32();
          break;
        case /* optional float dps */ 5:
          message.dps = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgServerRequestedTracer,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgVector origin = 1; */
    if (message.origin)
      CMsgVector.internalBinaryWrite(
        message.origin,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector end = 2; */
    if (message.end)
      CMsgVector.internalBinaryWrite(
        message.end,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional int32 weaponid = 3; */
    if (message.weaponid !== undefined)
      writer.tag(3, WireType.Varint).int32(message.weaponid);
    /* optional uint32 entity_handle = 4; */
    if (message.entityHandle !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.entityHandle);
    /* optional float dps = 5; */
    if (message.dps !== undefined)
      writer.tag(5, WireType.Bit32).float(message.dps);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgServerRequestedTracer
 */
export const CMsgServerRequestedTracer = new CMsgServerRequestedTracer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgEnableSatVolumesEvent$Type extends MessageType<CMsgEnableSatVolumesEvent> {
  constructor() {
    super("CMsgEnableSatVolumesEvent", [
      {
        no: 1,
        name: "mode",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "desat_amount",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 3,
        name: "sat_tint",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 4,
        name: "desat_tint",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
      {
        no: 5,
        name: "outline_color",
        kind: "scalar",
        opt: true,
        T: 7 /*ScalarType.FIXED32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgEnableSatVolumesEvent>,
  ): CMsgEnableSatVolumesEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgEnableSatVolumesEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgEnableSatVolumesEvent,
  ): CMsgEnableSatVolumesEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 mode */ 1:
          message.mode = reader.uint32();
          break;
        case /* optional float desat_amount */ 2:
          message.desatAmount = reader.float();
          break;
        case /* optional fixed32 sat_tint */ 3:
          message.satTint = reader.fixed32();
          break;
        case /* optional fixed32 desat_tint */ 4:
          message.desatTint = reader.fixed32();
          break;
        case /* optional fixed32 outline_color */ 5:
          message.outlineColor = reader.fixed32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgEnableSatVolumesEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional uint32 mode = 1; */
    if (message.mode !== undefined)
      writer.tag(1, WireType.Varint).uint32(message.mode);
    /* optional float desat_amount = 2; */
    if (message.desatAmount !== undefined)
      writer.tag(2, WireType.Bit32).float(message.desatAmount);
    /* optional fixed32 sat_tint = 3; */
    if (message.satTint !== undefined)
      writer.tag(3, WireType.Bit32).fixed32(message.satTint);
    /* optional fixed32 desat_tint = 4; */
    if (message.desatTint !== undefined)
      writer.tag(4, WireType.Bit32).fixed32(message.desatTint);
    /* optional fixed32 outline_color = 5; */
    if (message.outlineColor !== undefined)
      writer.tag(5, WireType.Bit32).fixed32(message.outlineColor);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgEnableSatVolumesEvent
 */
export const CMsgEnableSatVolumesEvent = new CMsgEnableSatVolumesEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgPlaceSatVolumeEvent$Type extends MessageType<CMsgPlaceSatVolumeEvent> {
  constructor() {
    super("CMsgPlaceSatVolumeEvent", [
      { no: 1, name: "position", kind: "message", T: () => CMsgVector },
      { no: 2, name: "direction", kind: "message", T: () => CMsgVector },
      {
        no: 3,
        name: "radius",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 4,
        name: "falloff_distance",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 5,
        name: "theta_dot",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 6,
        name: "phi_dot",
        kind: "scalar",
        opt: true,
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 7,
        name: "entity_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 8,
        name: "attachment_handle",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "type",
        kind: "scalar",
        opt: true,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "volume_id",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgPlaceSatVolumeEvent>,
  ): CMsgPlaceSatVolumeEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgPlaceSatVolumeEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgPlaceSatVolumeEvent,
  ): CMsgPlaceSatVolumeEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional CMsgVector position */ 1:
          message.position = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        case /* optional CMsgVector direction */ 2:
          message.direction = CMsgVector.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.direction,
          );
          break;
        case /* optional float radius */ 3:
          message.radius = reader.float();
          break;
        case /* optional float falloff_distance */ 4:
          message.falloffDistance = reader.float();
          break;
        case /* optional float theta_dot */ 5:
          message.thetaDot = reader.float();
          break;
        case /* optional float phi_dot */ 6:
          message.phiDot = reader.float();
          break;
        case /* optional uint32 entity_handle */ 7:
          message.entityHandle = reader.uint32();
          break;
        case /* optional uint32 attachment_handle */ 8:
          message.attachmentHandle = reader.uint32();
          break;
        case /* optional uint32 type */ 9:
          message.type = reader.uint32();
          break;
        case /* optional int32 volume_id */ 10:
          message.volumeId = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgPlaceSatVolumeEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional CMsgVector position = 1; */
    if (message.position)
      CMsgVector.internalBinaryWrite(
        message.position,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional CMsgVector direction = 2; */
    if (message.direction)
      CMsgVector.internalBinaryWrite(
        message.direction,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional float radius = 3; */
    if (message.radius !== undefined)
      writer.tag(3, WireType.Bit32).float(message.radius);
    /* optional float falloff_distance = 4; */
    if (message.falloffDistance !== undefined)
      writer.tag(4, WireType.Bit32).float(message.falloffDistance);
    /* optional float theta_dot = 5; */
    if (message.thetaDot !== undefined)
      writer.tag(5, WireType.Bit32).float(message.thetaDot);
    /* optional float phi_dot = 6; */
    if (message.phiDot !== undefined)
      writer.tag(6, WireType.Bit32).float(message.phiDot);
    /* optional uint32 entity_handle = 7; */
    if (message.entityHandle !== undefined)
      writer.tag(7, WireType.Varint).uint32(message.entityHandle);
    /* optional uint32 attachment_handle = 8; */
    if (message.attachmentHandle !== undefined)
      writer.tag(8, WireType.Varint).uint32(message.attachmentHandle);
    /* optional uint32 type = 9; */
    if (message.type !== undefined)
      writer.tag(9, WireType.Varint).uint32(message.type);
    /* optional int32 volume_id = 10; */
    if (message.volumeId !== undefined)
      writer.tag(10, WireType.Varint).int32(message.volumeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgPlaceSatVolumeEvent
 */
export const CMsgPlaceSatVolumeEvent = new CMsgPlaceSatVolumeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgRemoveSatVolumeEvent$Type extends MessageType<CMsgRemoveSatVolumeEvent> {
  constructor() {
    super("CMsgRemoveSatVolumeEvent", [
      {
        no: 1,
        name: "volume_id",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CMsgRemoveSatVolumeEvent>,
  ): CMsgRemoveSatVolumeEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgRemoveSatVolumeEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgRemoveSatVolumeEvent,
  ): CMsgRemoveSatVolumeEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 volume_id */ 1:
          message.volumeId = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CMsgRemoveSatVolumeEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int32 volume_id = 1; */
    if (message.volumeId !== undefined)
      writer.tag(1, WireType.Varint).int32(message.volumeId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgRemoveSatVolumeEvent
 */
export const CMsgRemoveSatVolumeEvent = new CMsgRemoveSatVolumeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CMsgDisableSatVolumesEvent$Type extends MessageType<CMsgDisableSatVolumesEvent> {
  constructor() {
    super("CMsgDisableSatVolumesEvent", []);
  }
  create(
    value?: PartialMessage<CMsgDisableSatVolumesEvent>,
  ): CMsgDisableSatVolumesEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CMsgDisableSatVolumesEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CMsgDisableSatVolumesEvent,
  ): CMsgDisableSatVolumesEvent {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CMsgDisableSatVolumesEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message CMsgDisableSatVolumesEvent
 */
export const CMsgDisableSatVolumesEvent = new CMsgDisableSatVolumesEvent$Type();
